<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java进阶之并发编程（三）AQS详解</title>
      <link href="/2023/03/27/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/03/27/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是JUC"><a href="#一、什么是JUC" class="headerlink" title="一、什么是JUC"></a>一、什么是JUC</h3><p>JUC指的是Java并发编程工具包（Java Concurrency Utilities），它提供了一系列的工具类和接口，用于简化并发编程的开发。虽然Java语言中已经提供了synchronized关键字来支持多线程并发编程，但是JUC提供了更加灵活和高效的实现方式，以满足更加复杂的并发编程需求。</p><p>具体来说，JUC提供了以下几个重要的类和接口：</p><ol><li>Lock和Condition：Lock和Condition是替代synchronized关键字的工具，它们提供了更加灵活和可控的线程同步机制，使得在高并发情况下能够更加高效地协调线程之间的交互。</li><li>Semaphore：Semaphore是一种计数信号量，它可以用来控制同时访问某个资源的线程数量。</li><li>CountDownLatch：CountDownLatch是一种倒计数器，它可以让一个线程等待多个其他线程执行完毕后再继续执行。</li><li>CyclicBarrier：CyclicBarrier也是一种倒计数器，它可以让多个线程相互等待，直到所有线程都到达某个屏障点后再一起继续执行。</li><li>Executor和ExecutorService：Executor和ExecutorService是线程池的实现，它们可以有效地管理和控制线程的数量，从而避免创建过多的线程导致系统资源浪费和性能下降。</li></ol><p>综上所述，虽然synchronized关键字可以实现基本的线程同步和互斥，但在高并发情况下，JUC提供的工具类和接口能够更加灵活和高效地协调线程之间的交互，从而提高程序的性能和可靠性。</p><p>在正式介绍JUC之前，先思考一个问题，那就是如果让我们自己实现一个类似sychronized的锁机制，我们要如何去设计呢？</p><p><strong>锁设计猜想</strong></p><ul><li><p>一定会设计到锁的抢占 ， 需要有一个标记来实现互斥。 全局变量(0，1)</p></li><li><p>抢占到了锁，怎么处理(不需要处理.)</p></li><li><p>没抢占到锁，怎么处理</p><ul><li>需要等待(让处于排队中的线程，如果没有抢占到锁，则直接先阻塞-&gt;释放CPU资源)。 <ul><li>如何让线程等待?<ul><li>wait&#x2F;notify(线程通信的机制，<strong>无法指定唤醒某个线</strong>程)</li><li><strong>LockSupport.park&#x2F;unpark</strong>(阻塞一个指定的线程，唤醒一个指定的线程) Condition</li></ul></li></ul></li><li>需要排队(允许有N个线程被阻塞，此时线程处于活跃状态)。 <ul><li>通过一个数据结构，把这N个排队的线程存储起来。</li></ul></li></ul></li><li><p>抢占到锁的释放过程，如何处理</p><ul><li>LockSupport.unpark() -&gt; 唤醒处于队列中的指定线程.</li></ul></li><li><p>锁抢占的公平性(是否允许插队)</p></li><li><p>公平 </p></li><li><p>非公平</p></li></ul><p>在JUC中，AQS（AbstractQueuedSynchronizer）即是实现上述过程的一个框架类</p><h3 id="二、AQS"><a href="#二、AQS" class="headerlink" title="二、AQS"></a>二、AQS</h3><p>AQS（AbstractQueuedSynchronizer）是一个用于构建锁、同步器等并发组件的框架，它是Java并发包（java.util.concurrent）的核心组件之一。</p><p>首先介绍一下AQS中用到的一些类与变量</p><h4 id="1-内部类—Node"><a href="#1-内部类—Node" class="headerlink" title="1.内部类—Node"></a>1.内部类—Node</h4><p>Node作为等待队列节点类，在线程竞争锁失败后，AQS会将线程封装成一个Node节点，放入等待队列当中，自旋等待，自旋竞争再次失败后就会进入等待状态，等待被唤醒再次竞争锁</p><p>Node类包含以下主要字段：</p><ol><li>prev：指向前一个节点的指针。</li><li>next：指向后一个节点的指针。</li><li>thread：持有该节点的线程对象。</li><li>waitStatus：用于表示线程的状态，包括取消、阻塞、等待等。</li><li>nextWaiter：用于在等待队列中链接不同条件的线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     +------+  prev +-----+       +-----+</span><br><span class="line">head |      | &lt;---- |     | &lt;---- |     |  tail</span><br><span class="line">     +------+       +-----+       +-----+</span><br></pre></td></tr></table></figure><p>Node类源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">/** 标识共享模式的静态常量，它被用于表示线程等待的条件是共享的，而不是独占的 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="comment">/** 标识独占模式的静态常量，它被用于表示线程等待的条件是独占的，而不是共享的 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 用于标记一个节点已经被取消，不再参与同步操作 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** 用于表示一个节点已经被唤醒，并且可以尝试竞争同步资源 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">  *是一个表示节点所属的条件队列的静态常量。它被用于区分节点所属的等待队列和条件队列</span></span><br><span class="line"><span class="comment">  * 每个节点在创建时，都会与一个特定的条件队列相关联。</span></span><br><span class="line"><span class="comment">* 当节点被添加到等待队列中时，它的CONDITION字段会被设置为与它相关联的条件队列。</span></span><br><span class="line"><span class="comment">* 在等待队列中，节点的状态为WAITING或SIGNAL；而在条件队列中，节点的状态为CONDITION。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/** 标志表示当前节点需要向后传播唤醒信号，通知后继节点可以尝试获取锁 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"><span class="comment">/** 表示持有锁或正在等待锁的线程 */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 指向同步队列头</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指向同步队列尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure><p>同步队列是AQS中一个重要的概念，用于实现线程的阻塞和唤醒，以及线程的竞争获取同步状态。</p><p>AQS中包含了三种队列概念：等待队列、条件队列和同步队列。</p><ol><li><strong>等待队列</strong>（Wait Queue）：等待队列是AQS中用于存放<strong>被阻塞</strong>的线程的数据结构。当一个线程需要获取同步状态，但是当前同步状态已经被其他线程占用时，该线程会被封装成一个Node节点并加入到等待队列中。等待队列是一个FIFO队列，可以保证等待时间最长的线程先被唤醒。</li><li><strong>条件队列</strong>（Condition Queue）：条件队列是<strong>基于等待队列</strong>实现的，用于支持条件变量的功能。当一个线程需要等待一个条件变量时，它会被封装成一个Node节点并加入到条件队列中，而不是等待队列中。当满足条件时，条件队列中的线程会被转移至等待队列中等待获取同步状态。</li><li><strong>同步队列</strong>（Sync Queue）：同步队列是AQS中存放<strong>已经获取到同步状态的线程（即通过acquire获取成功）</strong>的数据结构。当一个线程获取到同步状态后，它会从等待队列中转移到同步队列中，并且会释放之前占有的同步状态。同步队列的管理是通过head和tail指针实现的，head指向同步队列的第一个节点，tail指向同步队列的最后一个节点。</li></ol><blockquote><p>此外，还需要注意<code>exclusiveOwnerThread</code>这个变量，它来自于AQS的抽象父类<code>AbstractOwnableSynchronizer</code>，该类就两个方法，分别是设置和获取该变量<code>exclusiveOwnerThread</code></p></blockquote><h4 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a>3.方法</h4><p>AQS中的几个重要方法如下：</p><ol><li>acquire(int arg)：尝试获取独占锁，如果获取失败，则将当前线程加入同步队列并进行自旋或者阻塞，直到获取成功或者被中断。</li><li>acquireShared(int arg)：尝试获取共享锁，如果获取失败，则将当前线程加入同步队列并进行自旋或者阻塞，直到获取成功或者被中断。</li><li>release(int arg)：释放独占锁。</li><li>releaseShared(int arg)：释放共享锁。</li><li>tryAcquire(int arg)：尝试获取独占锁，如果获取成功，则返回true，否则返回false。</li><li>tryAcquireShared(int arg)：尝试获取共享锁，如果获取成功，则返回一个大于等于0的值，表示获取共享锁的线程数，否则返回负数。</li><li>tryRelease(int arg)：尝试释放独占锁，如果成功则返回true，否则返回false。</li><li>tryReleaseShared(int arg)：尝试释放共享锁，如果成功则返回true，否则返回false。</li><li>acquireInterruptibly(int arg)：尝试获取独占锁，如果获取失败，则将当前线程加入同步队列并进行自旋或者阻塞，直到获取成功或者被中断。</li></ol><p>这些方法是AQS中的核心方法，用于实现同步和互斥。</p><ul><li><p>acquire()、acquireShared()、release()、releaseShared() 是AQS中最常用的同步方法</p></li><li><p>tryAcquire()、tryAcquireShared()、tryRelease()、tryReleaseShared() 则是尝试获取&#x2F;释放同步状态，这些方法一般是被重载后使用。</p></li><li><p>acquireInterruptibly() 方法也是尝试获取独占锁，不过它会响应中断。</p></li></ul><h5 id="1）compareAndSetState"><a href="#1）compareAndSetState" class="headerlink" title="1）compareAndSetState"></a><strong>1）compareAndSetState</strong></h5><p>AQS中通过state变量来标识同步状态，为了保证state参数修改的可见性、原子性，在AQS当中使用CAS机制来进行state的修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）acquire"><a href="#2）acquire" class="headerlink" title="2）acquire"></a><strong>2）acquire</strong></h5><p>尝试获取独占锁，如果获取失败，则将当前线程加入同步队列并进行自旋或者阻塞，直到获取成功或者被中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>tryAcquire</code> 是 AQS 中一个抽象方法，需要用户自定义实现。在 AQS 中，同步状态的获取和释放都是通过 <code>tryAcquire</code> 和 <code>tryRelease</code> 方法实现的，因此用户可以根据自己的需求来定义同步状态的获取和释放逻辑。</p><p><code>addWaiter</code> 方法是 AQS 中的一个辅助方法，用于将一个新的 <code>Node</code> 节点加入到等待队列中，并返回这个新节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，AQS中的<code>enq</code>方法用于将线程加入到等待队列中，实现方式是通过CAS（compare-and-swap）操作将节点插入到队尾，保证线程的插入是原子性的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquireQueued传入<code>addWaiter</code> 方法返回的节点，一丝是在线程被包装成节点入队之后，还会尝试调用自旋来获取锁，步骤如下：</p><ol><li>尝试获取锁，如果成功则直接返回。</li><li>如果获取锁失败，则线程会进入自旋状态，不断地检查前驱节点的状态是否为 SIGNAL。</li><li>如果前驱节点状态为 SIGNAL，说明当前线程可以尝试获取同步状态了，于是调用tryAcquire方法再次尝试获取锁。</li><li>如果获取锁成功，则当前线程会从等待队列中移除，并返回。</li><li>如果tryAcquire方法返回false，则当前线程会继续自旋等待前驱节点唤醒自己。</li></ol><blockquote><p>acquireQueued方法中的自旋是在等待前驱节点释放锁的过程中进行的，如果等待时间过长，一般是由于前驱节点无法释放锁，这时会进入阻塞状态。在进入阻塞状态前，会将自己的节点状态设置为WAITING，并通过LockSupport.park()方法挂起线程，等待前驱节点的唤醒。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node表示当前来抢占锁的线程</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 自旋</span></span><br><span class="line">          <span class="comment">// 尝试去获得锁</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 返回true，不需要等待直接返回</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 否则让线程去阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于在当前线程上阻塞，直到被其他线程唤醒或中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>); <span class="comment">// 使当前线程阻塞</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 返回当前线程中断状态，即是否被中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3）acquireShared"><a href="#3）acquireShared" class="headerlink" title="3）acquireShared"></a><strong>3）acquireShared</strong></h5><p>尝试获取共享锁，如果获取失败，则将当前线程加入同步队列并进行自旋或者阻塞，直到获取成功或者被中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4）release"><a href="#4）release" class="headerlink" title="4）release"></a><strong>4）release</strong></h5><p>释放独占锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，tryRelease交给子类实现</p><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p>AQS是一个用于构建同步器的框架，它为子类提供了许多方法，使得子类仅需要重写部分方法就可以方便的实现同步功能，下面是AQS为子类提供的一些公共功能</p><ol><li>获取&#x2F;释放锁：AQS提供了acquire()和release()两个方法，这两个方法是获取锁和释放锁的基础。</li><li>等待队列的操作：AQS提供了许多操作等待队列的方法，例如enq()、deq()、transferForSignal()等等。这些方法让子类能够方便地实现等待队列的管理。</li><li>条件队列的操作：AQS还提供了一些操作条件队列的方法，例如addConditionWaiter()、transferAfterCancelledWait()等等。这些方法可以让子类方便地实现条件队列的管理。</li><li>重入锁的实现：AQS还提供了一些方法，可以方便地实现重入锁。例如tryAcquire()、tryRelease()等等。</li><li>共享锁的实现：AQS提供了一些方法，可以方便地实现共享锁。例如tryAcquireShared()、tryReleaseShared()等等。</li><li>线程的中断处理：AQS提供了interruptMode()和clearInterruptsForReentry()两个方法，可以方便地处理线程中断的情况。</li></ol><p>总的来说，AQS并没有定义具体的加锁和释放锁的逻辑，而是通过子类来实现这些逻辑，同时提供了一些钩子方法，使得子类可以在特定的时间点进行扩展和定制。这种设计能够提高复用性和灵活性，使得开发者可以快速地构建出各种同步器，以满足不同的需求。</p><p>其中，子类至少需要重写以下方法：</p><ol><li><strong>tryAcquire</strong>(int)：尝试以独占模式获取同步状态，如果获取成功，返回true，否则返回false。</li><li><strong>tryRelease</strong>(int)：尝试以独占模式释放同步状态，如果释放成功，返回true，否则返回false。</li><li><strong>tryAcquireShared</strong>(int)：尝试以共享模式获取同步状态，如果获取成功，返回大于等于0的值，否则返回小于0的值。</li><li><strong>tryReleaseShared</strong>(int)：尝试以共享模式释放同步状态，如果释放成功，返回true，否则返回false。</li></ol><h3 id="三、ReentrantLock类"><a href="#三、ReentrantLock类" class="headerlink" title="三、ReentrantLock类"></a>三、ReentrantLock类</h3><h4 id="1-基础分析"><a href="#1-基础分析" class="headerlink" title="1.基础分析"></a>1.基础分析</h4><p>ReentrantLock并不是直接继承了AQS抽象类，而是定义了一个内部类来继承AQS，并在此基础上分别实现了公平锁与非公平锁两种同步类型，宏观上看代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 默认实现非公平锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在不指定锁类型时，声明的就是非公平锁，如果传入了boolean值，则判断后生成公平或者非公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-非公平锁-加锁"><a href="#2-非公平锁-加锁" class="headerlink" title="2.非公平锁-加锁"></a>2.非公平锁-加锁</h4><p>首先看加锁过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 无论AQS中是否有排队情况，都会尝试插队抢占锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 插队失败后执行AQS中的acquire方法</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面已经分析过acquire方法，这里不再赘述，简单来说就是一个封装线程为节点入队，并在入队后自旋尝试继续获取锁的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由ReentrantLock实现的非公平锁加锁过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 无锁状态</span></span><br><span class="line">      <span class="comment">// 不管队列情况，直接抢锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//CAS(#Lock) -&gt; 原子操作| 实现互斥的判断</span></span><br><span class="line">            setExclusiveOwnerThread(current); <span class="comment">//把获得锁的线程保存到exclusiveOwnerThread中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//如果当前获得锁的线程和当前抢占锁的线程是同一个，表示重入</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires; <span class="comment">// 增加重入次数</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc); <span class="comment">// 保存state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-公平锁-加锁"><a href="#3-公平锁-加锁" class="headerlink" title="3.公平锁-加锁"></a>3.公平锁-加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试抢占一把锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS中定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试获取锁</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 注意与非公平锁的tryAcquire方法区别在这里</span></span><br><span class="line">      <span class="comment">// hasQueuedPredecessors用来判断当前线程是否有前驱节点，如果有就不能抢占</span></span><br><span class="line">      <span class="comment">// 即需要按照入队顺序依次获取锁，如果当前线程前面有线程未获得锁，当前线程也不能抢占</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-解锁"><a href="#4-解锁" class="headerlink" title="4.解锁"></a>4.解锁</h4><p>ReentrantLock类内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AQS中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 判断是否完全释放了锁，即state为0</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 队列不为空，尝试唤醒</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases; <span class="comment">// state新值</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">//判断释放锁的线程是否持有锁</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">//完全释放了锁</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>); <span class="comment">// 释放独占标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) <span class="comment">// 表示可以唤醒状态</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>); <span class="comment">// 恢复状态值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">// 说明这个线程已经被销毁，或者存在异常</span></span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 从tail往head进行遍历</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 查找状态小于等于0，表示需要被唤醒</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 最后找到的是head后面第一个能唤醒的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);<span class="comment">// 唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是waitStatus的取值与代表意义</p><ul><li>SIGNAL(-1)：表示当前节点的后继节点需要被唤醒。</li><li>CANCELLED(1)：表示当前节点已经取消等待。</li><li>CONDITION(2)：表示当前节点在条件队列中等待。</li><li>PROPAGATE(-3)：用于共享模式下，表示后继节点需要向前传播唤醒信号。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶之并发编程（二）volatile关键字</title>
      <link href="/2023/03/25/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/03/25/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是线程安全的可见性与有序性"><a href="#一、什么是线程安全的可见性与有序性" class="headerlink" title="一、什么是线程安全的可见性与有序性"></a>一、什么是线程安全的可见性与有序性</h3><p>先看如下案例，在该样例中，线程外将stop改为true之后，理论上线程会跳出while循环进而终止，但是实际运行会发现线程依然继续运行，为什么会出现这种情况呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> stop=<span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">               i++;</span><br><span class="line">&#125; </span><br><span class="line">       &#125;);</span><br><span class="line">       t1.start();</span><br><span class="line">       System.out.println(<span class="string">&quot;begin start thread&quot;</span>);</span><br><span class="line">       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       stop=<span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为现代JVM实现（如HotSpot JVM）中的即时编译器会对程序进行代码优化，从而导致对<code>stop</code>变量的读取在循环中只被执行一次，即初始状态下读取到的true，而外部对<code>stop</code>的修改并不能被线程内部的<code>stop</code>所获取到，这就是所谓的<strong>可见性</strong>问题</p><p>想解决上述代码可见性问题，只需要增加一个<code>volatile</code>关键字即可，该关键字可以保证代码的可见性</p><p>那什么是有序性问题呢？看如下案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderingDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        x = <span class="number">42</span>;  <span class="comment">// 写操作</span></span><br><span class="line">        flag = <span class="literal">true</span>;  <span class="comment">// 写操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;  <span class="comment">// 读操作</span></span><br><span class="line">            System.out.println(x);  <span class="comment">// 读操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ReorderingDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReorderingDemo</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        demo.writer();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        demo.reader();</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上述代码中，线程1调用了<code>writer</code>方法，而线程2调用了<code>reader</code>方法。由于没有使用同步机制或者<code>volatile</code>关键字，线程2可能会看到变量<code>flag</code>为<code>true</code>，但是变量<code>x</code>的值还没有被写入，从而导致输出的x值为0</p><p>这是因为在java当中，如果一段代码没有强依赖关系，那么在多线程条件下这些代码可能会被重排序，从而导致并发顺序问题；此外，<code>x = 42</code>并不是一个原子性操作，而是由初始化x为0和将42赋值给x两步组成的，因此多线程条件下可能会先拿到为0的x值，这就是线程的有序性问题</p><h3 id="二、为什么会出现可见性问题"><a href="#二、为什么会出现可见性问题" class="headerlink" title="二、为什么会出现可见性问题"></a>二、为什么会出现可见性问题</h3><h4 id="1-为了性能处理所做的优化"><a href="#1-为了性能处理所做的优化" class="headerlink" title="1.为了性能处理所做的优化"></a>1.为了性能处理所做的优化</h4><p>在整个计算机的发展历程中，除了CPU、内存以及I&#x2F;O设备不断迭代升级来提升计算机处理性能之外， 还有一个非常核心的矛盾点，就是这三者在处理速度的差异。CPU的计算速度是非常快的，其次是内存、最后是IO设备(比如磁盘)，也就是CPU的计算速度远远高于内存以及磁盘设备的I&#x2F;O速度。</p><p>为了平 衡这三者之间的速度差异，最大化的利用CPU。所以在硬件层面、操作系统层面、编译器层面做出了很 多的优化</p><ul><li>CPU增加了高速缓存</li><li>操作系统增加了进程、线程。通过CPU的时间片切换最大化的提升CPU的使用率 </li><li>编译器的指令优化，更合理的去利用好CPU的高速缓存</li></ul><p>每一种优化，都会带来相应的问题，而这些问题是导致线程安全性问题的根源，那接下来我们逐步去了<br>解这些优化的本质和带来的问题。</p><h4 id="2-CPU层面的缓存"><a href="#2-CPU层面的缓存" class="headerlink" title="2.CPU层面的缓存"></a>2.CPU层面的缓存</h4><p>CPU在做计算时，和内存的IO操作是无法避免的，而这个IO过程相对于CPU的计算速度来说是非常耗时，基于这样一个问题，所以在CPU层面设计了高速缓存，这个缓存行可以缓存存储在内存中的数据，CPU每次会先从缓存行中读取需要运算的数据，如果缓存行中不存在该数据，才会从内存中加载，通过这样一个机制可以减少CPU和内存的交互开销从而提升CPU的利用率。</p><p>对于主流的x86平台，cpu的缓存行(cache)分为L1、L2、L3总共3级。</p><p><img src="https://static-2w2.pages.dev/post/levelCache.png" alt="image-20230327011219482"></p><p><strong>1）缓存一致性问题</strong></p><p>CPU高速缓存的出现，虽然提升了CPU的利用率，但是同时也带来了另外一个问题—缓存一致性问题， 这个一致性问题体现在。</p><p>在多线程环境中，当多个线程并行执行加载同一块内存数据时，由于每个CPU都有自己独立的L1、L2缓存，所以每个CPU的这部分缓存空间都会缓存到相同的数据，并且每个CPU执行相关指令时，彼此之间不可见，就会导致缓存的一致性问题。</p><p><strong>2）缓存一致性协议</strong></p><p>为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，常 见的协议有MSI，MESI，MOSI等。最常见的就是MESI协议。接下来简单讲解一下MESI。</p><p><strong>MESI表示缓存行的四种状态，分别是</strong></p><ul><li>M(Modify) 表示共享数据只缓存在当前CPU缓存中，并且是被修改状态，也就是缓存的 数据和主内存中的数据不一致</li><li>E(Exclusive) 表示缓存的独占状态，数据只缓存在当前CPU缓存中，并且没有被修改</li><li>S(Shared) 表示数据可能被多个CPU缓存，并且各个缓存中的数据和主内存数据一致</li><li>I(Invalid) 表示缓存已经失效</li></ul><p>在CPU的缓存行中，每一个Cache一定会处于以下三种状态之一</p><ol><li><strong>Shared状态</strong>：表示该缓存块正在被多个处理器共享。在该状态下，缓存块的副本位于多个处理器的缓存中，这些副本之间的数据应该是相同的，因此任何一个处理器的缓存更改都必须与其他处理器的缓存同步。</li><li><strong>Exclusive状态</strong>：表示该缓存块只存在于当前处理器的缓存中。在这种情况下，当前处理器是唯一可以访问该缓存块的处理器，并且其他处理器无法访问该缓存块。如果其他处理器需要访问该缓存块，则必须先使其从Exclusive状态转换为Shared状态。</li><li><strong>Invalid状态</strong>：表示该缓存块无效或者已经过期，不能被任何处理器使用。当某个处理器修改了一个缓存块的数据时，该缓存块的状态会变为Invalid状态，此时其他处理器需要刷新其缓存中的数据，以确保其缓存中的数据与内存中的数据一致。</li></ol><blockquote><p>即共享，独占和无效</p></blockquote><p>但是，缓存一致性协议情况下依然可能会存在<strong>指令重排序</strong>问题，一般采用<strong>内存屏障</strong>来处理，保证指令有序性与可见性</p><p>也可以使用<strong>缓存锁&#x2F;总线锁</strong>等机制解决</p><h4 id="3-指令重排序问题"><a href="#3-指令重排序问题" class="headerlink" title="3.指令重排序问题"></a>3.指令重排序问题</h4><p><strong>CPU层面</strong>的指令重排序问题是指在现代处理器中，为了提高指令执行效率，处理器内部可能会对指令进行重排序，从而可能导致指令的执行顺序发生变化。这种重排序通常不会影响程序的语义，但是在多线程环境下，如果不加以控制，就可能会导致线程之间的数据竞争和有序性问题。</p><p>比如存在a和b两个普通共享变量，a变量被一个线程修改后，有缓存还没有更新a值，这时候b变量用到了a变量的值，但是读取到了修改前的值，从而导致线程安全问题</p><p><strong>Java层面</strong>的指令重排序问题是指在Java程序中，由于JVM的优化机制和编译器的优化策略，可能会导致程序中的指令执行顺序发生变化。这种重排序通常不会影响单线程程序的语义，但是在多线程环境下，如果不加以控制，就可能会导致线程之间的数据竞争和有序性问题。</p><p>java层面，最常见解决可见性与有序性问题的手段是使用<code>volatile</code>关键字或者加锁</p><p>本质是采用了内存屏障的技术</p><h4 id="4-内存屏障"><a href="#4-内存屏障" class="headerlink" title="4.内存屏障"></a>4.内存屏障</h4><p>内存屏障（Memory Barrier），也叫内存栅栏，是一种CPU硬件提供的指令，用于限制处理器和内存的乱序执行和重排序。内存屏障可以被用来保证指令的执行顺序、控制CPU和内存之间的同步、保证内存可见性等。内存屏障通常分为以下几种：</p><ol><li><strong>Load Barrier</strong>（读屏障）：它保证在读取某个变量的值之前，其它变量的值已经被加载到处理器的缓存中。读屏障确保了程序的有序性和可见性，避免了程序中出现未初始化的变量或无效的数据。</li><li><strong>Store Barrier</strong>（写屏障）：它保证在修改某个变量的值之后，其它变量的值被刷新到内存中。写屏障确保了程序的有序性和可见性，避免了出现脏数据或不一致的数据。</li><li><strong>Full Barrier</strong>（全屏障）：它同时包括了读屏障和写屏障的功能，保证了程序的所有操作都是有序的。全屏障一般比较耗费资源，只在特定情况下使用。</li></ol><p>在Java中，<code>volatile</code>关键字使用的内存屏障主要包括<code>store-store</code>屏障、<code>load-load</code>屏障和<code>store-load</code>屏障，它们合起来构成了一种全屏障的机制。</p><ul><li><code>store-store</code>屏障会保证在该屏障之前的所有<code>store</code>指令都已经完成，确保该屏障之前的所有修改对其他线程可见；</li><li><code>load-load</code>屏障会保证在该屏障之后的所有<code>load</code>指令都能够读取到最新的值，确保该屏障之后的所有读操作都是有效的；</li><li><code>store-load</code>屏障会保证在该屏障之前的所有<code>store</code>指令都已经完成，确保该屏障之前的所有修改对其他线程可见，同时会强制所有之后的<code>load</code>指令重新从内存中读取数据，而不是使用之前的缓存数据，确保该屏障之后的所有读操作都能够读取到最新的值。</li></ul><h3 id="三、JMM模型"><a href="#三、JMM模型" class="headerlink" title="三、JMM模型"></a>三、JMM模型</h3><p>简单来说，<strong>Java内存模型（JMM）定义了多线程程序中，线程之间通过内存进行通信的规则和限制。</strong></p><p>具体的，Java内存模型规定了所有的变量都存储在<strong>主内存</strong>中，每条线程还有自己的<strong>工作内存</strong>，线程的工作内存中保存了这个线程中用到的变量的<strong>主内存副本拷贝</strong>，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。</p><p>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行，流程图如下:</p><img src="https://static-2w2.pages.dev/post/jmm.jpeg" alt="image-20230327011219482" style="zoom: 67%;" /><p>目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重<br>排序、处理器会对代码乱序执行等带来的问题</p><blockquote><p>本地内存是JMM的一个抽象概念，并不真实存在。</p><p>它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p></blockquote><p>上面的可见性与有序性问题主要是通过volatile关键字来解决的，那有哪些情况是，不需要通过增加volatile关键字，也能保证在多线程环境下的可见性和有序性的呢?</p><p>从JDK1.5开始，引入了一个<strong>happens-before</strong>的概念来阐述多个线程操作共享变量的可见性问题。所以我们可以认为在JMM中，如果一个操作执行的结果需要对另一个操作课件，那么这两个操作必须要存在 happens-before关系。这两个操作可以是同一个线程，也可以是不同的线程。</p><h4 id="1-happens-before-规则"><a href="#1-happens-before-规则" class="headerlink" title="1.happens-before 规则"></a>1.happens-before 规则</h4><p>“<strong>happens-before</strong>“ 是 Java 内存模型（JMM）中的一个概念，用来描述多线程程序中各个线程之间操作的先后顺序。</p><p>具体来说，如果操作 A happens-before 操作 B，那么 A 一定在 B 之前执行，且 B 可以看到 A 执行的结果。happens-before 规则定义了一组顺序关系，用来保证多线程程序中的操作顺序，从而确保程序的正确性和可移植性。</p><p>happens-before 规则包括以下几个方面：</p><ol><li><strong>传递性</strong>（Transitivity）规则：如果事件 A 在事件 B 之前发生，事件 B 在事件 C 之前发生，那么事件 A 必须在事件 C 之前发生。</li><li><strong>volatile</strong> 变量规则：如果一个线程先写一个 volatile 变量，然后另一个线程读取该变量，那么这个写操作将 happen-before 于这个读操作。</li><li><strong>监视器锁</strong>规则：如果一个线程获得了一个监视器锁并释放了它，那么这个获得操作将 happen-before 于这个释放操作。</li><li><strong>start</strong> 规则：如果线程 A 启动线程 B，那么线程 A 的 start 操作将 happen-before 于线程 B 的任意操作。</li><li><strong>join</strong> 规则：如果线程 A 等待线程 B 结束，那么线程 B 的任意操作都将 happen-before 于线程 A 的 join 操作返回。</li></ol><h4 id="2-as-if-serial"><a href="#2-as-if-serial" class="headerlink" title="2.as-if-serial"></a>2.as-if-serial</h4><p>“as-if-serial” 是指，虚拟机可以对指令进行重排序，只要重排序后的执行结果与原来的执行结果一致，就可以保证程序的正确性。换句话说，虚拟机可以将指令序列中无关联的操作进行并行执行，只要保证最终的结果与串行执行的结果一致即可。</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶之并发编程（一）synchronized关键字</title>
      <link href="/2023/03/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/03/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="并发编程基础篇"><a href="#并发编程基础篇" class="headerlink" title="并发编程基础篇"></a>并发编程基础篇</h2><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><ol><li><strong>QPS</strong>（Queries Per Second）：每秒查询率，指的是一个系统或服务在一秒内能够处理的查询次数。例如，如果一个网站每秒钟能够处理100个请求，那么它的QPS为100。</li><li><strong>TPS</strong>（Transactions Per Second）：每秒事务数，指的是一个系统或服务在一秒内能够完成的事务数。一个事务通常指的是一组相关的操作，例如在数据库中执行一次读写操作。TPS是一个系统的性能指标之一，可以用来衡量系统的稳定性和响应能力。</li><li><strong>CPU</strong>（Central Processing Unit，中央处理器）：CPU是计算机的核心部件，它负责执行计算机指令。在并发编程中，CPU的主要限制是它的计算能力，它能够处理的任务数量受到CPU核心数、频率和指令集等因素的影响。为了充分利用CPU的性能，可以采用多线程、异步编程等方式来并发执行任务。</li><li><strong>内存</strong>（Memory）：内存是计算机中用于存储数据和程序的临时存储器，它的容量和速度对并发编程也有很大的影响。如果程序需要频繁地读写内存，那么内存的带宽和延迟就会成为瓶颈。为了减少内存的使用，可以采用一些优化策略，如对象池、缓存等方式。</li><li><strong>磁盘</strong>（Disk）：磁盘是计算机用于存储数据的永久性存储器，它的容量和速度也会对并发编程造成影响。磁盘的读写速度相对于内存来说较慢，因此频繁地进行磁盘读写会成为程序的瓶颈。为了优化磁盘的使用，可以采用一些策略，如异步I&#x2F;O、缓存、压缩等方式。</li><li><strong>网卡</strong>（Network Interface Card）：网卡是计算机用于连接网络的接口，它的带宽和延迟对网络通信的性能有很大的影响。在并发编程中，网络通信是一种常见的场景，因此优化网络通信的性能非常重要。可以采用一些策略，如连接池、异步I&#x2F;O、压缩等方式来优化网络通信的性能。</li><li><strong>I&#x2F;O</strong>（Input&#x2F;Output）是计算机系统中，用于实现计算机与外部设备交互的操作。在并发编程中，I&#x2F;O操作的限制主要包括磁盘、网络和数据库等方面的性能瓶颈。磁盘的读写速度相对于内存来说较慢，因此频繁进行磁盘读写会成为程序的瓶颈。网络通信的带宽和延迟也会影响I&#x2F;O操作的性能，需要采用一些策略来优化，如使用缓存、压缩、连接池等方式。在使用数据库时，频繁进行数据库的读写操作也会成为系统的瓶颈，需要采用一些策略来优化，如使用数据库连接池、使用索引等。</li></ol><blockquote><p>此外，在并发编程之中，进程和线程的概念是必须熟练掌握的</p></blockquote><ul><li><p>进程是指一个程序的运行实例，它拥有自己的地址空间、文件描述符、环境变量、堆栈等资源，是操作系统进行资源分配和调度的基本单位。</p></li><li><p>线程是进程内的一个执行单元，一个进程可以包含多个线程，线程共享进程的地址空间和资源，但是每个线程都有自己的堆栈和寄存器，可以独立执行。线程的并发性相对于进程更高，可以更好地利用计算机的多核处理器，提高程序的性能。</p></li></ul><p><strong>区别：</strong></p><ol><li>进程是操作系统资源分配的基本单位，线程是进程的执行单元，进程可以包含多个线程。</li><li>进程拥有自己的地址空间、文件描述符、环境变量等资源，而线程共享进程的地址空间和资源。</li><li>进程之间相互独立，线程之间共享进程的资源。</li><li>进程切换需要保存当前进程的状态和上下文，开销较大，线程切换开销较小，切换速度更快。</li><li>进程通信需要使用进程间通信机制，如管道、消息队列、共享内存等，线程之间可以直接共享数据。</li></ol><p>总的来说，进程和线程都是用于实现多任务的机制，但是它们的性质和使用方式不同，应该根据具体情况选择适合的机制来实现多任务。</p><h3 id="二、线程相关"><a href="#二、线程相关" class="headerlink" title="二、线程相关"></a>二、线程相关</h3><h4 id="1-线程生命周期"><a href="#1-线程生命周期" class="headerlink" title="1.线程生命周期"></a>1.线程生命周期</h4><p>线程的生命周期可以被分为五个不同的阶段：创建、就绪、运行、阻塞和终止。</p><ol><li>创建阶段：线程被创建，分配了必要的系统资源，但还未开始运行。</li><li>就绪阶段：线程已经准备好运行，但还未被CPU调度执行。</li><li>运行阶段：CPU选择了一个就绪状态的线程，将其放入运行状态，并执行线程的run()方法。</li><li>阻塞阶段：线程进入了一个阻塞状态，例如等待某个事件发生或者等待输入输出操作完成。</li><li>终止阶段：线程执行完了run()方法或者抛出了一个未被捕获的异常，或者被强制中断，线程将进入终止状态。</li></ol><blockquote><p>需要注意的是，在java代码当中，线程具有六个状态，和线程生命周期并不完全匹配</p><p>NEW 新建,RUNNABLE 就绪,BLOCKED 阻塞,WAITING 等待,TIMED_WAITING 时间等待,TERMINATED 终止</p></blockquote><p>不同状态之间的转换可以由以下事件触发：</p><ol><li>创建状态转换为就绪状态：当线程被创建并分配了系统资源之后，它就进入了就绪状态。这个状态转换是自动发生的。</li><li>就绪状态转换为运行状态：当线程被操作系统的调度器选择并分配了CPU资源后，线程进入运行状态。</li><li>运行状态转换为阻塞状态：当线程在执行过程中遇到了阻塞事件（如等待输入&#x2F;输出操作完成、等待某个锁等待等），线程会被挂起，进入阻塞状态。</li><li>阻塞状态转换为就绪状态：当线程被阻塞的原因消除后（如输入&#x2F;输出操作完成或某个锁被释放），线程就会转换为就绪状态，等待操作系统调度器重新分配CPU资源。</li><li>运行状态转换为终止状态：当线程执行完了run()方法或抛出了未被捕获的异常或被强制中断时，线程就会进入终止状态。</li></ol><h4 id="2-实现线程的方法"><a href="#2-实现线程的方法" class="headerlink" title="2.实现线程的方法"></a>2.实现线程的方法</h4><p>1.继承Thread类</p><p>2.实现Runnable接口</p><p>3.实现Callable接口</p><p>4.使用线程池ThreadPoolExecutor</p><h4 id="3-线程中断"><a href="#3-线程中断" class="headerlink" title="3.线程中断"></a>3.线程中断</h4><blockquote><p>线程可以使用stop()来中断，但是这种方法会不论当前线程状态直接将线程中断掉，容易造成未知影响，已经逐渐废弃</p></blockquote><p>更普遍的，可以使用interrupt()方法来中断线程，相当于给正在运行的线程发送了一个信号，通知线程可以中断了，可以用isInterrupted()方法来判断是否启用了线程中断，如果处于中断命令状态，用户可以执行相应操作</p><p>需要注意的是，如果线程内run使用类似如下语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!Thread.currentThread.isInterrupted())&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下在线程外调用interrupt()方法是可以将线程正常中断掉的，而这种状态下的中断其实和使用volatile声明一个共享变量来做线程通信的原理是相似的</p><p><code>interrupt()</code>方法并不会直接中断一个正在运行状态的线程，而是将中断标志位设置为<strong>true</strong>，在线程内可以通过对中断标志位的判断，来决定何时中断当前线程，此外，<code>interrupt()</code>方法对不同状态的线程影响不同：</p><ol><li>如果线程处于运行状态，那么中断标志位将被设置为<code>true</code>，但线程并不会立即停止执行，而是可以通过对中断标志位的检查来决定是否停止执行。</li><li>如果线程处于阻塞状态，那么调用<code>interrupt()</code>方法会立即抛出<code>InterruptedException</code>异常，这样可以提前结束线程的阻塞状态并抛出异常，从而使线程退出阻塞状态继续执行。</li><li>如果线程处于等待状态，例如调用了<code>Object.wait()</code>方法或<code>Thread.join()</code>方法等待其他线程的通知或执行完成，那么调用<code>interrupt()</code>方法也会立即抛出<code>InterruptedException</code>异常，从而使线程退出等待状态继续执行。</li><li>如果线程处于新建状态或者已经终止，那么调用<code>interrupt()</code>方法不会有任何效果，中断标志位会被设置为<code>true</code>，但线程并不会中断执行。</li></ol><blockquote><p>需要注意的是，抛出<code>InterruptedException</code>异常之后，运行线程会将中断标志位重新置为<code>false</code>，即退出了中断状态，为什么这样设计呢？</p><p>这种设计主要是为了线程安全性考虑，当某个线程中断标志位设置为<code>true</code>之后，如果其他线程来获取这个线程状态，会获得<code>true</code>结果，但是这个线程其实并不是在中断标志位被设置为<code>true</code>后就立即进入中断状态了，它可能还会有一些自己的处理，因此需要将中断标志位重置。同时，这也是将中断交给用户来处理的一个操作，使得用户可以更加灵活的处理中断情况，而如果用户想真的中断这个线程时，可以在run内部调用<code>Thread.currentThread().interrupt()</code>来实现线程真正的中断。</p></blockquote><p>如下所示，就是一个调用<code>interrupt()</code>后能抛出<code>InterruptedException</code>异常的run内写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!Thread.currentThread.isInterrupted())&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(InterruptException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-cpu飙升问题排查"><a href="#4-cpu飙升问题排查" class="headerlink" title="4.cpu飙升问题排查"></a>4.cpu飙升问题排查</h4><p>当CPU飙升时，可能是因为某个进程或线程在消耗大量的CPU资源，导致CPU使用率过高。要解决这个问题，可以通过以下步骤进行排查：</p><ol><li>查看系统负载：可以通过命令<code>top</code>或<code>htop</code>来查看系统的负载情况，包括CPU使用率、内存使用率、进程数量等信息。如果CPU使用率很高，可以查看哪些进程或线程占用了大量的CPU资源。</li><li>查看进程信息：可以通过命令<code>ps</code>或<code>pidstat</code>来查看进程的详细信息，包括进程ID、CPU使用率、内存使用率、线程数量等信息。可以根据进程ID定位到具体的进程，并查看其线程的详细信息。<strong>（top命令看进程信息，找到占用cpu过高的进程）</strong></li><li>分析线程堆栈信息：可以通过工具如jstack、jvisualvm等来获取线程堆栈信息，从而了解线程的执行情况。通过分析线程堆栈信息，可以确定哪些线程占用了大量的CPU资源，并查找问题所在。<strong>（jstack查看线程信息，找到占用cpu过高的线程）</strong></li><li>分析代码：根据线程堆栈信息，可以定位到具体的代码位置，进一步分析代码的执行情况。如果是某个代码块或方法导致CPU使用率过高，可以考虑对其进行优化或改进。<strong>（根据dump文件，使用jmap分析是否有死锁，内存泄漏等问题，定位到对应代码块）</strong></li><li>调整系统参数：如果以上步骤都无法解决问题，可以考虑调整系统参数，例如增加CPU数量、增加内存容量、调整线程池大小等，以提高系统性能。</li></ol><p>需要注意的是，CPU飙升问题可能有多种原因，可能是代码问题，也可能是系统配置问题。在排查问题时，需要综合考虑各种因素，并根据具体情况采取相应的措施。</p><blockquote><p>注意，死锁不一定会导致CPU飙升</p><p>首先分析会导致CPU飙升的死锁，这种情况就是多个进程存在死锁，然后不断重试去尝试获取资源，从而导致占用大量CPU资源，导致CPU使用率飙升</p><p>那么不会使CPU飙升的死锁是什么样的呢？考虑以下场景</p><ul><li>进程A获取了锁1，正在等待锁2</li><li>进程B获取了锁2，正在等待锁1</li></ul><p>在这种情况下，A和B进程都进入了阻塞状态，这种状态是不会对CPU资源进行占用的，但是这种死锁不释放也会对资源进行占用，需要及时发现并处理。</p></blockquote><h3 id="三、并发编程之同步锁"><a href="#三、并发编程之同步锁" class="headerlink" title="三、并发编程之同步锁"></a>三、并发编程之同步锁</h3><h4 id="1-synchronized关键字"><a href="#1-synchronized关键字" class="headerlink" title="1.synchronized关键字"></a>1.synchronized关键字</h4><p>synchronized关键字只能作用于<strong>代码块</strong>或者<strong>方法</strong>，并不能直接作用于变量，但是可以声明一个对象放在sychronized锁住代码块的小括号里，作为共享对象进行并发控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时引出了另一个问题，sychronized关键字都可以怎么使用？不同方法锁住的都是什么？</p><ul><li>锁在普通方法上：这种情况下，sychronized锁住的就是当前实例对象本身，也就是this</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>锁在静态方法上：这种情况下，锁对象通常是类对象，也就是说，锁住的是当前类对象的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>锁在代码块上：这种情况下，锁对象可以是任何的Java对象，通常是使用一个专门声明的私有final对象，防止其他对象意外使用该对象导致竞争发生</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，锁的也可以是ClassName.class形式的对象，表示对这个类加了锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (ClassName.class) &#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么叫对类进行加锁呢？</p><p>在JVM当中，每个类在其中都有一个对应的Class对象，这个Class对象是全局唯一的，因此当使用synchronized关键字对类进行加锁时，类所有实例对象的静态变量和静态方法也都是被锁住的，但是对于这个类的实例来说，非静态方法与变量是可以被其他线程正常访问的；所以类锁其实只会锁住一个类的静态方法与静态变量；</p><p>类锁控制的资源范围更大，锁的粒度也更大，可以保证多线程条件下类的静态资源的并发安全性，经典的用例便是单例模式的双重校验锁中对单例类的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// private constructor</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了一个 <code>volatile</code> 关键字来保证在多线程环境下，instance 变量的可见性和有序性，为什么要使用它呢？</p><p>如果没有使用 volatile 关键字，可能会出现以下问题：</p><ol><li>线程 A 进入双重校验锁，执行第一个步骤，此时实例还未被创建，然后线程 B 也进入双重校验锁。</li><li>线程 B 获取到锁，执行第一个步骤，此时实例还未被创建，然后线程 A 获取到锁，执行第二个步骤，创建实例。</li><li>线程 B 继续执行第二个步骤，创建另一个实例，并返回。</li></ol><p>因为指令重排序的原因，线程 B 可能会在实例还未被创建的时候获取到锁，并返回一个未完成初始化的实例。如果其他线程使用这个实例，可能会导致程序出错。</p><blockquote><p>双重校验锁实现的单例并不完美，具体问题与优化可以参考<a href="https://yzj.life/2023/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Java进阶之设计模式</a>中的单例模式介绍</p></blockquote><h4 id="2-抢占锁的本质是什么"><a href="#2-抢占锁的本质是什么" class="headerlink" title="2.抢占锁的本质是什么"></a>2.抢占锁的本质是什么</h4><p>抢占锁是指多个线程竞争同一把锁时，其中一个线程成功获得了锁并持有锁的情况下，其他线程将被阻塞，无法进入临界区进行操作，只有等到锁被释放后才能继续竞争锁并进入临界区。</p><p>抢占锁的本质是通过锁来保证多个线程对共享资源的访问是互斥的，从而保证了线程安全。当一个线程获取锁时，它会进入临界区，执行相关操作，直到完成后才会释放锁。其他线程在没有获得锁之前，无法进入临界区，从而避免了多个线程同时对共享资源进行修改而导致的数据不一致问题。</p><h4 id="3-MarkWord对象头"><a href="#3-MarkWord对象头" class="headerlink" title="3.MarkWord对象头"></a>3.MarkWord对象头</h4><p>在Java对象头中，用于表示锁状态的部分称为mark word（标记字段）。mark word通常包含了三种信息：</p><ul><li>对象的hashCode值</li><li>对象的分代年龄</li><li>锁状态</li></ul><p>其中，锁状态一般使用2bit位来表示，但是在无锁或者偏向锁时，会用3bit位来表示锁状态</p><ul><li>0 01表示无锁状态</li><li>1 01表示是偏向锁状态</li><li>00表示是轻量级锁状态</li><li>10表示是重量级锁状态</li><li>11则是用到的GC标志</li></ul><p>mark word的指针并不是一直不变的，在不同的锁状态下指向不同的对象，用于实现不同需求</p><ul><li>在偏向锁状态下，mark word的指针指向线程ID，用于记录哪个线程拥有该对象。</li><li>在轻量级锁状态下，mark word的指针指向锁记录的地址，锁记录用于存储锁定对象的线程ID和锁的状态信息。</li><li>在重量级锁状态下，mark word的指针指向重量级锁的互斥量。</li></ul><p>下面分别介绍这几种锁</p><blockquote><p>在jdk6之后才对sychronized进行了细化区分，在5和之前都是用的重量级锁</p></blockquote><p><strong>1.偏向锁</strong></p><p>偏向锁的核心思想是，如果一个线程获得了对象的锁，那么在之后的执行中，该线程就可以直接进入临界区，而不用再次获取锁了。偏向锁可以消除大量的同步操作，因为大部分情况下，锁总是由同一个线程多次获得的。如果加入了偏向锁，当这个线程再次进入临界区时，就不用再去尝试获取锁，因为锁已经被偏向该线程了。</p><blockquote><p>注意，并不是说一个线程拿到某一对象置为偏向锁后，这个对象的偏向锁就只能是该线程了，偏向锁存在一个偏向锁撤销的可能，偏向锁撤销可能会升级成轻量级锁，也可能重新变成无锁状态，由以下状态情况触发回到无锁状态</p><ul><li>使用-XX:BiasedLockingStartupDelay参数设置了偏向锁持有时间，到达时间后偏向锁会被撤销</li><li>在并发标记过程中，遇到了安全点，会暂停所有线程，并且把对象头中的偏向锁撤销</li></ul><p>其他一些情况不再细谈，撤销偏向锁其实是一个比较耗费资源的操作，所以有时候jvm会直接把对象设置为“不可偏向”状态，此时再有线程过来尝试获取锁直接升级为轻量级锁</p></blockquote><p><strong>2.轻量级锁</strong></p><p>当一个线程尝试获取一个有偏向锁的对象时，如果这个对象的偏向锁标识符与线程的标识符不同，说明有另一个线程已经竞争这个锁了，那么就会将偏向锁升级为轻量级锁，并使用CAS操作来竞争锁。所以，一般情况下，偏向锁升级为轻量级锁是在第二个线程尝试获取锁时发生的。</p><p>轻量级锁适合使用在有<strong>多个线程在不同时刻</strong>轮流获取锁的情况，如果竞争较为激烈，重量级锁的性能表现会更好</p><p>轻量级锁采用CAS机制来尝试获取锁，如果获取锁失败则会自旋尝试再次获取锁，默认会在10次获取失败后升级成重量级锁，但是这个参数可用通过JVM参数控制</p><p><strong>3.重量级锁</strong></p><p><code>synchronized</code> 的重量级锁是指当竞争激烈时，锁会升级为重量级锁（也叫监视器锁）。在重量级锁的实现中，会使用操作系统的<strong>互斥量</strong>来实现锁，因此在争用同步资源时会发生<strong>内核态与用户态</strong>之间的切换，这种切换的代价比较高，因此重量级锁在性能方面比较差，适合用于保护竞争激烈的共享资源。</p><p>那么操作系统的互斥量是指的什么呢？重量级锁又是如何实现的呢？</p><p>简单来说，Java虚拟机通过对对象的监视器（<code>monitor</code>）进行操作，来达到对对象的加锁和解锁目的</p><p><code>monitorenter</code> 和 <code>monitorexit</code> 是 Java 虚拟机的两条指令，当 JVM 执行 <code>monitorenter</code> 指令时，会先判断对象的 <code>monitor</code> 是否处于无锁状态，如果是，就将 <code>monitor</code> 设置为当前线程持有，并将锁的计数器加1。如果 monitor 已经被当前线程持有，就直接将计数器加1即可，这样可以重入锁。如果 <code>monitor</code> 已经被其他线程持有，则当前线程就会进入阻塞状态，直到 <code>monitor</code> 变为可用。</p><p>当 JVM 执行 <code>monitorexit</code> 指令时，会先判断当前线程是否持有 <code>monitor</code>，如果是，就将 <code>monitor</code> 的计数器减1。如果计数器减为0，说明该线程已经释放了 <code>monitor</code>，可以将 <code>monitor</code> 设置为无锁状态，并唤醒等待在 <code>monitor</code> 上的其他线程。</p><blockquote><p>本质上就是JVM通过对<code>monitor</code>的状态进行操作，来进行加锁和解锁，那么更进一步了解，<code>monitor</code>又是如何实现的呢？</p><p><code>monitor</code> 是一种同步原语，用于实现互斥锁等同步操作。<code>monitor</code> 可以看作是一种抽象的概念，实际上是通过操作系统的互斥量（mutex）来实现的。</p><p><strong>mutex enter</strong>和<strong>mutex exit</strong>就是操作系统中用于实现互斥量的原语。</p></blockquote><h3 id="四、CAS机制"><a href="#四、CAS机制" class="headerlink" title="四、CAS机制"></a>四、CAS机制</h3><p><strong>1.简介</strong></p><p>CAS（Compare And Swap）是一种基于原子性操作的并发编程技术，主要用于多线程环境下的共享变量的操作，可以保证线程安全。</p><p>在CAS操作中，主要包含三个参数：内存地址V、旧的预期值A和新的值B。操作步骤如下：</p><ol><li>读取V的当前值，记为A。</li><li>判断A是否等于预期值，如果相等，则执行步骤3，否则不执行。</li><li>将V的值设置为新值B，如果操作成功，则返回true，否则返回false。</li></ol><p>CAS操作通过比较内存地址V中的旧值A与预期值是否相等来判断是否执行更新操作，如果相等，则将新值B写入到内存地址V中，如果不相等，则不执行更新操作。在更新操作期间，如果其他线程修改了内存地址V中的值，那么CAS操作会失败，需要重新尝试执行CAS操作。</p><p>在java中使用<code>unsafe.compareAndSwapXXX</code>方法来实现cas操作，传递四个值，两个是用来对内存地址定位，相当于内存地址V</p><p><strong>2.ABA问题</strong></p><p>CAS操作存在ABA问题，即如果一个值由A变为B，又变回A，那么CAS操作就可能认为这个值没有变化，从而可能产生问题。为了解决ABA问题，Java提供了AtomicStampedReference类和AtomicMarkableReference类。</p><blockquote><p>AtomicStampedReference使用一个整数类型的stamp（可以理解为版本号）来记录对象被修改的次数。在执行CAS操作时，除了比较对象是否相同，还需要比较版本号是否相同，从而确保不会出现ABA问题。</p><p>AtomicMarkableReference则是使用一个boolean类型的标记位来记录对象是否被修改过。在执行CAS操作时，除了比较对象是否相同，还需要比较标记位是否相同，从而确保不会出现ABA问题。</p></blockquote><p><strong>3.CAS如何实现并发安全</strong></p><p>在单CPU情况下，CAS利用来硬件的原子性指令，将比较与交换同时完成，因此可以保证执行的原子性，从而保证了并发安全</p><p>在多CPU的情况下，单个CPU的原子性指令并不能保证夸CPU实现原子性，因此在多CPU的情况下，底层实际上是加了一个LOCK锁，可以称为缓存锁或总线锁，因此本质还是使用锁来保证的原子性</p><p>关于总线锁，后面会再展开篇幅进行介绍</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶之设计模式</title>
      <link href="/2023/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="一、设计原则"><a href="#一、设计原则" class="headerlink" title="一、设计原则"></a>一、设计原则</h3><h4 id="1-接口隔离原则"><a href="#1-接口隔离原则" class="headerlink" title="1.接口隔离原则"></a>1.接口隔离原则</h4><p><strong>核心思想：</strong>将接口拆分成多个小的、专门的接口，避免大而全的接口导致实现类必须实现无用的方法，从而提高代码的灵活性、可扩展性和可维护性。</p><p>解析：即接口要分割的足够小，功能尽量高内聚，不要太多冗余方法</p><p>以下是一个满足接口隔离原则的<strong>正例</strong>。假设我们有一个图形类<code>Shape</code>，它有一个计算面积的方法<code>calculateArea()</code>和一个计算周长的方法<code>calculatePerimeter()</code>。我们可以将这两个方法拆分成两个接口<code>AreaCalculatable</code>和<code>PerimeterCalculatable</code>，然后让实现<code>Shape</code>类的类只实现它们需要的接口。这个设计可以避免实现一个不需要的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AreaCalculatable</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PerimeterCalculatable</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculatePerimeter</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">AreaCalculatable</span>, PerimeterCalculatable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">double</span> width, <span class="type">double</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculatePerimeter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (width + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>反例</strong>，假设有一个动物接口，它定义了一系列方法，包括吃、喝、跑和飞等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drink</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而实际上，一个动物很可能并不具有所有的这些能力，比如企鹅不会飞，老鹰也不一定会游泳，这里违背了接口隔离原则，需要接口功能更加细化</p><h4 id="2-迪米特法则"><a href="#2-迪米特法则" class="headerlink" title="2.迪米特法则"></a>2.迪米特法则</h4><p><strong>核心思想：</strong>也叫作最少知识原则（Least Knowledge Principle，LKP），是一种面向对象设计原则，它要求一个对象应当对其他对象有<strong>尽可能少</strong>的了解，也就是说一个对象应当尽可能少地与其他对象发生相互作用。迪米特法则的核心思想是“不和陌生人说话”，它的目的是降低类之间的耦合度，从而提高系统的灵活性和可维护性。</p><p><strong>解析：</strong>主要是为了降低类之间的耦合度，便于后期维护与阅读，同时满足高内聚低耦合的设计思想，具体优点如下</p><ul><li>降低耦合度：迪米特法则可以降低类之间的耦合度，避免不必要的依赖关系，从而提高系统的灵活性和可维护性。</li><li>提高可重用性：迪米特法则可以将类的内部实现和外部接口进行分离，使得类的实现更加独立和可重用。</li><li>易于测试：迪米特法则可以降低类之间的依赖关系，使得单元测试更加容易进行。</li><li>易于扩展：迪米特法则可以降低类之间的耦合度，使得系统更加容易扩展和维护。</li></ul><p>下面是一个违反迪米特法则的反例。假设有一个电视类，它需要调用遥控器类的turnOn和turnOff方法来控制电视的开关状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RemoteControl remoteControl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TV</span><span class="params">(RemoteControl remoteControl)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.remoteControl = remoteControl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOn</span><span class="params">()</span> &#123;</span><br><span class="line">        remoteControl.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOff</span><span class="params">()</span> &#123;</span><br><span class="line">        remoteControl.turnOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Remote control is turning on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Remote control is turning off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个设计看起来很简单，但是如果在实际应用中，遥控器类还包含其他方法，比如换台、调音量等，而电视类只需要控制开关状态，这时候就违反了迪米特法则。因为电视类并不需要知道遥控器类的所有方法，但是它的构造函数却依赖于遥控器类的实例，这就增加了类之间的耦合度，使得系统更加脆弱和难以维护。</p><p>一个更好的设计是将电视类与遥控器类解耦，电视类只需要定义自己的方法，而遥控器类也只需要定义自己的方法，两者之间通过一个控制器类来进行连接</p><h4 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="3.里氏替换原则"></a>3.里氏替换原则</h4><p><strong>核心思想：</strong>是面向对象设计的一个重要原则，由Barbara Liskov和Jeannette Wing提出。该原则指出，任何基类可以出现的地方，子类一定可以出现，且替换后程序不会出错。</p><p><strong>解析：</strong>里氏替换原则的使用场景包括</p><ul><li>多态场景：在多态场景中，一个方法可以接受基类的实例，但实际上会传入子类的实例，这时就需要保证子类能够替换基类，不影响程序的正确性。</li><li>继承场景：在继承场景中，子类继承了父类的属性和方法，但子类还可以增加自己的属性和方法，这时需要保证子类与父类的替换性，不破坏原有的逻辑。</li><li>接口场景：在接口场景中，一个类实现了一个接口，就需要保证它的子类也能够实现这个接口，保证替换性和扩展性。</li></ul><p>实际的使用案例，如集合框架中，List是一个接口，ArrayList和LinkedList是它的两个实现类。由于它们都实现了List接口，所以在使用List的地方，可以用ArrayList或者LinkedList来代替。这里就保证了子类的替换性。</p><p>在Spring框架的AOP（面向切面编程）中，切面（Aspect）需要实现Advice接口，Spring提供了很多Advice的实现类，例如BeforeAdvice、AfterAdvice、AroundAdvice等等。用户可以根据自己的需要来选择实现哪个Advice接口，然后把它作为切面的一部分来使用，这里也保证了子类的替换性和扩展性。</p><h4 id="4-合成复用原则"><a href="#4-合成复用原则" class="headerlink" title="4.合成复用原则"></a>4.合成复用原则</h4><p><strong>核心思想：</strong>是面向对象设计的一个重要原则，它强调要优先使用对象组合（Composition）和聚合（Aggregation）关系来复用代码，而不是通过继承关系来复用代码。</p><p><strong>解析：</strong>该原则的基本思想是，在设计时要优先考虑对象的<strong>组合关系</strong>，<strong>而不是继承关系</strong>，通过将多个对象组合在一起来实现功能的复用。这种方法比继承更加灵活、可靠，同时也减少了代码的耦合度，提高了代码的可维护性和可扩展性。</p><p>假设有一个汽车类（Car），它有多个组成部分，例如引擎（Engine）、车轮（Wheel）等等。我们可以使用合成复用原则来实现汽车类的设计，将组成部分作为汽车的属性来组合起来，而不是通过继承来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line">    <span class="keyword">private</span> Wheel[] wheels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;</span><br><span class="line">        engine = <span class="keyword">new</span> <span class="title class_">Engine</span>();</span><br><span class="line">        wheels = <span class="keyword">new</span> <span class="title class_">Wheel</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            wheels[i] = <span class="keyword">new</span> <span class="title class_">Wheel</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Wheel wheel : wheels) &#123;</span><br><span class="line">            wheel.rotate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Engine start.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Engine stop.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wheel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Wheel rotate.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-开闭原则"><a href="#5-开闭原则" class="headerlink" title="5.开闭原则"></a>5.开闭原则</h4><p><strong>核心思想：</strong>一个软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着，当需要对一个软件实体进行改动时，应该尽量通过扩展来实现新功能，而不是通过修改已有的代码来实现。</p><p><strong>解析：</strong>开闭原则是java里面经常提到的设计原则，简单来说就是对扩展开放，对修改关闭。当我们需要新增或者修改功能时，尽量使用新的类或方法去实现新功能，而不是在已存在的类上去修改，因为这样会导致系统稳定性变差，并且容易造成功能冗余，新的修改也不确定会不会造成新的问题，降低软件风险。</p><p>策略模式就是符合开闭原则的很好实现，它是一种行为型设计模式，它定义了一系列算法，将每个算法都封装起来，并且使它们之间可以互换。通过使用策略模式，可以在运行时动态地选择算法，而不需要在代码中显式地指定。这样，当需要添加新的算法时，只需要编写新的策略类并且注册到上下文中即可，而不需要修改原有的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> <span class="keyword">implements</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 冒泡排序算法的具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> <span class="keyword">implements</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 快速排序算法的具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SortStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(SortStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        strategy.sort(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-依赖倒置原则"><a href="#6-依赖倒置原则" class="headerlink" title="6..依赖倒置原则"></a>6..依赖倒置原则</h4><p><strong>核心思想：</strong>依赖倒置原则（Dependency Inversion Principle，DIP）是面向对象设计中的一个重要原则，它提倡高层模块不应该依赖低层模块，二者都应该依赖于抽象接口。同时，抽象接口不应该依赖于具体实现，具体实现应该依赖于抽象接口。这个原则可以简单地表述为“依赖于抽象而不是具体实现”。</p><p><strong>解析：</strong>依赖倒置原则核心就在“<strong>依赖于抽象而不是具体实现</strong>”这句话上，依赖于抽象的设计有助于简历松耦合的模块关系，从而使系统更容易扩展、修改和维护。同时，在使用依赖倒置原则的时候，我们可以更容易地进行模块的替换，例如我们可以通过更换实现某个接口的具体类来实现模块的替换，而不需要修改其他模块的代码。</p><p>下面来看一下不使用依赖倒置原则和使用依赖倒置原则来优化的案例，假设我们有一个图形库，其中包括三个类：Circle、Rectangle和Graphics，它们的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a rectangle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graphics</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        circle.draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个图形库中，我们有两个具体的形状类：Circle和Rectangle，它们都有一个draw()方法来绘制它们的形状。我们还有一个Graphics类，它负责绘制图形。</p><p>Graphics类直接依赖于Circle和Rectangle类，因为它在它的方法中创建了一个Circle和Rectangle对象来进行绘制。</p><p>现在，我们将应用依赖倒置原则，通过引入抽象接口来解耦Graphics类和具体形状类之间的依赖关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Darw</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Darw</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a rectangle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graphics</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Draw</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        circle.draw();</span><br><span class="line">    </span><br><span class="line">        <span class="type">Draw</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-单一职责原则"><a href="#7-单一职责原则" class="headerlink" title="7.单一职责原则"></a>7.单一职责原则</h4><p><strong>核心思想：</strong>单一职责原则是一种设计模式，它建议将一个类或者函数的职责限制在一个单一的领域或者任务上。简而言之，一个类或者函数只应该有一个改变的理由。</p><p><strong>解析：</strong>单一职责原则猛一看和接口隔离原则有些相似，下面对比下两种原则的相似与不同之处</p><p>相似之处：</p><ul><li>都是为了提高代码的可维护性、可读性和可扩展性。</li><li>都要求将职责限制在一个单一的领域或者任务上。</li></ul><p>不同之处：</p><ul><li>单一职责原则注重的是职责的单一性，即一个类或者函数只应该有一个职责，而接口隔离原则注重的是接口的独立性，即接口应该只包含客户端所需的方法。</li><li>单一职责原则针对的是<strong>类或者函数</strong>的设计，而接口隔离原则针对的是<strong>接口</strong>的设计。</li><li>单一职责原则更多地<strong>关注代码内部</strong>的组织和设计，而接口隔离原则更多地<strong>关注代码之间</strong>的交互和通信。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRadius</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCircumference</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * Math.PI * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码示例中，<code>Circle</code> 类只有一个职责，即表示一个圆形，提供圆形半径、圆形面积和周长的获取方法。该类的职责是单一的，没有包含其他不相关的逻辑或功能。</p><h4 id="设计原则小结"><a href="#设计原则小结" class="headerlink" title="设计原则小结"></a>设计原则小结</h4><p>通过上面的详解，可以发现这些设计模式原则，核心思想就是为了使得系统实现高内聚、低耦合的状态，尽量减少各模块之间耦合的同时提高系统的可维护性，可扩展性；</p><p>设计模式只是一种思想，并不是说在写代码时要完全符合设计模式原则去做才行，很多情况下我们写出来的代码并不是那么符合设计模式原则，这就是在业务实现上的一种取舍，就像mysql数据库表设计的时候经常会出现一些反范式设计的情况，具体如何去做还要看实际情况。</p><p>设计模式（原则）只是帮助我们将代码写的更加灵活规范，但是过于追求符合设计模式也会导致出现新的问题，比如适配器模式过渡使用，就会导致出现大量类，使得代码可读性变差，类关系也变得更加复杂，系统性能也有可能会被影响，因此设计模式要在实际项目中灵活使用。</p><h3 id="二、设计模式"><a href="#二、设计模式" class="headerlink" title="二、设计模式"></a>二、设计模式</h3><h4 id="1-简单工厂类（不属于23种设计模式之一）"><a href="#1-简单工厂类（不属于23种设计模式之一）" class="headerlink" title="1.简单工厂类（不属于23种设计模式之一）"></a>1.简单工厂类（不属于23种设计模式之一）</h4><p><strong>适用场景：</strong>工厂类负责创建的对象较少</p><blockquote><p>客户端只需要传入工厂类的参数对于如何创建对象的逻辑不需要关心</p></blockquote><p><strong>缺点：</strong>工厂类的职责相对过重，增加新的产品时需要修改工厂类的判断逻辑，违背开闭原则。不易于扩展过于复杂的产品结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">createCar</span><span class="params">(String carType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (carType.equalsIgnoreCase(<span class="string">&quot;Sedan&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SedanCar</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (carType.equalsIgnoreCase(<span class="string">&quot;SUV&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SUVCar</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid car type: &quot;</span> + carType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SedanCar</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Driving a sedan car...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SUVCar</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Driving an SUV car...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2.工厂方法模式"></a>2.工厂方法模式</h4><p><strong>定义：</strong>是指定义一个创建对象的接口，反让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类种进行，属于创建型设计模式。</p><blockquote><p>主要解决扩展问题</p></blockquote><p><strong>缺点：</strong>子类过多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">implements</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging message to file: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsoleLogger</span> <span class="keyword">implements</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging message to console: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    Logger <span class="title function_">createLogger</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLoggerFactory</span> <span class="keyword">implements</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileLogger</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsoleLoggerFactory</span> <span class="keyword">implements</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConsoleLogger</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心思想就是不同的类使用不同的工厂来创建，需要的工厂较多时就会导致出现大量子类</p><h4 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3.抽象工厂模式"></a>3.抽象工厂模式</h4><p><strong>定义：</strong>是指提供一个创建一系列相关或者相互依赖对象的接口，无需指定他们具体的类</p><p><strong>缺点：</strong>规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口，增加了系统的抽象性和理解难度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂接口，定义了创建产品的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    Button <span class="title function_">createButton</span><span class="params">()</span>;</span><br><span class="line">    TextField <span class="title function_">createTextField</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂实现类1，用于创建Windows风格的控件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsTextField</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂实现类2，用于创建Mac风格的控件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacTextField</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品接口，定义了产品的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">click</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品实现类1，用于创建Windows风格的按钮</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">click</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Windows Button Clicked.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品实现类2，用于创建Mac风格的按钮</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">click</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mac Button Clicked.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品接口，定义了产品的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">input</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品实现类1，用于创建Windows风格的文本框</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">input</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Windows TextField Input.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品实现类2，用于创建Mac风格的文本框</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">input</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mac TextField Input.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码，通过传入不同的工厂对象创建不同风格的控件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Windows风格的控件</span></span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowsFactory</span>();</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button1</span> <span class="operator">=</span> factory1.createButton();</span><br><span class="line">        button1.click();</span><br><span class="line">        <span class="type">TextField</span> <span class="variable">textField1</span> <span class="operator">=</span> factory1.createTextField();</span><br><span class="line">        textField1.input();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Mac风格的控件</span></span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MacFactory</span>();</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button2</span> <span class="operator">=</span> factory2.createButton();</span><br><span class="line">        button2.click();</span><br><span class="line">        <span class="type">TextField</span> <span class="variable">textField2</span> <span class="operator">=</span> factory2.createTextField();</span><br><span class="line">        textField2.input();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂和产品实现均需要接口定义，接口内定义了这些抽象接口之间的关系，因此实现这些的工厂和产品也具有接口定义的关系</p><h4 id="4-单例模式"><a href="#4-单例模式" class="headerlink" title="4.单例模式"></a>4.单例模式</h4><p>定义：是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点</p><blockquote><p>隐藏其所有的构造方法</p><p>属于创建者模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缺点:能够被反射破坏----构造器黎明抛异常解决</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyStaticInnerClassSingleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">LazyStaticInnerClassSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(LazyHolder.INSTANCE != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不允许非法访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> LazyStaticInnerClassSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">LazyStaticInnerClassSingleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LazyStaticInnerClassSingleton</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册式单例-枚举-解决反射破坏单例问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingleton</span>&#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Object data;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册式单例-容器-线程不安全型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContainerSingleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">ContainerSingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; ioc = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getInstance</span><span class="params">(String className)</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(!ioc.containsKey(className))&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        instance = Class.forName(className).newInstance();</span><br><span class="line">        ioc.put(className,instance);</span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ioc.get(className);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思考：当前容器方式下，如何解决线程不安全问题？</p></blockquote><blockquote><p>chatGPT版答案：</p><p>这段代码实现了一个容器单例模式，即将对象的创建和管理委托给一个容器来处理，通过类名获取对象的实例，如果容器中没有该实例则创建并存储在容器中，否则直接从容器中获取。不过，这段代码存在以下问题：</p><ol><li>线程不安全：在多线程环境下，存在并发访问和更新 ioc 容器的情况，可能导致数据不一致或者出现线程安全问题。</li><li>可能会导致内存泄漏：容器中存储了对象的实例，如果这些实例没有被及时清理或移除，可能会导致内存泄漏。</li><li>使用反射：在getInstance方法中使用Class.forName(className).newInstance()创建对象，这种方式会带来性能开销，且容易出现异常。建议改用其他创建对象的方式，比如工厂方法模式等。</li><li>只能通过类名获取实例：如果需要传递参数来创建对象，那么就需要修改getInstance方法的实现，这增加了代码的复杂性。</li></ol><p>针对以上问题，可以考虑使用线程安全的容器来存储对象实例，如ConcurrentHashMap；对于内存泄漏问题，可以考虑在适当的时候清理容器中的对象实例；对于反射和只能通过类名获取实例的问题，可以使用工厂方法等方式来创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****线程安全，懒加载的单例****/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContainerSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ContainerSingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ContainerSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getService</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ioc.containsKey(className)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ioc) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ioc.containsKey(className)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        instance = Class.forName(className).newInstance();</span><br><span class="line">                        ioc.put(className, instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            instance = ioc.get(className);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ContainerSingleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContainerSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于序列化和反序列化不一致问题，可以采用如下解决方案：</p><p>单例里面重写readResolve()方法，返回单例对象即可解决序列化单例不一致问题，因为在反序列化时会判断有没有写readResolve()方法，有的话就调用这个方法返回instance</p><h4 id="5-代理模式"><a href="#5-代理模式" class="headerlink" title="5.代理模式"></a>5.代理模式</h4><p><strong>应用场景：</strong>保护目标对象，增强目标对象</p><p><strong>静态代理：</strong>显示声明代理对象，只能代理指定类型对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态代理十分常见，属于硬编码，主要用一个代理对象来增强原来对象的功能</span></span><br><span class="line"><span class="comment">// 接口：定义了用户的行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标对象：实现了接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">implements</span> <span class="title class_">IUserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户保存成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象：也实现了接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">IUserDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理对象执行开始&quot;</span>);</span><br><span class="line">        userDao.save();  <span class="comment">// 调用目标对象的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代理对象执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码：使用代理对象调用目标对象的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IUserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        <span class="type">UserDaoProxy</span> <span class="variable">userDaoProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao);</span><br><span class="line">        userDaoProxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>动态代理：</strong>不论目标是啥，都能进行代理，主要分为jdk和CGLib两种动态代理方式</p><blockquote><p><strong>区别</strong>是，jdk的动态代理需要知道被代理类实现的接口，而cglib能够不需要知道</p><p>CGLib采用继承的方式，覆盖父类的方法</p><p>JDK采用的实现的方式们必须要求代理的目标对象一定要实现一个接口</p><p>思想：都是通过生成字节码，重组成一个新的类</p><p>其中，JDK Proxy对于用户而言，依赖更强，调用也更复杂</p><p>CGLib对于目标则没有任何的要求</p><p>CGLib底层没有用到反射，效率和性能更高</p><p>JDK Proxy生成逻辑较为简单，执行效率要低，每次都要用反射</p></blockquote><p><strong>注意，CGLib不能有fina修饰的方法，这一种方法会被忽略</strong></p><p>Spring种的代理选择原则</p><ul><li>当Bean<strong>有实现接口</strong>时，Spring就会用<strong>JDK</strong>的动态代理</li><li>当Bean没有实现接口时，Spring选择CGLib</li><li>Spring可以通过配置强制使用CGLib，只需要在Spring的配置文件中加入声明</li></ul><p>那么JDK和CGLib到底都是如何实现动态代理的呢？首先看下JDK动态代理实现流程</p><ol><li>定义一个接口和实现该接口的类。</li><li>创建一个 <code>InvocationHandler</code> 对象，并实现 <code>invoke</code> 方法，该方法将在代理对象上调用方法时被调用。</li><li>调用 <code>Proxy.newProxyInstance</code> 方法创建代理对象，并将实现了 <code>InvocationHandler</code> 接口的对象传递给它。</li><li>调用代理对象的方法，代理对象会调用 <code>InvocationHandler.invoke</code> 方法，并将方法名、参数和代理对象传递给它。</li></ol><p>下面是实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyExample</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I&#x27;m a dog.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AnimalInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Object target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AnimalInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.target = target;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Before method &quot;</span> + method.getName());</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">            System.out.println(<span class="string">&quot;After method &quot;</span> + method.getName());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">AnimalInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalInvocationHandler</span>(dog);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">proxy</span> <span class="operator">=</span> (Animal) Proxy.newProxyInstance(</span><br><span class="line">            dog.getClass().getClassLoader(),</span><br><span class="line">            dog.getClass().getInterfaces(),</span><br><span class="line">            handler);</span><br><span class="line">        proxy.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述示例中，我们定义了一个接口 <code>Animal</code> 和一个实现该接口的类 <code>Dog</code>。然后，我们创建了一个实现了 <code>InvocationHandler</code> 接口的类 <code>AnimalInvocationHandler</code>，它可以代理 <code>Animal</code> 接口的任何实现类。</p><p>在 <code>main</code> 方法中，我们首先创建了一个 <code>Dog</code> 实例 <code>dog</code>，然后创建了一个 <code>AnimalInvocationHandler</code> 实例 <code>handler</code>，将 <code>dog</code> 传入构造方法。最后，我们使用 <code>Proxy.newProxyInstance</code> 方法创建了一个 <code>Animal</code> 接口的代理对象 <code>proxy</code>，并将 <code>handler</code> 传入其中。</p><p>当我们调用 <code>proxy.say()</code> 时，<code>AnimalInvocationHandler.invoke</code> 方法会被调用，并在调用 <code>dog.say()</code> 方法前后输出了一些信息，以此实现了代理的效果。</p><p><strong>CGLib实现</strong></p><ol><li>引入 <code>cglib</code> 依赖。</li><li>定义一个类和继承该类的代理类。</li><li>创建一个 <code>MethodInterceptor</code> 对象，并实现 <code>intercept</code> 方法，该方法将在代理对象上调用方法时被调用。</li><li>使用 <code>Enhancer</code> 类创建代理对象，并将实现了 <code>MethodInterceptor</code> 接口的对象传递给它。</li><li>调用代理对象的方法，代理对象会调用 <code>MethodInterceptor.intercept</code> 方法，并将方法名、参数和代理对象传递给它。</li></ol><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，定义一个需要被代理的类 <code>UserDao</code> 和一个代理类 <code>UserDaoProxy</code>。这里 <code>UserDao</code> 类只有一个方法 <code>save()</code>，<code>UserDaoProxy</code> 类是一个代理类，继承自 <code>UserDao</code> 并重写了 <code>save()</code> 方法。在重写的方法中，我们可以添加一些代理逻辑，比如在调用被代理对象的方法之前或之后进行一些额外的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">extends</span> <span class="title class_">UserDao</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(UserDao.class);</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method invocation&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method invocation&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-建造者模式"><a href="#6-建造者模式" class="headerlink" title="6.建造者模式"></a>6.建造者模式</h4><p><strong>定义：</strong>是一个将复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示</p><p><strong>特征：</strong>用户只需指定需要建造的类型就可以获得对象，建造过程及细节不需要了解</p><p>把复杂对象的创建和使用分离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">withFirstName</span><span class="params">(String firstName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">withLastName</span><span class="params">(String lastName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">withAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">withAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123; firstName=&#x27;&quot;</span> + firstName + <span class="string">&quot;&#x27;, lastName=&#x27;&quot;</span> + lastName + <span class="string">&quot;&#x27;, age=&quot;</span> + age + <span class="string">&quot;, address=&#x27;&quot;</span> + address + <span class="string">&quot;&#x27; &#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">                            .withFirstName(<span class="string">&quot;John&quot;</span>)</span><br><span class="line">                            .withLastName(<span class="string">&quot;Doe&quot;</span>)</span><br><span class="line">                            .withAge(<span class="number">30</span>)</span><br><span class="line">                            .withAddress(<span class="string">&quot;123 Main Street&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-原型模式"><a href="#7-原型模式" class="headerlink" title="7.原型模式"></a>7.原型模式</h4><p><strong>定义：</strong>是指原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象</p><p>调用者不需要知道任何创建细节，不调用构造函数</p><blockquote><p>通俗讲法就是如何快速构建对象的方法总结，简单工厂将getter、setter封装到某个方法中</p><p>JDK提供的实现Cloneable接口，实现快速复制</p></blockquote><p><strong>适用场景</strong></p><p>1.类初始化消耗资源较多</p><p>2.new产生的一个对象需要非常繁琐的过程</p><p>3.构造函数比较复杂</p><p>4.循环体中产生大量对象时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypeExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">PrototypeExample</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> PrototypeExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">      <span class="keyword">return</span> (PrototypeExample) <span class="built_in">super</span>.clone();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在客户端代码中使用原型模式来创建新对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">      <span class="type">PrototypeExample</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrototypeExample</span>(<span class="string">&quot;example&quot;</span>);</span><br><span class="line">      <span class="type">PrototypeExample</span> <span class="variable">clone</span> <span class="operator">=</span> prototype.clone();</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">&quot;Original object name: &quot;</span> + prototype.getName());</span><br><span class="line">      System.out.println(<span class="string">&quot;Cloned object name: &quot;</span> + clone.getName());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型模式主要是通过类实现cloneable接口，覆写clone接口来实现拷贝，但是这里默认实现的还是浅拷贝，如果想实现深拷贝，需要手动指明非基本类型的拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数和getter/setter方法省略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">cloned</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.birthday = (Date) <span class="built_in">this</span>.birthday.clone();</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-适配器模式"><a href="#8-适配器模式" class="headerlink" title="8.适配器模式"></a>8.适配器模式</h4><p><strong>定义：</strong>又叫变压器模式，它的功能是将一个类的接口编程客户端所期待的一种接口，从而使原本因接口不匹配而导致无法在一起工作的两个类能够一起工作</p><blockquote><p>属于结构型设计模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LegacyRectangle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> length * width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleAdapter</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LegacyRectangle adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RectangleAdapter</span><span class="params">(LegacyRectangle adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> adaptee.calculateArea();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LegacyRectangle</span> <span class="variable">legacyRectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LegacyRectangle</span>();</span><br><span class="line">        <span class="type">RectangleAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RectangleAdapter</span>(legacyRectangle);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> adapter.getArea();</span><br><span class="line">        System.out.println(<span class="string">&quot;Area of rectangle: &quot;</span> + area);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，我们首先创建了一个LegacyRectangle对象，并将其传递给RectangleAdapter适配器类的构造函数。然后，我们使用适配器对象的getArea()方法来计算长方形面积，并输出结果。</p><h4 id="9-桥接模式"><a href="#9-桥接模式" class="headerlink" title="9.桥接模式"></a>9.桥接模式</h4><p><strong>定义：</strong>是一种结构型设计模式，它将抽象部分与实现部分分离开来，使它们可以独立地变化。桥接模式的核心思想是通过组合的方式，将一个类的实现细节委托给另一个类来完成。</p><p>桥接模式的主要目的是将抽象和实现解耦，使得它们可以独立地变化。抽象部分定义了系统的接口和一些高层次的操作，而实现部分负责具体的实现细节。通过将抽象和实现分离开来，桥接模式使得系统更加灵活，易于扩展和维护。</p><p>假设我们要设计一个绘图程序，它可以绘制不同类型的图形，例如圆形和矩形。我们可以使用桥接模式来将图形的类型（抽象部分）和绘制图形的具体方式（实现部分）分离开来。</p><p>首先，我们定义一个Shape抽象类，它包含一个DrawAPI成员变量，表示绘制图形的实现部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们定义一个DrawAPI接口，表示绘制图形的实现部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> radius)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们定义两个具体实现类，分别实现DrawAPI接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedCircle</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> radius)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing red circle at (&quot;</span> + x + <span class="string">&quot;,&quot;</span> + y + <span class="string">&quot;), radius &quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenRectangle</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> radius)</span> &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span></span><br></pre></td></tr></table></figure><h4 id="10-委派模式"><a href="#10-委派模式" class="headerlink" title="10.委派模式"></a>10.委派模式</h4><p><strong>定义：</strong>又叫委托模式，它的基本作用就是负责任务的调度和任务分配，将任务的分配和执行分离开来，可以看做是一种特殊情况下的静态代理的全权代理。</p><blockquote><p>不属于23种GOF设计模式之一</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskA</span> <span class="keyword">implements</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running Task A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskB</span> <span class="keyword">implements</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running Task B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskDelegator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Task&gt; taskMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TaskDelegator</span><span class="params">()</span> &#123;</span><br><span class="line">        taskMap.put(<span class="string">&quot;TaskA&quot;</span>, <span class="keyword">new</span> <span class="title class_">TaskA</span>());</span><br><span class="line">        taskMap.put(<span class="string">&quot;TaskB&quot;</span>, <span class="keyword">new</span> <span class="title class_">TaskB</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">(String taskName)</span> &#123;</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskMap.get(taskName);</span><br><span class="line">        <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Unknown task: &quot;</span> + taskName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegationPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TaskDelegator</span> <span class="variable">taskDelegator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskDelegator</span>();</span><br><span class="line">        taskDelegator.doTask(<span class="string">&quot;TaskA&quot;</span>);</span><br><span class="line">        taskDelegator.doTask(<span class="string">&quot;TaskB&quot;</span>);</span><br><span class="line">        taskDelegator.doTask(<span class="string">&quot;TaskC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-模版模式"><a href="#11-模版模式" class="headerlink" title="11.模版模式"></a>11.模版模式</h4><p><strong>定义：</strong>是一种行为型设计模式，它定义了一个算法的骨架，将一些步骤延迟到子类中实现，从而使得子类可以改变算法的某些特定步骤，而不改变算法的结构。</p><p><strong>解析：</strong>模版模式是在框架和日常开发之中使用比较多的一种设计模式，适合具有大量重复操作的步骤，将这些重复内容抽离出来放进模版之中，后续的开发只需要继承模版并实现个性化部分即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">startPlay</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">endPlay</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 初始化游戏</span></span><br><span class="line">        initialize();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 抽取出的公共部分方法</span></span><br><span class="line">      doSomething1();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 开始游戏</span></span><br><span class="line">        startPlay();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 抽取出的公共部分方法</span></span><br><span class="line">      doSomething2();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 结束游戏</span></span><br><span class="line">        endPlay();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protect <span class="keyword">void</span> <span class="title function_">doSomething1</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;模版内固定方法1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  protect <span class="keyword">void</span> <span class="title function_">doSomething2</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;模版内固定方法2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cricket</span> <span class="keyword">extends</span> <span class="title class_">Game</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">endPlay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cricket Game Finished!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cricket Game Initialized! Start playing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">startPlay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cricket Game Started. Enjoy the game!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Football</span> <span class="keyword">extends</span> <span class="title class_">Game</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">endPlay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Finished!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Initialized! Start playing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">startPlay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Started. Enjoy the game!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameTemplatePatternDemo</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">Game</span> <span class="variable">game</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cricket</span>();</span><br><span class="line">        game.play();</span><br><span class="line">        System.out.println();</span><br><span class="line"> </span><br><span class="line">        game = <span class="keyword">new</span> <span class="title class_">Football</span>();</span><br><span class="line">        game.play();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-策略模式"><a href="#12-策略模式" class="headerlink" title="12.策略模式"></a>12.策略模式</h4><p><strong>定义：</strong>又叫政策模式，它是将定义的算法家族，分别封装起来，让他们之间可以相互替换，从而让算法的变化不会影响到使用算法的用户。</p><p><strong>可以避免多重的if-else语句</strong>，使用map或者数据库配置</p><blockquote><p>属于行为型模式</p></blockquote><p>以下是一个简单的示例，演示如何使用策略模式计算两个数字的和。该示例包括一个接口<code>Strategy</code>，它定义了一个<code>doOperation</code>方法，以及三个实现类：<code>AddStrategy</code>、<code>SubtractStrategy</code>和<code>MultiplyStrategy</code>，它们分别实现了<code>doOperation</code>方法，用于执行加法、减法和乘法运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义策略接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现加法策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现减法策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubtractStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现乘法策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiplyStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类，负责选择和执行具体策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">executeStrategy</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">AddStrategy</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">SubtractStrategy</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">MultiplyStrategy</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 * 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础之集合源码分析</title>
      <link href="/2023/03/21/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2023/03/21/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="java集合源码分析"><a href="#java集合源码分析" class="headerlink" title="java集合源码分析"></a>java集合源码分析</h2><h3 id="一、java集合"><a href="#一、java集合" class="headerlink" title="一、java集合"></a>一、java集合</h3><h4 id="1-ArrayList源码"><a href="#1-ArrayList源码" class="headerlink" title="1.ArrayList源码"></a>1.ArrayList源码</h4><h5 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认数组长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 默认空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">// 集合大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定初始容量的构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                         initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认空初始化---懒加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入实现了Collection接口的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">           elementData = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="add操作"><a href="#add操作" class="headerlink" title="add操作"></a>add操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最常用方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 确定容量 动态扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 进数组</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定位置插入，不常用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定数组大小并决定是否扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">  ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算较大值 minCapacity是size+1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">      <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 确定是否需要扩容 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存不足，需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">      grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩容 每次扩容1.5倍</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">// 新数组长度 = 1.5 * 旧数组长度</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity); <span class="comment">// 复制到新数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么ArrayList每次扩容容积都要变成原来的1.5倍呢？</p><p>在ArrayList的实现中，每次扩容容量都会增加原来容量的一半。这个增量的选择是为了在避免频繁扩容和节省内存之间寻求一个平衡点。</p><p>具体来说，如果每次只增加一个固定的值，那么当需要容纳大量元素时，ArrayList可能会不断地进行扩容操作，这会导致额外的内存分配和复制元素的开销。而如果每次增加原容量的比例太小，那么ArrayList可能需要频繁进行扩容操作，这同样会导致不必要的开销。</p><p>因此，1.5倍的增量选择是一种折中方案，既可以避免过于频繁的扩容操作，又可以减少额外的内存分配和元素复制的开销。同时，这个增量值也可以根据实际情况进行调整。</p></blockquote><h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">  rangeCheck(index); <span class="comment">// 检查是否数组越界</span></span><br><span class="line">  <span class="keyword">return</span> ArrayList.<span class="built_in">this</span>.elementData(offset + index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在多线程环境下，如果一个线程修改了集合中的元素，而另一个线程正在遍历这个集合，就可能会导致遍历出错。为了避免这种情况的发生，<code>ArrayList</code>类提供了<code>checkForComodification</code>方法，用于检测集合是否在遍历过程中被修改过。</p><p><code>modCount</code>变量表示<code>ArrayList</code>被修改的次数，每次修改（增加或删除元素）时<code>modCount</code>会自增</p></blockquote><h5 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E e)</span> &#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">// 检查是否越界</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> ArrayList.<span class="built_in">this</span>.elementData(offset + index); <span class="comment">// 获取原来下标对应的值</span></span><br><span class="line">    ArrayList.<span class="built_in">this</span>.elementData[offset + index] = e;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;<span class="comment">// 要移动元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 从删除位置往后拷贝删除</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                       numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-LinkedList源码"><a href="#2-LinkedList源码" class="headerlink" title="2.LinkedList源码"></a>2.LinkedList源码</h4><h5 id="前置声明-1"><a href="#前置声明-1" class="headerlink" title="前置声明"></a>前置声明</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组大小</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装的节点类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入实现Collection接口的其他对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增单个节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾插法插入新节点</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">      first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="get方法-1"><a href="#get方法-1" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取index位置数值</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index); <span class="comment">// 检查是否越界</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历查找</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">          x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">          x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="set方法-1"><a href="#set方法-1" class="headerlink" title="set方法"></a>set方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    checkElementIndex(index); <span class="comment">// 检查越界</span></span><br><span class="line">    Node&lt;E&gt; x = node(index); <span class="comment">// 找到节点</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove方法-1"><a href="#remove方法-1" class="headerlink" title="remove方法"></a>remove方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除某一坐标节点</span></span><br><span class="line"> <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">     checkElementIndex(index);</span><br><span class="line">     <span class="keyword">return</span> unlink(node(index)); <span class="comment">// node找到index位置的节点</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 删除节点</span></span><br><span class="line"> E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">     <span class="comment">// assert x != null;</span></span><br><span class="line">     <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">         first = next;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         prev.next = next;</span><br><span class="line">         x.prev = <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">         last = prev;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         next.prev = prev;</span><br><span class="line">         x.next = <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     x.item = <span class="literal">null</span>;</span><br><span class="line">     size--;</span><br><span class="line">     modCount++;</span><br><span class="line">     <span class="keyword">return</span> element;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="3-HashMap源码"><a href="#3-HashMap源码" class="headerlink" title="3.HashMap源码"></a>3.HashMap源码</h4><h5 id="前置声明-2"><a href="#前置声明-2" class="headerlink" title="前置声明"></a>前置声明</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认容初始量 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大容量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认负载因子</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转红黑树阈值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扩容后树转链表阈值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最小树化数组阈值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装的节点---hashmap中数据都以Node结构存储在桶中</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">      <span class="keyword">final</span> K key;</span><br><span class="line">      V value;</span><br><span class="line">      Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">      Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">          <span class="built_in">this</span>.hash = hash;</span><br><span class="line">          <span class="built_in">this</span>.key = key;</span><br><span class="line">          <span class="built_in">this</span>.value = value;</span><br><span class="line">          <span class="built_in">this</span>.next = next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">          <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">          value = newValue;</span><br><span class="line">          <span class="keyword">return</span> oldValue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">              Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">              <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                  Objects.equals(value, e.getValue()))</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 散列函数 使用 扰动函数 将哈希值进一步打乱</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      <span class="type">int</span> h;</span><br><span class="line">      <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定初始化容量与负载因子---很少使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定初始化容量---用于知道hashmap大概要存储多少数据时</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 默认构造方法，使用默认负载因子</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 传进来一个map初始化</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// put方法，本质是调用putVal</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 实际上实现put方法的地方</span></span><br><span class="line">  <span class="comment">/********onlyIfAbsent – if true, don&#x27;t change existing value********/</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                 <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// tab就是哈希桶，也就是数组+链表中的数组部分 p用来指向key对应的桶位置节点</span></span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 未初始化，先resize进行初始化</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// p指向要插入的桶节点位置，判断当前位置是否为空，为空直接把value封装放进去</span></span><br><span class="line">     <span class="comment">// (n - 1) &amp; hash 这一步很妙，与double扩容配合可以使得扩容时，节点要么不移动桶位置，要么+原数组长度移动</span></span><br><span class="line">      <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>) </span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 存在哈希冲突 e是要插入的位置，如果已存在这个key，e就指向这个key对应的节点</span></span><br><span class="line">          Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 桶处的根节点和插入的key相等，直接把e指向p</span></span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              e = p;</span><br><span class="line">        <span class="comment">// 如果桶位置已经树化，调用树的putTreeVal方法</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">              e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value); <span class="comment">// 树版本的putVal</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 未树化，则遍历找到要插入位置</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                  <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                      p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 如果插入之后链表长度达到阈值，尝试树化</span></span><br><span class="line">                      <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                          treeifyBin(tab, hash);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                <span class="comment">// 找到已存在key对应节点</span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  p = e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// key已存在，替换value</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">              <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                  e.value = value;</span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++modCount;</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">      <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">          resize();</span><br><span class="line">      afterNodeInsertion(evict);  <span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试将链表树化</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">      <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 如果数组长度未达阈值（64），则先进行数组扩容</span></span><br><span class="line">      <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">          resize();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">              <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                  hd = p;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  p.prev = tl;</span><br><span class="line">                  tl.next = p;</span><br><span class="line">              &#125;</span><br><span class="line">              tl = p;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">              hd.treeify(tab);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">      <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span> oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// 新容量是原来两倍</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 扩容临界值也两倍</span></span><br><span class="line">              newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">          newCap = oldThr;</span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line">      threshold = newThr;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">      Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123; <span class="comment">// 初始时不需要复制</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                  oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 桶中元素就一个 找到元素新位置赋值</span></span><br><span class="line">                      newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 移动树</span></span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                  <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                      Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; next;</span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line">                          <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                      <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                          loTail.next = <span class="literal">null</span>;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                          hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="get方法-2"><a href="#get方法-2" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取key对应值</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际调用方式</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// first是哈希后桶位置上第一个节点</span></span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接找到</span></span><br><span class="line">          <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">              ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              <span class="keyword">return</span> first;</span><br><span class="line">          <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历树</span></span><br><span class="line">              <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">return</span> e;</span><br><span class="line">              &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="remove方法-2"><a href="#remove方法-2" class="headerlink" title="remove方法"></a>remove方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">          <span class="literal">null</span> : e.value;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 找到节点，删除即可，注意树结构删除节点之后可能会退化</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                             <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">          Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              node = p;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">do</span> &#123;</span><br><span class="line">                      <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                          ((k = e.key) == key ||</span><br><span class="line">                           (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                          node = e;</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                      p = e;</span><br><span class="line">                  &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                               (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">              <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                  tab[index] = node.next;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  p.next = node.next;</span><br><span class="line">              ++modCount;</span><br><span class="line">              --size;</span><br><span class="line">              afterNodeRemoval(node);</span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="4-modCount与FailFast机制"><a href="#4-modCount与FailFast机制" class="headerlink" title="4.modCount与FailFast机制"></a>4.modCount与FailFast机制</h4><p>上面三个类里面，都有monCount变量，那么这个变量是什么，有什么用处呢？</p><p>在 Java 集合中，modCount 是用于实现<strong>“快速失败”</strong>机制的一个计数器，用于跟踪集合对象自创建以来所发生的修改次数。当通过迭代器遍历集合时，如果在迭代过程中发现集合的 modCount 发生了变化，就会立即抛出 ConcurrentModificationException 异常，以避免并发修改导致的数据不一致问题。</p><p>快速失败机制的目的是为了保证多个线程并发操作同一个集合时的数据一致性。如果不使用快速失败机制，可能会导致数据不一致，而且这种不一致的结果可能是不可预测的。</p><p>因此，集合类在实现迭代器时，通常会在每次进行<strong>修改（新增，删除，更新）</strong>操作时，将 modCount 的计数器加 1，以便在下次迭代时检测到修改操作，抛出异常以提醒程序员代码存在问题。同时，这也是 Java 集合框架的一个核心设计原则之一，即在多线程环境中保证数据的一致性。</p><h4 id="5-Vector"><a href="#5-Vector" class="headerlink" title="5.Vector"></a>5.Vector</h4><p>和ArrayList很相似，都是以动态数组的形式来存储数据，但是它是线程安全的，Vector的线程安全来自于每一个操作方法都加上了synchronized关键字，对性能来说有较大影响，目前属于逐渐废弃的方法</p><p>而对于ArrayList这种非线程安全的数组，可以使用Collections工具来实现线程安全，比Vector更加安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">syncList</span> <span class="operator">=</span> Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure><p>本质上是工具类为原方法封装了加锁的同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.get(index);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.set(index, element);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;list.add(index, element);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.remove(index);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatisPlus之条件构造器</title>
      <link href="/2022/08/24/%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8/"/>
      <url>/2022/08/24/%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><blockquote><p>说明：</p><p>条件构造器构造条件时，一般支持两到三个入参，使用以下两个入参情况较多（R column, Object val）；第一个参数是一个 boolean 类型，默认为 true，表示加入到最后构造的 sql 当中；因此在构造条件时，可以将判断加在外面，也可以写在第一个参数处</p></blockquote><h2 id="二、Wrapper"><a href="#二、Wrapper" class="headerlink" title="二、Wrapper"></a>二、Wrapper</h2><h3 id="AbstractWrapper"><a href="#AbstractWrapper" class="headerlink" title="AbstractWrapper"></a>AbstractWrapper</h3><blockquote><p>说明:</p><p>QueryWrapper (LambdaQueryWrapper) 和 UpdateWrapper (LambdaUpdateWrapper) 的父类用于生成 sql 的 where 条件，entity 属性也用于生成 sql 的 where 条件<br>注意: entity 生成的 where 条件与 使用各个 api 生成的 where 条件<strong>没有任何关联行为</strong></p></blockquote><p>作为父类，AbstractWrapper 包含了大量构造条件所用方法</p><p>常用方法不再赘述，具体参考 MyBatis-Plus 官网：<a href="https://baomidou.com/pages/10c804/#alleq:~:text=%23-,AbstractWrapper,-%E8%AF%B4%E6%98%8E%3A">条件构造器 - AbstractWrapper</a></p><p>需要稍微注意的是以下几个方法</p><h4 id="inSql"><a href="#inSql" class="headerlink" title="inSql"></a>inSql</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inSql(R column, String inValue)</span><br></pre></td></tr></table></figure><p>其中，inValue 代表 sql 语句，即开发者可以直接将 sql 语句作为参数传递进来，作为查询条件构造</p><ul><li>字段 IN (sql 语句)</li><li>例: <code>inSql(&quot;age&quot;, &quot;1,2,3,4,5,6&quot;)</code>—&gt;<code>age in (1,2,3,4,5,6)</code></li><li>例: <code>inSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)</code>—&gt;<code>id in (select id from table where id &lt; 3)</code></li></ul><h4 id="having"><a href="#having" class="headerlink" title="having"></a>having</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">having(String sqlHaving, Object... params)</span><br><span class="line">having(<span class="type">boolean</span> condition, String sqlHaving, Object... params)</span><br></pre></td></tr></table></figure><ul><li>HAVING (sql 语句)</li><li>例: <code>having(&quot;sum(age) &gt; 10&quot;)</code>—&gt;<code>having sum(age) &gt; 10</code></li><li>例: <code>having(&quot;sum(age) &gt; &#123;0&#125;&quot;, 11)</code>—&gt;<code>having sum(age) &gt; 11</code></li></ul><h4 id="func"><a href="#func" class="headerlink" title="func"></a>func</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(Consumer&lt;Children&gt; consumer)</span><br><span class="line">func(<span class="type">boolean</span> condition, Consumer&lt;Children&gt; consumer)</span><br></pre></td></tr></table></figure><ul><li>func 方法 (主要方便在出现 if…else 下调用不同方法能不断链)</li><li>例: <code>func(i -&gt; if(true) &#123;i.eq(&quot;id&quot;, 1)&#125; else &#123;i.ne(&quot;id&quot;, 1)&#125;)</code></li></ul><h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">or()</span><br><span class="line">or(<span class="type">boolean</span> condition)</span><br></pre></td></tr></table></figure><ul><li><p>拼接 OR</p><p>注意事项:</p><p>主动调用 <code>or</code> 表示紧接着下一个<strong>方法</strong>不是用 <code>and</code> 连接！(不调用 <code>or</code> 则默认为使用 <code>and</code> 连接)</p></li><li><p>例: <code>eq(&quot;id&quot;,1).or().eq(&quot;name&quot;,&quot;老王&quot;)</code>—&gt;<code>id = 1 or name = &#39;老王&#39;</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">or(Consumer&lt;Param&gt; consumer)</span><br><span class="line">or(<span class="type">boolean</span> condition, Consumer&lt;Param&gt; consumer)</span><br></pre></td></tr></table></figure><ul><li>OR 嵌套</li><li>例: <code>or(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))</code>—&gt;<code>or (name = &#39;李白&#39; and status &lt;&gt; &#39;活着&#39;)</code></li></ul><h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and(Consumer&lt;Param&gt; consumer)</span><br><span class="line">and(<span class="type">boolean</span> condition, Consumer&lt;Param&gt; consumer)</span><br></pre></td></tr></table></figure><ul><li>AND 嵌套</li><li>例: <code>and(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))</code>—&gt;<code>and (name = &#39;李白&#39; and status &lt;&gt; &#39;活着&#39;)</code></li></ul><h3 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h3><blockquote><p>说明:</p><p>继承自 AbstractWrapper , 自身的内部属性 entity 也用于生成 where 条件<br>及 LambdaQueryWrapper, 可以通过 new QueryWrapper ().lambda () 方法获取</p></blockquote><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select(String... sqlSelect)</span><br><span class="line">select(Predicate&lt;TableFieldInfo&gt; predicate)</span><br><span class="line">select(Class&lt;T&gt; entityClass, Predicate&lt;TableFieldInfo&gt; predicate)</span><br></pre></td></tr></table></figure><ul><li><p>设置查询字段</p><blockquote><p>说明:</p><p>以上方法分为两类.<br>第二类方法为：过滤查询字段 (主键除外), 入参不包含 class 的调用前需要 <code>wrapper</code> 内的 <code>entity</code> 属性有值！这两类方法重复调用以最后一次为准</p></blockquote></li><li><p>例: <code>select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;)</code></p></li><li><p>例: <code>select(i -&gt; i.getProperty().startsWith(&quot;test&quot;))</code></p></li></ul><p>在构造 Wrapper 时，使用 select 可以减少无用字段的查询</p><h3 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a>UpdateWrapper</h3><blockquote><p>说明:</p><p>继承自 <code>AbstractWrapper</code> , 自身的内部属性 <code>entity</code> 也用于生成 where 条件<br>及 <code>LambdaUpdateWrapper</code>, 可以通过 <code>new UpdateWrapper().lambda()</code> 方法获取！</p></blockquote><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(String column, Object val)</span><br><span class="line">set(<span class="type">boolean</span> condition, String column, Object val)</span><br></pre></td></tr></table></figure><ul><li>SQL SET 字段</li><li>例: <code>set(&quot;name&quot;, &quot;老李头&quot;)</code></li><li>例: <code>set(&quot;name&quot;, &quot;&quot;)</code>—&gt; 数据库字段值变为<strong>空字符串</strong></li><li>例: <code>set(&quot;name&quot;, null)</code>—&gt; 数据库字段值变为 <code>null</code></li></ul><h4 id="setSql"><a href="#setSql" class="headerlink" title="setSql"></a>setSql</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setSql(String sql)</span><br></pre></td></tr></table></figure><ul><li>设置 SET 部分 SQL</li><li>例: <code>setSql(&quot;name = &#39;老李头&#39;&quot;)</code></li></ul><h4 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h4><ul><li>获取 <code>LambdaWrapper</code><br>在 <code>QueryWrapper</code> 中是获取 <code>LambdaQueryWrapper</code><br>在 <code>UpdateWrapper</code> 中是获取 <code>LambdaUpdateWrapper</code></li></ul><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>上面介绍的都是常规用法，MyBatis-Plus 还支持一些更为简洁的书写方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">LambdaUpdateChainWrapper</span>&lt;&gt;(testMapper)</span><br><span class="line">        .eq(TestEntity::getIsDelete,<span class="number">0</span>)</span><br><span class="line">        .eq(TestEntity::getName,<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">        .eq(TestEntity::getAge,<span class="number">18</span>)</span><br><span class="line">        .set(TestEntity::getAge,<span class="number">20</span>)</span><br><span class="line">        .set(TestEntity::getUpdateTime,<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">        .update();</span><br></pre></td></tr></table></figure><p>这种方法能够直接按照条件查询并更新数据库</p><blockquote><p>此外，需要注意 @TableField (exist &#x3D; false) 注解，加了这个注解的参数不会再往数据库写入，同样无法作为条件参数进行查询</p></blockquote><h3 id="使用-Wrapper-自定义-SQL"><a href="#使用-Wrapper-自定义-SQL" class="headerlink" title="使用 Wrapper 自定义 SQL"></a>使用 Wrapper 自定义 SQL</h3><blockquote><p>注意事项:</p><p>需要 <code>mybatis-plus</code> 版本 &gt;&#x3D; <code>3.0.7</code> param 参数名要么叫 <code>ew</code>, 要么加上注解 <code>@Param(Constants.WRAPPER)</code> 使用 <code>$&#123;ew.customSqlSegment&#125;</code> 不支持 <code>Wrapper</code> 内的 entity 生成 where 语句</p></blockquote><h4 id="用注解"><a href="#用注解" class="headerlink" title="用注解"></a>用注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from mysql_data $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">List&lt;MysqlData&gt; <span class="title function_">getAll</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper wrapper)</span>;</span><br></pre></td></tr></table></figure><h4 id="用-XML"><a href="#用-XML" class="headerlink" title="用 XML"></a>用 XML</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;MysqlData&gt; <span class="title function_">getAll</span><span class="params">(Wrapper ew)</span>;</span><br><span class="line">XML</span><br><span class="line">&lt;select id=<span class="string">&quot;getAll&quot;</span> resultType=<span class="string">&quot;MysqlData&quot;</span>&gt;</span><br><span class="line">SELECT * FROM mysql_data $&#123;ew.customSqlSegment&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>该方法可以将 sql 与使用 Wrapper 构造的查询条件进行拼接，在业务比较复杂，使用 wrapper 又无法满足需求的时候，拼接可以减少不必要的重写 sql 工作</p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis-Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>下面是自己实现的不同排序算法，仅做随时复习观看用</p><h3 id="一、排序算法比较"><a href="#一、排序算法比较" class="headerlink" title="一、排序算法比较"></a>一、排序算法比较</h3><table><thead><tr><th>排序算法</th><th>时间复杂度（平均）</th><th>时间复杂度（最坏）</th><th>时间复杂度（最好）</th><th>空间复杂度</th><th>稳定性</th><th>复杂性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(N2)</td><td>O(N2)</td><td>O(N)</td><td>O(1)</td><td>稳定</td><td>简单</td></tr><tr><td>选择排序</td><td>O(N2)</td><td>O(N2)</td><td>O(N2)</td><td>O(1)</td><td>不稳定</td><td>简单</td></tr><tr><td>插入排序</td><td>O(N2)</td><td>O(N2)</td><td>O(N)</td><td>O(1)</td><td>稳定</td><td>简单</td></tr><tr><td>希尔排序</td><td>O(N1.3)</td><td>O(n(logN)^2)</td><td>O(N)</td><td>O(1)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>归并排序</td><td>O(NlogN)</td><td>O(NlogN)</td><td>O(NlogN)</td><td>O(N)</td><td>稳定</td><td>较复杂</td></tr><tr><td>快速排序</td><td>O(NlogN)</td><td>O(N2)</td><td>O(NlogN)</td><td>O(logN)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>堆排序</td><td>O(NlogN)</td><td>O(NlogN)</td><td>O(NlogN)</td><td>O(1)</td><td>不稳定</td><td>较复杂</td></tr></tbody></table><h3 id="二、算法实现"><a href="#二、算法实现" class="headerlink" title="二、算法实现"></a>二、算法实现</h3><h4 id="1-前置方法，用于交换"><a href="#1-前置方法，用于交换" class="headerlink" title="1.前置方法，用于交换"></a>1.前置方法，用于交换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> j, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2.冒泡排序"></a>2.冒泡排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="comment">// 依次比较两个数大小，每次确定末尾一个数是多少</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;bubbleSort:&quot;</span>+Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="comment">// 每次找到最大的值是多少，然后按顺序插入</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[temp])&#123;</span><br><span class="line">                temp = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,temp,i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;selectSort:&quot;</span>+Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4.插入排序"></a>4.插入排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="comment">// 每次找到排序的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; arr[i] &lt; arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">            swap(arr,i,i-<span class="number">1</span>);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;insertSort:&quot;</span>+Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5.希尔排序"></a>5.希尔排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="comment">// 增量缩小+插入排序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(gap != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i - gap &gt;= <span class="number">0</span> &amp;&amp; arr[i] &lt; arr[i-gap])&#123;</span><br><span class="line">                swap(arr,i,i-gap);</span><br><span class="line">                i -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;shellSort:&quot;</span>+Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6.归并排序"></a>6.归并排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> len / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[] left = Arrays.copyOfRange(arr,<span class="number">0</span>,mid);</span><br><span class="line">    <span class="type">int</span>[] right = Arrays.copyOfRange(arr,mid,len);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left),mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] merge(<span class="type">int</span>[] left, <span class="type">int</span>[] right) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lLen</span> <span class="operator">=</span> left.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rLen</span> <span class="operator">=</span> right.length;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[lLen+rLen];</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; lLen &amp;&amp; q &lt; rLen) &#123;</span><br><span class="line">        <span class="keyword">if</span>(left[p] &lt; right[q])&#123;</span><br><span class="line">            arr[i++] = left[p++];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            arr[i++] = right[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; lLen) arr[i++] = left[p++];</span><br><span class="line">    <span class="keyword">while</span> (q &lt; rLen) arr[i++] = right[q++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7.快速排序"></a>7.快速排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fastSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (end &lt;= start) <span class="keyword">return</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr,start,end);</span><br><span class="line">      fastSort(arr,start,pivot-<span class="number">1</span>);</span><br><span class="line">      fastSort(arr,pivot+<span class="number">1</span>,end);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">      <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">      <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> random.nextInt(end-start)+start;</span><br><span class="line">      swap(arr,start,p);</span><br><span class="line">      <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">      <span class="keyword">while</span> (start &lt; end)&#123;</span><br><span class="line">          <span class="keyword">while</span> (start &lt; end &amp;&amp; arr[end] &gt;= temp) end--;</span><br><span class="line">          arr[start] = arr[end];</span><br><span class="line">          <span class="keyword">while</span> (start &lt; end &amp;&amp; arr[start] &lt; temp) start++;</span><br><span class="line">          arr[end] = arr[start];</span><br><span class="line">      &#125;</span><br><span class="line">      arr[start] = temp;</span><br><span class="line">      <span class="keyword">return</span> start;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-堆排序"><a href="#8-堆排序" class="headerlink" title="8.堆排序"></a>8.堆排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">      <span class="comment">// 建堆 大根堆</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">          heapInsert(arr,i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调整，排序</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> len;</span><br><span class="line">      <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">          swap(arr,<span class="number">0</span>,heapSize-<span class="number">1</span>);</span><br><span class="line">          heapify(arr,heapSize-<span class="number">1</span>);</span><br><span class="line">          heapSize--;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;heapSort:&quot;</span>+Arrays.toString(arr));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调整0——heapSize-1</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (p &lt; heapSize)&#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> p * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">          <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (left &gt;= heapSize) <span class="keyword">return</span>;</span><br><span class="line">          <span class="keyword">if</span>(right &lt; heapSize &amp;&amp; arr[right] &gt; arr[left]) left = right;</span><br><span class="line">          <span class="keyword">if</span>(arr[left] &gt; arr[p]) &#123;</span><br><span class="line">              swap(arr,p,left);</span><br><span class="line">              p = left;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> i/<span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span>(arr[f] &lt;= arr[i]) &#123;</span><br><span class="line">              swap(arr,f,i);</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          i /= <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础之认识NlogN的排序</title>
      <link href="/2022/05/24/%E8%AE%A4%E8%AF%86NlogN%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/05/24/%E8%AE%A4%E8%AF%86NlogN%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础-归并排序"><a href="#一、基础-归并排序" class="headerlink" title="一、基础 - 归并排序"></a>一、基础 - 归并排序</h2><p>归并排序思想十分简单，但是利用归并排序的变形，可以解决一些看似较为复杂的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> ;</span><br><span class="line">      mergeSort(array,<span class="number">0</span>,array.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right == left) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        mergeSort(array,left,mid);</span><br><span class="line">        mergeSort(array,mid + <span class="number">1</span>,right);</span><br><span class="line">        merge(array,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span>&#123;</span><br><span class="line"><span class="comment">//归并排序特点，开辟一个辅助数组</span></span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right)&#123;</span><br><span class="line">            help[i++] = array[p1] &lt; array[p2] ? array[p1++] : array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid)&#123;</span><br><span class="line">            help[i++] = array[p1++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= right)&#123;</span><br><span class="line">            help[i++] = array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//排好序数组写回原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : help) &#123;</span><br><span class="line">            array[left++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        solution.mergeSort(nums);</span><br><span class="line">        System.out.println(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、拓展"><a href="#二、拓展" class="headerlink" title="二、拓展"></a>二、拓展</h2><h3 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h3><p><strong>问题描述：</strong></p><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。</p><p><strong>例子：</strong></p><p>求数组 [1,3,4,2,5] 的小和</p><p><strong>分析：</strong></p><p>3 左边比 3 小的数，1</p><p>4 左边比 4 小的数，1、3</p><p>2 左边比 2 小的数，1</p><p>5 左边比 5 小的数，1、3、4、2</p><p>所以小和为 1+1+3+1+1+3+4+2&#x3D;16</p><p><strong>求小和算法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> mergeSort(array,<span class="number">0</span>,array.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right == left) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSum</span> <span class="operator">=</span> mergeSort(array,left,mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightSum</span> <span class="operator">=</span> mergeSort(array,mid + <span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> leftSum + rightSum + merge(array,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span>&#123;</span><br><span class="line"><span class="comment">//开辟辅助数组</span></span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//小和结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right)&#123;</span><br><span class="line">          <span class="comment">//核心步骤，重点在于两边数组都是归并排好序的数组</span></span><br><span class="line">          <span class="comment">//因此array[p2]和其右边的值都大于array[p1]</span></span><br><span class="line">            result += array[p1] &lt; array[p2] ? (right - p2 + <span class="number">1</span>) * array[p1] : <span class="number">0</span>;</span><br><span class="line">            help[i++] = array[p1] &lt; array[p2] ? array[p1++] : array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid)&#123;</span><br><span class="line">            help[i++] = array[p1++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= right)&#123;</span><br><span class="line">            help[i++] = array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : help) &#123;</span><br><span class="line">            array[left++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(solution.mergeSort(nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>小和问题是经典的归并排序变形问题，与此类似的还有逆序对问题</p><h3 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h3><p>在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对（个数）。</p><blockquote><p>仅需改动核心步骤即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依然递增排序</span></span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right)&#123;</span><br><span class="line">  <span class="comment">//核心步骤，重点在于两边数组都是归并排好序的数组</span></span><br><span class="line">  <span class="comment">//打印逆序对</span></span><br><span class="line">  <span class="keyword">if</span>(array[p1] &gt; array[p2])&#123;</span><br><span class="line">  <span class="comment">//p1右边的都比p2大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p1;i&lt;mid;i++)&#123;</span><br><span class="line">      System.out.println(array[p1]+<span class="string">&quot;,&quot;</span>+array[p2]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//逆序对个数</span></span><br><span class="line">  <span class="comment">//result += array[p1] &gt; array[p2] ? (mid - p1 + 1) : 0;</span></span><br><span class="line">  help[i++] = array[p1] &lt; array[p2] ? array[p1++] : array[p2++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆序对与小和问题本质一样，除此之外，还有荷兰国旗问题，是小和问题的轻微进阶版本</p><h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><p>给定一个数组 arr，和一个数 num，请把小于 num 的数放在数组的左边，等于 num 的数放在数组的中间，大于 num 的数放在数组的右边。要求额外空间复杂度 O (1)，时间复杂度 O (N)</p><blockquote><p>返回值含义： 一定会返回一个长度为 2 的数组，等于区域的左边界和右边界（也就是相等区域的边界范围 ）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span>[] partition(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> num) &#123;</span><br><span class="line">    <span class="comment">//less为小于num区的边界，more为大于num的边界，left当做遍历数组的指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; more)&#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[left] &lt; num)&#123;</span><br><span class="line">        swap(arr,left++,++less);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[left] &gt; num)&#123;</span><br><span class="line">        swap(arr,--more,left);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        left++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;less + <span class="number">1</span>,more - <span class="number">1</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    solution.partition(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">    System.out.println(solution.partition(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>,<span class="number">5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p>【1】<a href="https://juejin.cn/post/7137283772797419534">认识认识 O (NlogN) 的排序 | 左程云算法笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础之时间复杂度</title>
      <link href="/2022/04/24/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2022/04/24/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础-简单排序算法"><a href="#一、基础-简单排序算法" class="headerlink" title="一、基础 - 简单排序算法"></a>一、基础 - 简单排序算法</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;<span class="comment">//记录最小值位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;<span class="comment">//改变最小值位置</span></span><br><span class="line">&#125;</span><br><span class="line">swap(arr, i, minIndex);<span class="comment">//交换最小值到前面 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; e &gt; <span class="number">0</span>; e--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(arr, i, i + <span class="number">1</span>);<span class="comment">//把较大数交换到后面</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">//只有i，j两个位置不同时可以这么写</span></span><br><span class="line">    <span class="comment">//否则会将数据抹成0</span></span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">arr[j] = arr[i] ^ arr[j];</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">arr[j] = arr[i] ^ arr[j];</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分法的详解与扩展"><a href="#二分法的详解与扩展" class="headerlink" title="二分法的详解与扩展"></a>二分法的详解与扩展</h3><h4 id="1）在一个有序数组中，找某个数是否存在"><a href="#1）在一个有序数组中，找某个数是否存在" class="headerlink" title="1）在一个有序数组中，找某个数是否存在"></a>1）在一个有序数组中，找某个数是否存在</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">int</span>[] sortedArr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (sortedArr == <span class="literal">null</span> || sortedArr.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> sortedArr.length - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (sortedArr[mid] == num) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sortedArr[mid] &gt; num) &#123;</span><br><span class="line">R = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">L = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sortedArr[L] == num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）在一个有序数组中，找-gt-x3D-某个数最左侧的位置"><a href="#2）在一个有序数组中，找-gt-x3D-某个数最左侧的位置" class="headerlink" title="2）在一个有序数组中，找 &gt;&#x3D; 某个数最左侧的位置"></a>2）在一个有序数组中，找 &gt;&#x3D; 某个数最左侧的位置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在arr上，找满足&gt;=value的最左位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nearestIndex</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">index = mid;</span><br><span class="line">R = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">L = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）局部最小值问题"><a href="#3）局部最小值问题" class="headerlink" title="3）局部最小值问题"></a>3）局部最小值问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到一个局部最小值就返回，会优先找到左边的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLessIndex</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// no exist</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr.length == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[arr.length - <span class="number">1</span>] &lt; arr[arr.length - <span class="number">2</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> arr.length - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//left == right 此时的left 就是下一次的mid</span></span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、拓展-异或运算"><a href="#二、拓展-异或运算" class="headerlink" title="二、拓展 - 异或运算"></a>二、拓展 - 异或运算</h2><h3 id="异或运算的性质与扩展"><a href="#异或运算的性质与扩展" class="headerlink" title="异或运算的性质与扩展"></a>异或运算的性质与扩展</h3><blockquote><p>0^N &#x3D;&#x3D; N N^N &#x3D;&#x3D; 0<br>异或运算满足交换律和结合率<br>不用额外变量交换两个数<br><strong>一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数</strong><br><strong>一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找一个出现了奇数次的数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printOddTimesNum1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">eO</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> cur : arr) &#123;</span><br><span class="line">eO ^= cur;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(eO);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找两个出现了奇数次的数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printOddTimesNum2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">eO</span> <span class="operator">=</span> <span class="number">0</span>, eOhasOne = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> curNum : arr) &#123;</span><br><span class="line">eO ^= curNum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">rightOne</span> <span class="operator">=</span> eO &amp; (~eO + <span class="number">1</span>);<span class="comment">//提取最右边的1出来</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> cur : arr) &#123;</span><br><span class="line">            <span class="comment">//当这个数的最右边一位1 与rightOne 相同时，才将它异或进去</span></span><br><span class="line"><span class="keyword">if</span> ((cur &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">eOhasOne ^= cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(eOhasOne + <span class="string">&quot; &quot;</span> + (eO ^ eOhasOne));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="master-公式"><a href="#master-公式" class="headerlink" title="master 公式"></a>master 公式</h3><blockquote><p>Master 公式用来较为简便地评估递归算法的时间复杂度</p></blockquote><p><strong>T(N) &#x3D; a*T(N&#x2F;b) + O(N^d)</strong></p><p>log (b,a) &gt; d -&gt; 复杂度为 O (N^log (b,a))<br>log (b,a) &#x3D; d -&gt; 复杂度为 O (N^d * logN)<br>log (b,a) &lt; d -&gt; 复杂度为 O (N^d)</p><blockquote><p>其中</p><p>a：生成的子问题数（比如二叉树的递归遍历就是 a &#x3D; 2)<br>b：表示每次递归是母问题的 1&#x2F;b 的数据规模<br>N：母问题的数据规模<br>d：额外操作的次数</p></blockquote><p>参考：</p><p>【1】<a href="https://blog.csdn.net/qq_53098203/article/details/120896749">左神算法 - 基础 01 - 认识复杂度和简单排序算法</a></p><p>【2】[数据结构与算法中的 Master 公式](</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
