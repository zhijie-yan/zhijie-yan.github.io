<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis详解（三）redis场景与实战</title>
      <link href="/2023/04/06/redis%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/04/06/redis%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、场景问题"><a href="#一、场景问题" class="headerlink" title="一、场景问题"></a>一、场景问题</h3><h4 id="1-数据丢失场景"><a href="#1-数据丢失场景" class="headerlink" title="1.数据丢失场景"></a>1.数据丢失场景</h4><p>持久化数据丢失：</p><ul><li>RDB采用定时备份，有可能丢失间隔区间内的数据</li><li>AOF使用追加，也有可能丢失1s的数据</li></ul><p>主从切换：主从切换是异步的，必定会导致数据丢失</p><p>脑裂问题：出现多个master，网络恢复时丢失一些master上的数据</p><h4 id="2-跟数据库数据一致性问题"><a href="#2-跟数据库数据一致性问题" class="headerlink" title="2.跟数据库数据一致性问题"></a>2.跟数据库数据一致性问题</h4><p><strong>缓存一致性问题</strong>：mysql数据变更，如何保证redis的数据一致性呢？</p><p>常见的答案是<strong>延时双删</strong>，即先删redis，再该数据库，然后间隔一定时间再删redis</p><p>防止修改数据期间从redis读到不一致数据</p><p>但是实际上，这个间隔时间如何确定？工作中也基本上没有人用延时双删，因为redis本来就不是一个保证强一致性的数据库，它的优点在于快</p><p>所以最常见的方式，就是直接把redis的数据删除即可，下次查询数据库时再放进去就行了</p><p>常见数据一致性解决方案：</p><ul><li>加锁：牺牲性能，不建议使用</li><li>延时双删：间隔时间不好确定，不建议使用</li><li>最终一致性方案<ul><li>给缓存设置过期时间，允许一部分时间内的数据不一致</li><li>canal监听，在数据变更后同步修改redis数据</li></ul></li></ul><h4 id="3-缓存穿透、击穿、雪崩"><a href="#3-缓存穿透、击穿、雪崩" class="headerlink" title="3.缓存穿透、击穿、雪崩"></a>3.缓存穿透、击穿、雪崩</h4><h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h5><p>定义：查询的key，redis里面没有，db里面也没有</p><p>解决方案：</p><ul><li>封禁ip：如果某ip大量请求不存在的key，直接把这个ip干掉</li><li>布隆过滤器：不存在的一定无法经过布隆过滤器</li></ul><h5 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h5><p>定义：某热点key突然失效，全部请求都打到了db</p><p>解决方案：加互斥锁，不影响正常访问，但是过期后会加锁，防止大量请求到db</p><h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><p>定义：大量热点key同时失效</p><p>解决方案：</p><ul><li>保证redis高可用：防止出现redis挂了导致的缓存雪崩</li><li>设置不同的过期时间</li><li>加互斥锁：很少这么干</li></ul><blockquote><p>但是实际上，现在mysql也都是集群部署，崩不了</p></blockquote><h4 id="4-慢查询、阻塞和bigkey"><a href="#4-慢查询、阻塞和bigkey" class="headerlink" title="4.慢查询、阻塞和bigkey"></a>4.慢查询、阻塞和bigkey</h4><h5 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h5><p>所谓慢查询，就是很慢的查询-_-#</p><p>如何找到？</p><p>在默认配置中，超过10ms的查询就是慢查询（不包含网络时间）</p><p>会保存在慢查询日志当中，也可以通过监控工具进行监控，报警</p><p>如何解决？</p><p>拆分数据</p><h5 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h5><p>通常是指Redis服务器无法立即响应客户端请求的情况</p><p>可以通过业务日志，监控命令来判断阻塞原因</p><ul><li>外部原因：网络阻塞，cpu被占用</li><li>内部原因：<ul><li>指令查询耗时</li><li>数据结构设置不合理，导致查询过久</li><li>fork子线程在进行aof刷盘</li></ul></li></ul><h5 id="bigKey"><a href="#bigKey" class="headerlink" title="bigKey"></a>bigKey</h5><p>指一个key对应的value过大</p><p>可以采用拆分，压缩，分片等方式解决</p><ul><li>拆分：比如hash类型，可以将里面的键值对多拆分拆分，变成小一点的结构</li><li>压缩：采用一定的压缩算法，将数据规模变小，提高存储效率</li><li>分片：想办法把数据映射到不同哈希槽上，对key拆分，别都放到一起</li></ul><h3 id="二、实战"><a href="#二、实战" class="headerlink" title="二、实战"></a>二、实战</h3><h4 id="1-客户端选择"><a href="#1-客户端选择" class="headerlink" title="1.客户端选择"></a>1.客户端选择</h4><p>Jedis</p><ul><li>简单，使用较多</li><li>非线程安全</li><li>支持多种模式</li></ul><p>Lettuce</p><ul><li>线程安全</li><li>支持同步、异步</li><li>支持读写分离</li><li>支持多种模式</li></ul><p>Redission</p><ul><li>支持分布式锁</li><li>支持分布式容器等高级功能</li></ul><h4 id="2-实战之授权"><a href="#2-实战之授权" class="headerlink" title="2.实战之授权"></a>2.实战之授权</h4><p>存储分布式session</p><h4 id="3-实战之用户状态保存"><a href="#3-实战之用户状态保存" class="headerlink" title="3.实战之用户状态保存"></a>3.实战之用户状态保存</h4><p>使用bitmap数据结构，记录用户的一些状态，比如是否点过新人引导，是否领过优惠券，使用0&#x2F;1表示即可，状态不可逆，以用户为粒度进行读写</p><p>同时，mysql里面也要有一个bigint的结构与其对应，保证最终一致性</p><h4 id="4-实战之流量限制"><a href="#4-实战之流量限制" class="headerlink" title="4.实战之流量限制"></a>4.实战之流量限制</h4><p>限流基本概念：</p><ul><li>对访问频率的限制</li><li>对连接数的限制</li><li>对客户端的限制</li><li>对速率的限制</li></ul><p>限流常用算法：</p><ul><li>时间窗算法：设定一段时间内的请求次数上限来进行限流的</li><li>漏桶算法：桶大小固定，出桶速度固定，可能会溢出</li><li>令牌桶算法：能在短时间内处理大量请求<ul><li>桶里最多x个令牌，因此同时最多能支持x个取令牌操作</li><li>有一个线程检测桶里令牌是否低于x，是的话就定时产生令牌放桶里</li><li>拿走令牌的线程也可以在任务处理完毕后，在桶里令牌不到x时放回去</li></ul></li></ul><p>在分布式系统中，可以使用令牌桶算法，使用redis搭配搭配网关gateWay，来进行分布式系统限流</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis详解（二）redis高可用方案</title>
      <link href="/2023/04/06/redis%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/04/06/redis%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、持久化"><a href="#一、持久化" class="headerlink" title="一、持久化"></a>一、持久化</h2><p>为什么要持久化？</p><p>由于redis数据都是保存在内存中的，那么如果遇到断电等问题，没有持久化就会导致所有数据都丢失，这是很严重的问题，因此要对redis进行持久化</p><h3 id="1-RDB快照"><a href="#1-RDB快照" class="headerlink" title="1.RDB快照"></a>1.RDB快照</h3><p>RDB 是 Redis 默认的持久化方案。RDB快照(Redis Database)，当满足 一定条件的时候，会把当前内存中的数据写入磁盘，生成一个快照文件</p><p><strong>什么时候触发呢？</strong></p><p>可以分为自动触发与手动触发</p><h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a><strong>自动触发</strong></h4><ul><li>配置触发，即间隔一定时间备份一次</li><li>shutdown正常关闭</li><li>flushall指令触发</li></ul><h4 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a><strong>手动触发</strong></h4><ul><li>save：主线程去进行备份，备份期间不会去处理其他指令，其他指令必须等待</li><li>bgsave：fork一个子线程去进行备份</li></ul><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h4><ul><li>快</li><li>做备份，恢复快，是非常紧凑的文件<ul><li>新起子线程，子线程会将当前Redis的数据写入一个临时文件 </li><li>当临时文件写完成后，会替换旧的RDB文件</li></ul></li><li>主线程指令操作不需要跟磁盘进行任何交互</li></ul><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a><strong>劣势</strong></h4><ul><li>安全性很低，可能会有数据丢失</li><li>fork子线程可能特别耗时，cpu不友好</li></ul><h3 id="2-AOF追加"><a href="#2-AOF追加" class="headerlink" title="2.AOF追加"></a>2.AOF追加</h3><p>由于RDB的数据可靠性非常低，所以Redis又提供了另外一种持久化方案: Append Only File 简称:AOF，默认关闭，可以配置开启</p><p>那么问题来了，AOF是采用追加的方式实现的，那么它如何追加呢？每条命令都追加吗？</p><p>事实上，AOF有三种磁盘交互策略</p><ul><li>appendfsync always：表示每次写入都要执行fsync（刷新）函数，性能非常慢，但是非常安全</li><li>appendfsync everysec：表示每秒执行一次fsync函数，突然断电可能丢失1s数据</li><li>appendfsync no：由操作系统保证数据同步到磁盘，速度最快</li></ul><h4 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a><strong>重写机制</strong></h4><p>为何要进行重写呢？</p><p>由于AOF是追加的形式，所以文件会越来越大，越大的话，数据加载越慢。 所以需要对AOF文件进行重写</p><p>重写流程有两个版本，这里仅介绍redis7.0之前的</p><ul><li>Redis fork一个子进程，在一个临时文件中写入新的AOF (当前内存的数据生成的新的AOF)</li><li>那么在写入新的AOF的时候，主进程还会有指令进入，那么主进程会在内存缓存区中累计新的指令 (但是同时也会写在旧的AOF文件中，就算重写失败，也不会导致AOF损坏或者数据丢失)</li><li>如果子进程重写完成，父进程会收到完成信号，并且把内存缓存中的指令追加到新的AOF文件中</li><li>替换旧的AOF文件 ，并且将新的指令附加到重写好的AOF文件中。</li></ul><p>但是这种仅使用AOF重写方式存在一个问题，那就是如果当前数据非常大，那么执行效果会很慢，因此可以采用RDB的方式生成新的AOF文件，再用AOF去新文件末尾追加后续指令</p><blockquote><p>何时重写？</p><p>可以配置一个百分比与阈值共同控制</p></blockquote><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul><li>安全性高，就算默认的持久化同步机制，也最多只会导致1s丢失 </li><li>AOF由于某些原因，比如磁盘满了等导致追加失败，也能通过redis-check-aof 工具来修复</li><li>格式都是追加的日志，所以可读性更高</li></ul><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul><li>数据集一般比RDB大</li><li>持久化跟数据加载比RDB更慢</li><li>在7.0之前，重写的时候，因为重写的时候，新的指令会缓存在内存 区，所以会导致大量的内存使用</li><li>并且重写期间，会跟磁盘进行2次IO，一个是写入老的AOF文件，一个 是写入新的AOF文件</li></ul><h2 id="二、集群"><a href="#二、集群" class="headerlink" title="二、集群"></a>二、集群</h2><h3 id="1-Redis主从"><a href="#1-Redis主从" class="headerlink" title="1.Redis主从"></a>1.Redis主从</h3><p><strong>为什么要有主从?</strong></p><ul><li>故障恢复：主挂了或者数据丢失了，从还会有数据冗余</li><li>负载均衡，流量分发，可以主写，从库读，减少单实例的读写压力</li><li>高可用：集群等，都是基于主从去实现的</li></ul><h4 id="1）主从数据同步"><a href="#1）主从数据同步" class="headerlink" title="1）主从数据同步"></a>1）主从数据同步</h4><ul><li>相互之间会建立连接 保存地址 端口等信息</li><li>加入从第一次成为slave，发送数据同步指令</li><li>master收到后比较repid（判断是否同步过）</li><li>不一致或为空，触发全量同步<ul><li>master使用bgsave生成rdb文件，然后把rdb发给slave，同时把自己repid&#x2F;offert给slave</li><li>生成新的rdb期间，会有新的指令，把这些指令放到一个内存</li><li>3.rdb同步完了之后，会把这些新指令也同步过去</li></ul></li><li>假如只是中间断开过，则重新同步，使用增量同步<ul><li>master发现repid符合，则去找这个slave还有哪些没有同步</li><li>offert上次偏移量即可找到上次同步位置</li><li>回去积压缓存那里去找是否有同步记录，找不到的话就全量同步</li></ul></li></ul><blockquote><p>发生主从切换，一定会有数据丢失<br>因为同步是异步的，切换主从的话主数据一定会丢失</p></blockquote><h3 id="2-Redis-sentinel哨兵"><a href="#2-Redis-sentinel哨兵" class="headerlink" title="2.Redis sentinel哨兵"></a>2.Redis sentinel哨兵</h3><p>主从虽然解决了比如负载、数据备份等问题</p><p>但是当master挂了之后，slave是不会直接升级为主，必须手动把slave升级为主</p><p>master挂了后，slave只是状态变更为down，会导致所有服务不可用</p><p>因此出现了哨兵模式来解决这个问题，当一个master挂了之后，能够通过哨兵自动选择出来一个master</p><blockquote><p>官网上哨兵介绍</p><p>Redis sentinel在<strong>不适用Cluster集群</strong>的时候，为Redis提供了高可用性。</p><p>并且提供了监测、通知、自动故障转移、配置提供等功能。</p><p><strong>监控</strong>:能够监控我的Redis各实例是否正常工作</p><p><strong>通知</strong>:如果Redis的实例出现问题，能够通知给其他实例以及sentinel</p><p><strong>自动故障转移</strong>:当我的master宕机，slave可以自动升级为master</p><p><strong>配置提供</strong>:sentinel可以提供Redis的master实例地址，那么客户端只需要 跟sentinel进行连接，master挂了后会提供新的master</p></blockquote><p>需要注意，哨兵机器需要单独设置，哨兵需要独立的服务器来运行，它们不应该与Redis实例运行在同一台机器上，这是为了保证当机器发生故障时，哨兵仍然能够继续运行并监控Redis集群的状态</p><p>哨兵能够实现自动故障转移，主要包括<strong>发现故障</strong>与<strong>故障转移</strong>两个步骤</p><h4 id="1）发现故障"><a href="#1）发现故障" class="headerlink" title="1）发现故障"></a>1）发现故障</h4><ul><li>某哨兵在一定时间内收不到master的回应，该哨兵认为主节点挂了，因此会标记一个主观下线</li><li>询问其他的sentinel，去跟master ping，如果超过quornum（配置的参数）的sentinel认为master挂了，那么就标记为ODwon（客观下线）</li></ul><h4 id="2）故障转移"><a href="#2）故障转移" class="headerlink" title="2）故障转移"></a>2）故障转移</h4><p>客观下线状态，选举一个sentinel去触发故障转移，此时其他sentibel不能触发故障转移</p><ul><li>如果配置的quornum小于等于一半，那么必须超过半数的sentinel授权，才能成为master</li><li>如果quornum超过一半，那么就要quornum数量的授权</li></ul><p>如何选举哪一个slaver为master呢？</p><ul><li>断开时间：超过一定时间失去资格</li><li>优先级slaver_priority：越小优先级越高，但是到0失去资格</li><li>根据slave赋值的偏移量offerset，数据最新的直接升级为master</li><li>RunID—实例启动时配置的唯一id</li></ul><h4 id="3）数据一致性问题"><a href="#3）数据一致性问题" class="headerlink" title="3）数据一致性问题"></a>3）数据一致性问题</h4><p>官方建议最少配置3个sentinel</p><p>原因：</p><p>如果只有1个sentinel实例，则这个实例挂了就不能保证sentinel的高可用性</p><p>如果只有2个sentinel实例，且只有一主一从，quorum&#x3D;1，那么因为网络问题，哨兵和mastre之间断网了，在这期间slave可能被选为master，从而出现两个master与客户端通信，当网络恢复时，一个master会被干掉，恢复成slave，这时它作为master接收的数据都会丢失</p><p>这也就是所谓的<strong>脑裂问题</strong></p><p><strong>指的是当主节点和哨兵节点之间网络分区后，可能导致多个哨兵节点同时将从节点提升为主节点，从而导致主从数据不一致的问题</strong></p><p>脑裂问题解决方案：</p><ul><li>min-replicas-to-write 1：配置至少有 1 个从节点，才能执行写操作。这样可以确保主节点挂掉时，还有至少一个从节点可以接替成为新的主节点，并保证集群数据不会丢失。</li><li>min-replicas-max-lag 10：配置从节点和主节点的数据同步最大延迟时间为 10 秒。如果有某个从节点的数据同步延迟超过了 10 秒，那么就不再允许该从节点成为新的主节点，以防止数据不一致的情况发生。</li></ul><p>这两个配置可以结合使用，保证 Redis 集群在发生主节点故障时，可以自动选举出新的主节点，并且选举出的节点能够保证数据一致性</p><h3 id="3-集群-cluster"><a href="#3-集群-cluster" class="headerlink" title="3.集群 cluster"></a>3.集群 cluster</h3><p>sentinel提供了比如监控、自动故障转移、客户端配置等高可用的 方案，但是没有分片功能。<br>何为分片:就是希望把数据分布到不同的节点。这样如果某些节点异常，其他数据能正常提供服务，跟微服务的思想很相似</p><blockquote><p>官网上介绍cluster提供的功能</p><p>1.多个节点之间的数据拆分，也就是数据分片</p><p>2.当某些节点遇到故障的时候，其他节点还能继续服务</p></blockquote><h4 id="1）hash-solt-虚拟槽"><a href="#1）hash-solt-虚拟槽" class="headerlink" title="1）hash solt 虚拟槽"></a>1）hash solt 虚拟槽</h4><p>如何分片？</p><p>分片就是把不同的数据放到不同的位置，相当于分表，不同的数据放到不同的表里</p><p>在Redis里面，采用的是虚拟槽的概念，就是在redis cluster里面有16384个虚拟节点，存储数据时就往这些节点里面映射，而这些节点由不同的机器负责，由此也就实现了数据的分片存储；后续这些数据跟槽的关系也不会变更，只会随着槽的负责机器不同而到不同的机器上</p><p>那么如何映射到虚拟槽呢？</p><p>计算公式：slot &#x3D; CRC16(key) &amp; 16383</p><blockquote><p>如果想把相关key放入一个虚拟槽,也就是一个实例节点，可以采用{},那么就只会根据{}里面的内容计算hash槽! 比如:<br>zhnagsan{18} 跟 lisi{18} 就会在一个虚拟槽</p></blockquote><h4 id="2）部署"><a href="#2）部署" class="headerlink" title="2）部署"></a>2）部署</h4><p>cluster模式下，最少三主三从</p><p>如何把key放到真实节点呢？可以通过命令为不同的主机分配不同范围的槽</p><p>比如三主三从时，可以让master按照如下范围负责虚拟槽</p><p>master1 0-5460虚拟槽<br>master2 5461-10922虚拟槽<br>master3 10923-16383虚拟槽</p><p>这样，每次扩容与缩容，只要改变节点跟虚拟槽之间的关系即可</p><h4 id="3）为什么槽数量是16384？"><a href="#3）为什么槽数量是16384？" class="headerlink" title="3）为什么槽数量是16384？"></a>3）为什么槽数量是16384？</h4><ul><li>16384个槽已经能够满足大多数使用情况了</li><li>16384个槽正好使用2k空间能够表示，再大的话就可能会带来资源的浪费</li></ul><blockquote><p>实际上，有参数可以修改这个值，但是一般不建议修改</p></blockquote><p>扩展：</p><p>由于虚拟槽机制，可以做数据的冷热分离，把一些热数据放到相邻的槽上，从而使他们位于固定的几台机器上，可以特意开几台性能好的机器专门处理这些热数据</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（七）ThreadPoolExecutor</title>
      <link href="/2023/04/05/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2023/04/05/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><h4 id="1-思考"><a href="#1-思考" class="headerlink" title="1.思考"></a>1.思考</h4><p>先来考虑下，假如没有线程池，每次使用多线程都要创建并销毁，可能存在什么问题？</p><ol><li><strong>资源消耗：</strong>线程的创建和销毁是一项昂贵的操作，会消耗大量的 CPU 和内存资源。频繁地创建和销毁线程可能会导致资源的浪费和系统性能的下降。</li><li><strong>稳定性：</strong>在创建和销毁线程的过程中，线程状态的切换可能会导致程序不稳定。例如，在线程销毁之前，可能存在一段时间的竞态条件，导致程序出现不一致的行为。</li><li><strong>并发性能：</strong>在高并发场景下，频繁地创建和销毁线程会导致线程数的不稳定，进而影响程序的并发性能。过多的线程数会导致 CPU 和内存的浪费，而过少的线程数则会导致任务执行的延迟和并发性能的下降。</li></ol><p>因此，使用线程池可以避免频繁地创建和销毁线程，从而节省资源、提高程序的稳定性和并发性能。</p><h4 id="2-设计"><a href="#2-设计" class="headerlink" title="2.设计"></a>2.设计</h4><p>既然想要利用池化技术解决线程频繁创建和销毁的问题，那么该如何设计呢？</p><p><strong>如何实现线程的复用？</strong></p><p>能实现线程复用的唯一方式，就是让线程不结束</p><p><strong>那么如何让线程能够执行新的任务呢？</strong></p><p>共享内存—&gt;List.add()</p><p><strong>那么线程无任务时，就一直空转吗？</strong></p><p>有任务来时，执行任务；无任务时，阻塞</p><p><strong>结论：</strong></p><p>使用阻塞队列的方式，来实现线程池技术，从而完成线程的复用</p><h4 id="3-执行流程"><a href="#3-执行流程" class="headerlink" title="3.执行流程"></a>3.执行流程</h4><blockquote><p>具体设计流程参考下图</p></blockquote><p><img src="https://static-2w2.pages.dev/post/threadPoolDesign.png" alt="image-20230406143137653"></p><h3 id="二、源码"><a href="#二、源码" class="headerlink" title="二、源码"></a>二、源码</h3><blockquote><p>线程池中的核心线程是延迟初始化的</p></blockquote><ul><li>先初始化核心线程。</li><li>调用阻塞队列的方法，把task存进去。(offer() -&gt; true&#x2F;false)<ul><li>如果true ，说明当前的请求量不大， 核心线程就可以搞定。 </li><li>false，增加工作线程(非核心线程)<ul><li>如果添加失败，说明当前的工作线程数量达到了最大的线程数，直接调用拒绝策略。</li></ul></li></ul></li></ul><h4 id="1-构造器"><a href="#1-构造器" class="headerlink" title="1.构造器"></a>1.构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, // 核心线程数</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,// 最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,// 超时销毁时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit,// 时间单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,// 阻塞队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,// 线程工厂</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;<span class="comment">// 拒绝策略</span></span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池创建时，这七大参数是必不可少的，但是像线程工厂和拒绝策略可不填，有默认值可用，下面详解这七个参数</p><ul><li><p><strong>corePoolSize：</strong>核心线程数，线程池中常态化保持的线程数量</p></li><li><p><strong>maximumPoolSize：</strong>最大线程数，当核心线程与阻塞队列都满了，再有新的任务进来，而还没达到最大线程数，则会创建新的线程处理任务</p></li><li><p><strong>keepAliveTime：</strong>超时销毁时间，超过核心线程数量的线程，休息这个时间后还没有任务处理，就会自动关闭；</p></li><li><p><strong>unit：</strong>上一个参数的时间单位</p></li><li><p><strong>workQueue：</strong>阻塞队列，用于保存任务，详情可参考<a href="https://yzj.life/2023/03/28/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/#%E4%B8%89%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97">阻塞队列</a></p></li><li><p><strong>threadFactory：</strong>线程工程，用于生产线程，可采用默认值</p></li><li><p><strong>handler：</strong>拒绝策略</p><ul><li>AbortPolicy（默认策略）：当任务添加到线程池中被拒绝时，将抛出RejectedExecutionException异常。</li><li>CallerRunsPolicy：当任务添加到线程池中被拒绝时，将该任务添加到当前线程执行。</li><li>DiscardPolicy：当任务添加到线程池中被拒绝时，将直接丢弃该任务，不做任何处理。</li><li>DiscardOldestPolicy：当任务添加到线程池中被拒绝时，将丢弃最早加入线程池的任务，并尝试重新提交当前任务。</li></ul><p>除了上述四种策略之外，也可以通过实现RejectedExecutionHandler接口，自定义拒绝策略。</p></li></ul><h4 id="2-execute"><a href="#2-execute" class="headerlink" title="2.execute"></a>2.execute</h4><ul><li>如果当前运行的线程数少于corePoolSize，尝试使用给定的命令作为新线程的第一个任务来启动一个新线程。addWorker方法会原子地检查runState和workerCount，因此可以防止出现错误警报，以避免在不需要添加线程时添加线程并返回false</li><li>如果可以成功将任务加入到队列中，那么我们仍然需要双重检查是否应该添加一个线程（因为现有线程在上次检查后已经死亡），或者在进入此方法后池已关闭。因此，我们重新检查状态，如果需要，在停止时回滚排队操作，或者在没有线程时启动一个新线程</li><li>如果无法将任务加入队列，则尝试添加一个新线程。如果失败，我们知道线程池已关闭或已饱和，因此拒绝该任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">  <span class="comment">// 判断当前工作线程数是否小于核心线程数(延迟初始化)</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">      <span class="comment">// 添加工作线程的同时，执行command</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// workQueue.offer 添加到阻塞队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 如果阻塞队列满了，则添加工作线程(扩容的线程)</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">      <span class="comment">// 启用拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-addWorker"><a href="#3-addWorker" class="headerlink" title="3.addWorker"></a>3.addWorker</h4><p>尝试向线程池中添加一个新的工作线程</p><ul><li>如果线程池中当前的工作线程数小于corePoolSize，则会尝试创建一个新的工作线程，并将给定的任务作为该线程的第一个任务。这个操作是原子的，即只有一个线程能够进行，避免了竞争条件。</li><li>如果任务不能立即分配给线程执行，会将任务放入工作队列中。</li><li>如果工作队列已满，将尝试创建新的工作线程来处理任务。</li><li>如果无法创建新的工作线程，则会根据设置的拒绝策略来处理该任务。默认的拒绝策略是抛出RejectedExecutionException异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    retry:</span><br><span class="line">  <span class="comment">// 通过原子操作来增加线程数量 一般cas操作都是配合死循环使用</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="comment">// 增加线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 初始化工作线程</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 构建一个工作线程，此时线程还未启动</span></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                  <span class="comment">// 线程构建成功，加入容器中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                  <span class="comment">// 添加线程成功</span></span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">              <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里能看到，新创建的线程进入了workers，这个容器是何方神圣呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br></pre></td></tr></table></figure><p>定义如上，用到了一个内部类Worker，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    Runnable firstTask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line">  ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，这是一个对工作线程进行包装的类，那么自然，workers中存储的也就都是创建好的线程了</p><h4 id="4-run"><a href="#4-run" class="headerlink" title="4.run"></a>4.run</h4><p>在上面的Work类中，存在run方法，即线程要执行的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    runWorker(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上执行任务的方法，具体实现步骤如下</p><ul><li>获取当前 <code>Worker</code> 线程对象所持有的 <code>Thread</code> 对象，这里的 <code>Thread</code> 对象在 <code>Worker</code> 对象的构造函数中被创建。</li><li>循环执行以下步骤：<ul><li>如果 <code>Worker</code> 对象的 <code>firstTask</code> 不为 null，说明这个线程还没有开始执行任务，那么就执行 <code>firstTask</code>，并将 <code>firstTask</code> 置为 null。</li><li>如果 <code>Worker</code> 对象的 <code>firstTask</code> 为 null，那么就从任务队列中取出一个任务进行执行。这里的任务队列就是 <code>ThreadPoolExecutor</code> 的 <code>BlockingQueue</code> 对象，它用于存储还未被执行的任务。如果队列为空，则调用 <code>getTask()</code> 方法阻塞等待队列中有新的任务。</li><li>如果 <code>getTask()</code> 方法返回 null，说明任务队列已经被关闭，那么就直接跳出循环。</li><li>执行任务。执行任务的过程中，可能会抛出异常，这时需要调用 <code>afterExecute()</code> 方法进行一些清理工作，比如将异常打印出来或者记录日志。</li></ul></li><li>如果循环结束，说明线程要么被要求退出，要么发生了异常，需要将 <code>Worker</code> 线程对象从线程池中移除，同时也要执行一些清理工作，比如中断当前线程、调用 <code>processWorkerExit()</code> 方法等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// while循环保证当前线程不结束. 直到task为null</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 自己实现的互斥锁，利用了AQS框架，为什么这里要使用锁呢？</span></span><br><span class="line">          <span class="comment">// 表示当前线程正在运行一个任务，如果其他地方要shutdown()</span></span><br><span class="line">          <span class="comment">// 你必须要等我执行完成；即保证正常关闭</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();<span class="comment">// 是否应该触发中断</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 空的实现</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-getTask"><a href="#5-getTask" class="headerlink" title="5.getTask"></a>5.getTask</h4><p>用于获取任务队列中的下一个任务</p><p>两个参数：firstTask和core，分别表示线程第一次获取任务时的任务以及线程是否为核心线程</p><p>核心逻辑如下</p><ul><li>如果线程池的状态为STOP，即线程池已关闭并且没有任务等待执行，那么返回null。这个判断是为了确保线程在关闭时能够正确退出。</li><li>如果线程为非核心线程或者线程池中正在运行的线程数大于核心线程数，那么调用workQueue的poll方法从任务队列中获取任务。如果获取到的任务不为null，则直接返回该任务。</li><li>如果线程为核心线程且线程池中正在运行的线程数小于等于核心线程数，则调用workQueue的take方法从任务队列中获取任务。take方法会在任务队列为空时自动阻塞线程，直到队列中有任务或线程池被关闭。如果获取到的任务不为null，则直接返回该任务。</li><li>如果获取到的任务为null，则返回null。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"><span class="comment">// 配合cas自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"><span class="comment">// 如果线程池处在结束状态，直接返回null. 需要清理掉所有的工作线程</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 是否允许超时</span></span><br><span class="line">      <span class="comment">// 如果当前工作线程数量大于核心线程数</span></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">          <span class="comment">// 减少工作线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">// 表示要销毁当前工作线程</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 获取任务过程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">          <span class="comment">// 如果阻塞队列没有任务，当前工作线程会阻塞在这里</span></span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;<span class="comment">// 中断异常</span></span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、线程池参数设置"><a href="#三、线程池参数设置" class="headerlink" title="三、线程池参数设置"></a>三、线程池参数设置</h3><ul><li>IO密集型 CPU 2core+1 </li><li>CPU利用率不高</li><li>CPU密集型 CPU +1 </li><li>CPU利用率很高，会增加上下文切换.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis详解（一）redis基础</title>
      <link href="/2023/04/04/redis%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/04/04/redis%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p><strong>1.为何要有redis？只用mysql不行吗？</strong></p><p>因为mysql为了保证数据安全性，所以每次交互都要落盘，即与磁盘进行交互</p><p>众所周知，磁盘访问的速度是很慢的，所以mysql这种方式极大的限制了高并发与高速访问的速度</p><p><strong>2.那么redis为什么能做到那么快呢？</strong><br>因为mysql是与磁盘进行交互所以比较慢，所以redis就将操作都在内存中进行，所以它是一个内存型数据库，由此使得redis速度很快，此外还有一些其他措施保证redis速度，如下</p><ul><li>它是一个内存型数据库：所以访问不需要与磁盘进行交互，内存会快很多</li><li>它使用单线程进行操作：减少了上下文切换等消耗</li><li>它使用了IO多路复用技术：极大的提升了单线程的速度</li><li>它本身是Key-value结构：类似hashmap，访问速度接近O(1)</li><li>底层数据结构：跳表，sds等采用了空间换时间的思路</li></ul><p><strong>3.CAP理论</strong></p><p>CAP 理论是指在分布式系统中，不可能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）这三个特性，最多只能同时满足其中两个</p><p>redis本质上是一个AP模型，即更加重视可用性和分区容错性，对于一致性要求并不是那么高，因此它的速度在一定程度上也是牺牲一致性来换取的</p><blockquote><p>由此也可以得知，对于数据一致性要求高的场景，就尽量不要选用redis，因为它的优点是快，并不追求数据一致性，如果放到强一致性的场景，并不适合使用redis</p></blockquote><h3 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h3><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><h5 id="1-dict-字典"><a href="#1-dict-字典" class="headerlink" title="1.dict 字典"></a>1.dict 字典</h5><p>redis底层数据结构之一，两种基础数据类型hash和zset底层都有采用这种数据结构</p><p>首先看下server.h中，最外层结构redisDb的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                     <span class="comment">// 数据库键值对存储的哈希表</span></span><br><span class="line">    dict *expires;                  <span class="comment">// 记录键的过期时间的哈希表</span></span><br><span class="line">    dict *blocking_keys;            <span class="comment">// 阻塞客户端的键的哈希表</span></span><br><span class="line">    dict *ready_keys;               <span class="comment">// 可读键的哈希表</span></span><br><span class="line">    dict *watched_keys;             <span class="comment">// 被监视的键的哈希表</span></span><br><span class="line">    <span class="type">int</span> id;                         <span class="comment">// 数据库 ID</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> avg_ttl;              <span class="comment">// 平均 TTL</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> expires_cursor;  <span class="comment">// 上一次检查键的过期时间的游标</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;             <span class="comment">// 要在之后进行内存碎片整理的键列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisMemOverhead</span> *<span class="title">mem_overhead</span>;</span>  <span class="comment">// 内存使用情况的统计信息</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>由上面代码，可见其大量用到了dict的数据结构，它是存储在dict.h文件中定义的数据结果，称为字典，下面是字典数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;     <span class="comment">// 哈希表类型，定义了一组用于操作哈希表的函数指针</span></span><br><span class="line">    <span class="type">void</span> *privdata;     <span class="comment">// 私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];       <span class="comment">// 两个哈希表，通常只使用其中一个，另一个用于重建或扩展</span></span><br><span class="line">    <span class="type">long</span> rehashidx;     <span class="comment">// 哈希表扩展或重建时，rehashidx 表示已经处理的桶的数量</span></span><br><span class="line">    <span class="type">int</span> iterators;      <span class="comment">// 迭代器的数量</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>这里用到了dictht结构的哈希表，它也在dict.h文件中定义，那它的结构是怎样的呢？如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;              <span class="comment">// 哈希表数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;             <span class="comment">// 哈希表桶数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;         <span class="comment">// 哈希表大小掩码，用于计算哈希值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;             <span class="comment">// 键值对的数量</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>再看一下同样在dict.h文件中定义的dictEntry结构，它是类似hashmap的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;                      <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;                  <span class="comment">// 值</span></span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>         <span class="comment">// 指向下一个哈希表节</span></span><br></pre></td></tr></table></figure><p>redisObject结构如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:<span class="number">4</span>;                <span class="comment">// 类型，占用 4 个比特位</span></span><br><span class="line">    unsigned encoding:<span class="number">4</span>;            <span class="comment">// 编码方式，占用 4 个比特位</span></span><br><span class="line">    unsigned lru:LRU_BITS;          <span class="comment">// LRU 时间，占用 LRU_BITS 个比特位</span></span><br><span class="line">    <span class="type">int</span> refcount;                   <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;                      <span class="comment">// 指向实际值的指针</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>看了那么多数据结构，那么他们的关系是怎样的呢？参考下图</p><p><img src="https://static-2w2.pages.dev/post/dict.jpeg" alt="dict"></p><p>则由上面定义与关系图，可总结字典结构的一些数据结构关系如下：</p><ul><li><code>redisDb</code> 包含了所有 Redis 数据库的状态，每个数据库通过 <code>dict</code> 实现一个键值对的哈希表。</li><li><code>dict</code> 是 Redis 的哈希表实现，内部使用 <code>dictht</code> 结构体实现哈希表，<code>dictEntry</code> 结构体表示哈希表中一个键值对。</li><li><code>redisObject</code> 是 Redis 中非常重要的一个结构体，用于表示 Redis 中的所有数据对象，包括字符串、列表、哈希、集合等等。<code>redisObject</code> 包含了该对象的类型、编码方式、引用计数等信息，以及指向实际值的指针</li></ul><p>h[0]是正常情况下用来存储数据的数据结构，h[1]是扩容时使用的临时空间</p><p>dictEntry构成一个table表存储在h[0]当中，每个位置由链表结构组成</p><p>整体结构类似java集合中的hashMap结构，即数组+链表</p><p>只是要注意，链表的每个节点中存储的value使用redisObject结构，这个结构类型通过type来指明</p><p>链表部分，使用头插法插入新数据，因为redis是单线程操作，所以不怕出现死链情况</p><p>头插就可以免去遍历到链表结尾的过程了</p><h5 id="2-字典扩容"><a href="#2-字典扩容" class="headerlink" title="2.字典扩容"></a>2.字典扩容</h5><p><strong>1）扩容时机</strong></p><p>注意，在上面的dictht结构中</p><p>used参数，用来标识已经使用的桶数量</p><p>size参数，表示已经存储的键值对数量</p><p>因此扩容时机就是依据这两个参数来判断</p><ul><li>无子进程在fork刷盘时，used  &gt;&#x3D; size 的时候 进行扩容</li><li>有子进程在刷盘时，要used  &gt;&#x3D; size * 5</li></ul><p>之所以这样设计，是为了使得资源合理利用</p><p><strong>2）扩容流程</strong></p><p>在早期的redis3.x及以前，扩容数组大小是直接取h[0].size * 2，类似hashMap中的扩容机制</p><p>但是在redis4.0及之后，为了更高效的扩容，采用了渐进式迁移的方式，因此扩容大小也修改成了新数组为ht[0].used * 2向上取2的幂，下面是扩容流程</p><ul><li><strong>判断是否扩容：</strong>当满足我扩容条件，触发扩容时，判断是否在扩容，如果在扩容，或者 扩容的大小跟我现在的ht[0].size一样，这次扩容不做。</li><li><strong>new新数组：</strong>new一个新的dictht，大小为ht[0].used * 2(但是必须向上2的幂，比如6 ，那么大小为8) ，并且ht[1]&#x3D;新创建的dictht。</li><li><strong>渐进式数据迁移：</strong>我们有个更大的table了，但是需要把数据迁移到ht[1].table ，所以将 dict的rehashidx(数据迁移的偏移量)赋值为0 ，代表可以进行数据迁移了，也就是可以rehash了。</li><li><strong>数组指向修改：</strong>等待数据迁移完成，数据不会马上迁移，而是采用渐进式rehash，慢慢的把数据迁移到ht[1]</li><li>当数据迁移完成，ht[0].table&#x3D;ht[1] ，ht[1] .table &#x3D; NULL、ht[1] .size &#x3D; 0、ht[1] .sizemask &#x3D; 0、 ht[1] .used &#x3D; 0;</li><li>把dict的rehashidex&#x3D;-1</li></ul><h5 id="3-渐进式迁移"><a href="#3-渐进式迁移" class="headerlink" title="3.渐进式迁移"></a>3.渐进式迁移</h5><p><strong>思考：</strong>为什么会出现渐进式数据迁移呢？</p><p>假如一次性把数据迁移会很耗时间，会让单条指令等待很久很久，会形成阻塞<br>所以，Redis采用的是渐进式Rehash,所谓渐进式，就是慢慢的，不会一次性把所有数据迁移</p><p>那么，什么时候会触发迁移呢？又是如何迁移的？</p><ul><li>每次进行key的crud操作都会进行一个hash桶的数据迁移</li><li>定时任务，进行部分数据迁移</li></ul><p><strong>1）crud触发迁移</strong></p><p>在源码中，每次增删改都会触发**_dictRehashStep**方法，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个代码在增删改查的方法中都会调用</span></span><br><span class="line"><span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br></pre></td></tr></table></figure><p>_dictRehashStep里面调用了dictRehash</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _dictRehashStep(dict *d)&#123;</span><br><span class="line">  <span class="keyword">if</span>(d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看看dictRehash</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果已经完成了rehash，则直接退出 */</span></span><br><span class="line">        <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 如果有正在进行的 AOF 重写，那么可以在重写过程中进行异步重hash操作，</span></span><br><span class="line"><span class="comment">             * 这样就不会阻塞主线程的操作。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (dictIsRehashing(d))</span><br><span class="line">                <span class="comment">/* 异步地执行字典的 rehash 操作 */</span></span><br><span class="line">                dictRehashMilliseconds(d, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从ht[0]表中选择一个非空的bucket */</span></span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) d-&gt;rehashidx++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 获取bucket中的第一个元素 */</span></span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="type">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 保存下一个元素的地址，防止在rehash的过程中被删除 */</span></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 计算元素在ht[1]表中的索引值 */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 插入元素到ht[1]表的bucket中 */</span></span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 更新ht[0]表的元素数量 */</span></span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 更新ht[1]表的元素数量 */</span></span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 处理下一个元素 */</span></span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 释放这个bucket */</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 更新rehash进度 */</span></span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果已经完成了rehash，则释放ht[0]表，将ht[1]表设置为ht[0]表 */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dictRehash是Redis中扩容哈希表的过程，它会将原哈希表ht[0]中的所有元素重新计算哈希值并移动到新哈希表ht[1]中对应的位置。</p><p>通过这种方式，可以避免扩容过程中的数据丢失，同时也保证了扩容操作的高效性和可扩展性。</p><p>在rehash操作过程中，为了避免耗时过长而造成服务不可用，Redis会将操作分批进行，并交给事件循环处理。</p><p><strong>2）定时处理</strong></p><p>配置文件中可以修改多久执行一次定时任务</p><p>下面是定时任务流程，不再看源码</p><ul><li><strong>选任务：</strong>Redis定时从任务队列中选取一定数量的任务。</li><li><strong>算权重：</strong>对于每个选中的任务，计算出任务的执行权重。</li><li><strong>排序：</strong>根据权重排序，选出最高的一批任务进行执行。</li><li><strong>迁移：</strong>执行任务时将需要迁移的键的数据从源节点迁移到目标节点。</li><li><strong>同步：</strong>迁移过程中会进行增量同步，确保数据的一致性。</li><li><strong>删除：</strong>迁移完成后，源节点上的键会被删除。</li><li>执行完一批任务后，如果任务队列中还有剩余的任务，则返回第二步，继续选取任务进行执行。</li><li>如果任务队列中没有剩余任务，则等待一定时间后再次从任务队列中选取任务。</li></ul><blockquote><p>数据量较大时，hash和set的底层结构都采用的dictht</p></blockquote><h4 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h4><h5 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度，即 SDS 存储的字符串的长度</span></span><br><span class="line">    <span class="comment">// 注意这里的长度是指字符串的长度，不包括结尾的空字符 &#x27;\0&#x27;</span></span><br><span class="line">    <span class="comment">// 实际占用空间为 len + 1</span></span><br><span class="line">    <span class="comment">// 如果 SDS 用于存储二进制数据，那么 len 就表示 buf 中已占用空间的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 中未使用的空间的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存字符串数据的数组</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SDS可以看作是一个可以支持动态扩容的数组结构</p><h5 id="2-扩容与缩容"><a href="#2-扩容与缩容" class="headerlink" title="2.扩容与缩容"></a>2.扩容与缩容</h5><p>SDS使用空间预分配和惰性空间释放的方式，可以避免频繁的内存分配和释放，从而提高了内存的利用率，减少了内存碎片的产生</p><p><strong>1）空间预分配</strong></p><p>在SDS扩容时，预先分配一定量的额外空间，避免频繁的内存重新分配操作</p><p>SDS长度如果小于1MB，预分配跟长度一样的，大于1M,每次跟len的大小多1M</p><p><strong>2）惰性空间释放</strong></p><p>当SDS的长度缩短时，并不立即释放多余的空间，而是等待下一次扩容时再进行释放</p><blockquote><p>五种基本数据类型之中，String在数据量不大时底层采用SDS实现，数据量大了采用字节数组实现</p></blockquote><h4 id="压缩列表-ziplist"><a href="#压缩列表-ziplist" class="headerlink" title="压缩列表 ziplist"></a>压缩列表 ziplist</h4><p><strong>压缩列表（ziplist）</strong>是 Redis 内部使用的一种紧凑的、列表式数据结构。它可以存储多个键值对，每个键值对占用一段连续的内存空间，且支持在列表的两端进行高效的插入和删除操作</p><p>压缩列表会根据存入的数据的不同类型以及不同大小，分配不同大小的空间。所以是为了节省内存而采用的。因为是一块完整的内存空间，当里面的元素发生变更时，会产生连锁更<br>新，严重影响我们的访问性能。所以，只适用于数据量比较小的场景</p><blockquote><p>在redis之中，<strong>list</strong>，<strong>set</strong>和<strong>zset</strong>在数据量不大并满足一定条件时，都会采用压缩链表作为存储结构</p></blockquote><p>例如hash类型，当hash对象同时满足以下两个条件的时候，使用ziplist编码:</p><ul><li>哈希对象保存的键值对数量&lt;512个</li><li>所有的键值对的健和值的字符串长度都&lt;64byte(一个英文字母一个字节)</li></ul><h4 id="快速列表-quicklist"><a href="#快速列表-quicklist" class="headerlink" title="快速列表 quicklist"></a>快速列表 quicklist</h4><p><strong>快速列表（quicklist）</strong>是 Redis 中用于实现列表类型的一种数据结构，它是一种紧凑的、节约内存的、压缩列表的变种。</p><p>快速列表可以保存多个元素，并且每个元素可以是不同的类型。快速列表的结构非常紧凑，可以大大减少存储空间的占用。</p><p>把连锁更新的连续块儿，拆成了node节点，连成链表，即双向链表节点里面会持有一个ziplist；本质上还是用了ziplist；多少个ziplist拼成一个node可在配置文件中配置</p><p>所以一定程度上可解决连锁更新的问题</p><p>整体结构图如下</p><p><img src="https://static-2w2.pages.dev/post/quicklist.png" alt="image-20230406193140330"></p><h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p><strong>跳表（Skip List）</strong>是一种随机化数据结构，可以用来实现有序的数据集合，也可以用来加速查找操作。Redis中的有序集合（Sorted Set）就是通过跳表实现的</p><p>数据结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 跳表节点结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 后退指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">    &#125; level[];</span><br><span class="line">    <span class="comment">// 分值 排序使用</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 最大层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>本质上就是通过设置不同层level来构建不同层级的索引，通过索引加速查询</p><p>图解</p><p><img src="https://static-2w2.pages.dev/post/skiplist.png" alt="image-20230406195140282"></p><h3 id="三、基础数据类型"><a href="#三、基础数据类型" class="headerlink" title="三、基础数据类型"></a>三、基础数据类型</h3><h4 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h4><p><strong>实现：</strong></p><p>在数据量较小时，使用SDS实现</p><p>数据量较大则采用字节数组实现</p><p><strong>适用场景：</strong></p><ul><li>缓存</li><li>全局id</li><li>计数器</li><li>限流<ul><li>用一个值记录访问次数，达到就实现限流方案，也算是计数器变种</li></ul></li></ul><h4 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h4><p><strong>实现：</strong></p><p>数据量较小时，使用ziplist实现</p><p>数据量较大时，使用dictht实现</p><p><strong>适用场景：</strong></p><p>适合存储对象等结构化数据</p><h4 id="3-List"><a href="#3-List" class="headerlink" title="3.List"></a>3.List</h4><p><strong>实现：</strong></p><p>数据量较小时，使用ziplist实现</p><p>数据量较大时，使用quicklist实现</p><p><strong>适用场景：</strong></p><ul><li>分布式队列</li><li>消息队列</li><li>异步消息通知</li></ul><h4 id="4-Set"><a href="#4-Set" class="headerlink" title="4.Set"></a>4.Set</h4><p><strong>实现：</strong></p><p>数据量较小时，使用ziplist实现</p><p>数据量较大时，使用dictht实现，只用key不用value，类似Java的Set</p><p><strong>适用场景：</strong></p><p>适用于存储不重复的数据，如用户ID、IP地址、标签等</p><h4 id="5-ZSet"><a href="#5-ZSet" class="headerlink" title="5.ZSet"></a>5.ZSet</h4><blockquote><p>它的排序是通过每个数据携带一个score来实现的</p></blockquote><p><strong>实现：</strong></p><p>数据量较小时，使用ziplist实现</p><p>数据量较大时，使用skiplist实现</p><p><strong>适用场景：</strong></p><p>适用于按照分数排序的数据，如排行榜、优先级队列等</p><h3 id="四、内存管理"><a href="#四、内存管理" class="headerlink" title="四、内存管理"></a>四、内存管理</h3><p>要区分什么是过期策略，什么是淘汰策略</p><h4 id="1-过期策略"><a href="#1-过期策略" class="headerlink" title="1.过期策略"></a>1.过期策略</h4><p>为了保证内存的利用率，会把过期数据进行删除，删除设置了过期时间，并且到期的数据</p><p><strong>1）惰性过期</strong></p><p>要用的时候，会判断是否过期</p><p>缺点是脏数据一直占据内存，很不友好</p><p><strong>2）定期清理</strong></p><ul><li>去设置了过期时间的key里面拿</li><li>以hash桶为维度，扫到20个为止最多拿400个空桶</li><li>找到里面过期的key，进行删除</li><li>过期的比例超过10，就再次扫描</li><li>最多扫描16次，超次截止</li></ul><blockquote><p>所以，过期策略就是怎样淘汰那些设置了过期时间的过期数据</p></blockquote><p>这里有一个面试题，就是当redis大量key同时过期，会导致什么情况？</p><p>想问的是当大量key同时过期，主线程会一直在扫描这些key进行过期处理，导致主线程阻塞</p><p>解决方案：</p><ul><li>设置过期时间时，将过期时间分散开来</li><li>通过参数配置，减少主线程的扫描时间</li></ul><h4 id="2-淘汰策略"><a href="#2-淘汰策略" class="headerlink" title="2.淘汰策略"></a>2.淘汰策略</h4><p>假设没有设置过期时间，或者设置的过期时间没到期，但是内存满了，内存里面的数据都是有效数据，这时需要有一个淘汰策略</p><p>在redis里面，淘汰策略每次不会删除太多数据，因为这时候的数据并没有过期，所以只会按照一定策略将数据删除的正好能够放进新数据即可</p><p><strong>1）淘汰算法</strong></p><ul><li>默认情况下，不能写，能读，写入报错</li><li>所有数据里使用lru&#x2F;lfu</li><li>过期数据里使用lru&#x2F;lfu</li><li>ttl淘汰快过期数据</li><li>random随机</li></ul><p><strong>2）淘汰池</strong></p><p>如何保证不删太多，删的正好够放入新key呢？<br>就是用淘汰池，从里面删除正好数量的数据，实行末位淘汰机制，从最后面开始删</p><p>redis的淘汰并不是全量范围内淘汰，而是根据批次选择，放入淘汰池最应该被淘汰的key<br>注意，这里并不删除key，只是放里面最应该淘汰的</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶之并发编程（六）ThreadLocal</title>
      <link href="/2023/04/04/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2023/04/04/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p><code>ThreadLocal</code> 是一个 Java 提供的线程局部变量类。它的主要作用是为每个线程提供独立的变量副本，使得每个线程都可以独立地修改自己所拥有的变量副本，而不会影响其他线程的副本</p><h3 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h3><h4 id="1-ThreadLocalMap"><a href="#1-ThreadLocalMap" class="headerlink" title="1.ThreadLocalMap"></a>1.ThreadLocalMap</h4><p>ThreadLocalMap是实现ThreadLocal的根本所在，因此分析ThreadLocalMap的代码即可了解ThreadLocal的实现原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部类Entry，使用弱引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Entry类型的数组，用于存储set进来的value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * table大小标记</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容阈值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容阈值是长度的2/3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setThreshold</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">        threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器 传入第一个key，和对应的值，即第一次set值时才会进行初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器 继承父线程的ThreadlocalMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> &#123;</span><br><span class="line">        Entry[] parentTable = parentMap.table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> parentTable.length;</span><br><span class="line">        setThreshold(len);</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> parentTable[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> key.childValue(e.value);</span><br><span class="line">                    <span class="type">Entry</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">while</span> (table[h] != <span class="literal">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    table[h] = c;</span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-set方法"><a href="#2-set方法" class="headerlink" title="2.set方法"></a>2.set方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法十分简单，直接传进来要存储的value，然后获得ThreadLocalMap放进去即可</p><p>但是要注意，这里调用了两个其他方法，分析下这两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了线程的threadLocals参数，这个参数如何定义的呢？在Thread类里面，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>即<strong>每个线程都有一个ThreadLocalMap类型的threadLocals变量，用于存储threadLocal值</strong></p><p>所以set操作，最后其实都是放在了线程内，即拿到当前操作的线程，获取线程内部的threadlocals对象，将threadlocal作为key，存储进threadlocals里面去</p><p>假如线程的threadlocals对象尚未初始化，则会调用下述方法，来进行ThreadLocalMap对象的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终是使用ThreadLocalMap的构造器创建了对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造器 传入第一个key，和对应的值，即第一次set值时才会进行初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">  <span class="comment">// 使用table存储value数值</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">  <span class="comment">// 根据哈希取模确定位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 创建Entry对象，传入key和value</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 设置阈值</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就是真正的set方法实现的地方，上面调用了map .set(this,value)，最终调用的是ThreadLocalmap内的set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 发生哈希冲突，依次往后遍历，找到第一个不冲突的位置</span></span><br><span class="line">  <span class="comment">// nextIndex保证找到数组最后之后从头开始查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"><span class="comment">// 如果key相等，则覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 如果key过期或者被清理，不存在的话</span></span><br><span class="line">      <span class="comment">// 调用replaceStaleEntry，清理失效的key和对应的value</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">  <span class="comment">//清理</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里介绍下replaceStaleEntry方法，它内部调用了cleanSomeSlots方法，而在cleanSomeSlots内部又调用了expungeStaleEntry方法，那么这三个方法有什么用呢？</p><p>首先说回threadLocalMap中数据的存储方法，是采用Entry数组进行的存储，面对冲突，采用的开放地址法解决冲突，这种方法实现简单，就是不断往后遍历，直到找到空位置，插入即可；但是也存在很大的问题，那就是当一些数据失效时，本来连续的数据就会存在空缺，这时候再进行查询，查到空位就会停止了，因此需要提供一个策略，保证失效数据被清除后能够重整数据位置，而上面的这三个方法，就是实现这个清理过程的</p><p>首先看expungeStaleEntry方法，传入的staleSlot对应位置的key为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key为null，所以value可以直接清除</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash 重新计算位置，调整结构</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// 左边的都是遍历过的，无空缺，所以往后走调整就行</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">      <span class="comment">// key已被清除，对应位置清除</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 比较哈希值是否相同，即判断这个key是否采用过开放地址法解决冲突</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">          <span class="comment">// 使用过开放地址法，因此</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">              <span class="comment">// 原位置清空</span></span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 还是按照开放地址法解决冲突方式，从前往后，找到空位置插入</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 现在的i是从传入位置，第一次往后走到的key为null位置</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面的源码分析，可以知道expungeStaleEntry方法主要是什么作用了，它主要是重新调整key为null后面那些key的位置，保证能够不出现空缺</p><p>由于在table表中，staleSlot位置的key没了，那么之前通过开放地址法经过这个key，往后排的那些key都不能再被查到了，因此需要调整它后面的数据位置，走到第一个key为null的位置即可，具体参考下图</p><p><img src="https://static-2w2.pages.dev/post/threadlocal.png" alt="image-20230406195704176"></p><p>下面再看cleanSomeSlots方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入key为null的位置i，table长度n</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 复制一个table，可以认为局部数组访问速度加快</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 往后走一步</span></span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">      <span class="comment">// 取出e</span></span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">      <span class="comment">// e的key失效</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 调用expungeStaleEntry，调整i之后的数据位置</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>); <span class="comment">// 要遍历一遍调整位置</span></span><br><span class="line">  <span class="comment">// 是否调整过数组，移除过无效value</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以它本质上就是遍历了</p><p>一遍数组，清理并调整了数组中的对象，将无效value清除，重新调整了其他有效数据的位置</p><p>再看replaceStaleEntry方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入key，value和位置i，这里的key==null，要将value存储进来</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;<span class="comment">//使用局部数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">  <span class="comment">// 往前遍历，找到第一个key失效的位置slotToExpunge</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从staleSlot位置往后遍历，如果找到key相等的地方，就覆盖处理</span></span><br><span class="line">  <span class="comment">// 没找到key相等的地方，就找到第一个为null的地方</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">      <span class="comment">// 覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 覆盖后，清除并调整其他元素</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在i位置指向的是null</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入新值</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次清除无效key，调整其他数据</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以replaceStaleEntry方法就是一个把value放入table，并且清理无效key调整元素位置的方法，但是这个方法只在插入时，走到了一个key为null但是有value的地方时才会调用</p><h4 id="3-get方法"><a href="#3-get方法" class="headerlink" title="3.get方法"></a>3.get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 查找</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 还未初始化，进行初始化</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何查询的呢？如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">  <span class="comment">// 直接找到，返回</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 未直接找到，向后找</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向后查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">          <span class="comment">// 找的时候发现失效key，进行清理</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>由上面的分析可知，threadLocal主要依赖ThreadLocalMap来实现各种功能，数据也是包装成Entry类型存储在数组之中</p><p>为了防止内存泄漏，使用threadLocal作为key时使用的是弱引用，所以会存在key失效而value依然存在的情况；尽管get和set方法都能够清除无效的key，但是如果一直没调用也会导致value存储在table中无法清除，造成内存泄漏；因此使用threadLocal之后，要保留调用一下remove方法的习惯</p><p>而ThreadLocalMap采用的是开放地址法解决哈希冲突，若是某位置key失效了，清除后可能会对其他Entry对象的查找造成问题，所以ThreadLocalMap提供了cleanSomeSlots和expungeStaleEntry方法配合使用，可以清除key失效的无效槽，并且能够调整剩余的Entry到正确的位置</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶之并发编程（五）ConcurrentHashMap</title>
      <link href="/2023/04/03/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2023/04/03/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><h4 id="1-随便说说"><a href="#1-随便说说" class="headerlink" title="1.随便说说"></a>1.随便说说</h4><p><code>ConcurrentHashMap</code>在jdk1.8之前，即1.7的时候，采用的是分段锁+数组+链表的技术</p><p>但是这样会存在一些问题，如下：</p><p>1.分段锁存在性能瓶颈，不能支持很高的并发量</p><p>2.链表解决冲突，在极端情况下会导致链表过长查询性能下降</p><p>3.死链问题，头插法可能会导致扩容时出现死链</p><p>因此，本文主要介绍jdk1.8实现的<code>ConcurrentHashMap</code>源码</p><blockquote><p>此外，像哈希表中的get，set，size等方法过于简单，此处不会进行分析</p><p>仅对put，扩容，计算元素数量做详细介绍</p></blockquote><h4 id="2-简单比较"><a href="#2-简单比较" class="headerlink" title="2.简单比较"></a>2.简单比较</h4><p>相比1.7版本的ConcurrentHashMap，1.8版本的ConcurrentHashMap进行了一次很好的优化，主要在以下方面：</p><p><strong>1.分段锁 -&gt; CAS</strong></p><p>不再采用分段锁技术，插入时仅锁某一个槽，并且使用CAS进行元素操作，极大的提升了并发性能</p><p><strong>2.数组+链表 -&gt; 数组+链表+红黑树</strong></p><p>引入红黑树解决哈希冲突，提升了插入和查询效率</p><p><strong>3.扩容机制改进</strong></p><p>由头插法改为尾插法，防止死链问题</p><h3 id="二、参数解析"><a href="#二、参数解析" class="headerlink" title="二、参数解析"></a>二、参数解析</h3><h4 id="1-容量相关参数"><a href="#1-容量相关参数" class="headerlink" title="1.容量相关参数"></a>1.容量相关参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容器最大容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组最大长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认并发级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负载因子，用于计算扩容阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表树化阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树退化为链表阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表树化时，数组最小长度阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure><h4 id="2-扩容相关参数"><a href="#2-扩容相关参数" class="headerlink" title="2.扩容相关参数"></a>2.扩容相关参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示resizeStamp中记录扩容状态和版本号信息所占用的位数</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_BITS</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 能帮助扩容的最大线程数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RESIZERS</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配合resizeStamp记录扩容状态和版本号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_SHIFT</span> <span class="operator">=</span> <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br></pre></td></tr></table></figure><h4 id="3-状态相关参数"><a href="#3-状态相关参数" class="headerlink" title="3.状态相关参数"></a>3.状态相关参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVED</span>     <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 表示该槽位元素已迁移</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEBIN</span>   <span class="operator">=</span> -<span class="number">2</span>; <span class="comment">// 表示该槽位元素已树化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESERVED</span>  <span class="operator">=</span> -<span class="number">3</span>; <span class="comment">// 槽位已占有，但未分配</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_BITS</span> <span class="operator">=</span> <span class="number">0x7fffffff</span>; <span class="comment">// 用于计算元素哈希槽位置</span></span><br></pre></td></tr></table></figure><h4 id="4-Node结构"><a href="#4-Node结构" class="headerlink" title="4.Node结构"></a>4.Node结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存在槽与链表中的节点数据结构</p><h4 id="5-工具方法"><a href="#5-工具方法" class="headerlink" title="5.工具方法"></a>5.工具方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换哈希码，使其尽量均匀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">spread</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">  <span class="comment">// 哈希码右移16位与自己异或散列后，再和HASH_BITS与运算再次散列</span></span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要作用是根据给定的初始容量，计算出一个大于等于该初始容量的2的整数次幂值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个元素大小关系</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span> <span class="comment">// for cast to Comparable</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="literal">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">            ((Comparable)k).compareTo(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-元素操作方法"><a href="#6-元素操作方法" class="headerlink" title="6.元素操作方法"></a>6.元素操作方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数组对应位置头元素</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// casTabAt方法的作用是将数组tab中下标为i的节点的值从c更新为v</span></span><br><span class="line"><span class="comment">// 但只有在节点值为c时才会更新成功</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setTabAt方法的作用是将数组tab中下标为i的节点的值直接设置为v</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-全局变量"><a href="#7-全局变量" class="headerlink" title="7.全局变量"></a>7.全局变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组，即数组+链表/红黑树中的数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时的新数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用cas修改指，统计元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态机，用于标识当前哈希表状态---十分重要</span></span><br><span class="line"><span class="comment">// sizeCtl == -N（N &gt; 1）表示正在扩容，已经有N个线程正在参与扩容操作</span></span><br><span class="line"><span class="comment">// sizeCtl == -1 表示正在初始化</span></span><br><span class="line"><span class="comment">// sizeCtl == 0  表示当前哈希表没有被初始化，初始化后为 初始容量 * 0.75</span></span><br><span class="line"><span class="comment">// sizeCtl &gt; 0 由上面可知，表示扩容阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定了当前线程在进行扩容操作时，需要转移元素的下标位置</span></span><br><span class="line"><span class="comment">// 由spread方法和当前线程的线程ID计算得出的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于标识当前是否有线程正在对ConcurrentHashMap进行扩容操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用该数组记录容器元素数，减少冲突</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><h3 id="三、put操作"><a href="#三、put操作" class="headerlink" title="三、put操作"></a>三、put操作</h3><h4 id="1-源码"><a href="#1-源码" class="headerlink" title="1.源码"></a>1.源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口方法，实际上是调用putVal实现的put操作</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">  <span class="comment">// ConcurrentHashMap不支持key和value为null的情况，防止出现二义性</span></span><br><span class="line">  <span class="comment">// 比如某个key本来不存在，get后是null</span></span><br><span class="line">  <span class="comment">// 但是使用containsKey判断时，另一个线程插入了key为null，就出现二义性</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  <span class="comment">// 获取散列后的hash值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">  <span class="comment">// 统计槽内元素数量，判断要不要树化</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 死循环，不搞进去不结束</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">      <span class="comment">// 发现还未初始化，进行数组初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">      <span class="comment">// 已初始化，对应槽是空的，直接放进去</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 已初始化，对应槽非空，但是正在进行扩容，于是线程也加入扩容大军</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">      <span class="comment">// 已初始化，对应槽非空，也没在扩容，那就进去扩容</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">          <span class="comment">// 锁住这个槽，插入后再释放</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">              <span class="comment">// 确认下f没被其他线程干掉，有点儿双重校验锁的味道～</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                  <span class="comment">// 节点哈希值为负数就不能用链表了，非负才走链表逻辑</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                          <span class="comment">// key相等，覆盖</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                          <span class="comment">// 走到尾部了，尾插放进去</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// 走树的插入逻辑</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 有插入成功元素</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 达到树化的链表阈值</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 统计哈希表元素数量，并且判断是否扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-小结"><a href="#2-小结" class="headerlink" title="2.小结"></a>2.小结</h4><p>通过上述流程，可以总结出来put流程大体如下</p><p>1.判空</p><p>2.启用一个死循环，直到binCount !&#x3D; 0为止，即插入成功</p><p>3.是否初始化，未初始化先调用初始化方法</p><p>4.判断槽是否空，空的直接放进去</p><p>5.槽不空，判断是否在扩容中，扩容中就加入扩容队伍</p><p>6.槽不空，未在扩容，那就锁住这个槽执行插入</p><p>7.判断槽中是链表还是树，执行向下走的流程</p><p>8.key是否存在？存在就覆盖</p><p>9.key不存在，那就插入，链表是尾插</p><p>10.如果key存在采用的覆盖，就返回旧值</p><p>11.元素统计加上</p><h3 id="四、初始化"><a href="#四、初始化" class="headerlink" title="四、初始化"></a>四、初始化</h3><h4 id="1-源码-1"><a href="#1-源码-1" class="headerlink" title="1.源码"></a>1.源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">  <span class="comment">// 未被初始化</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 已有其他线程扩容中，先尝试放弃cpu给其他线程用</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">      <span class="comment">// 尝试将SIZECTL的值从sc修改为-1，一般是0到-1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 再判断一次，tab还没被其他线程初始化，就进行初始化</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="comment">// 初始化后，sizeCtl设置为扩容阈值</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-小结-1"><a href="#2-小结-1" class="headerlink" title="2.小结"></a>2.小结</h4><p>1.启动一个循环进行初始化</p><p>2.使用sizeCtl控制初始化状态</p><p>3.如果sizeCtl为负值，就是在初始化&#x2F;扩容中，当前线程临时歇着就行</p><p>4.sizeCtl大于等于0，尝试将sizeCtl设置为-1，表示初始化中</p><p>5.再判断一次tab是否为空，防止其他线程已经初始化</p><p>6.初始化，将sizeCtl设置为扩容阈值</p><h3 id="三、扩容流程"><a href="#三、扩容流程" class="headerlink" title="三、扩容流程"></a>三、扩容流程</h3><h4 id="1-源码-2"><a href="#1-源码-2" class="headerlink" title="1.源码"></a>1.源码</h4><p>helpTransfer线程入场，加入扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="type">int</span> sc;</span><br><span class="line">  <span class="comment">// tab != null表示旧数组不为null，还在扩容中</span></span><br><span class="line">    <span class="comment">// ForwardingNode类型表示当前节点正在进行扩容操作</span></span><br><span class="line">  <span class="comment">// nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable取出新数组，且不为空</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 扩容戳，高16位表示扩容次数，低16位表示线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line">      <span class="comment">// 新旧数组都对应的上，sizeCtl小于0表示在扩容中</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 判断是否还需要帮助扩容</span></span><br><span class="line">          <span class="comment">// (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs扩容戳变化</span></span><br><span class="line">          <span class="comment">// 表示当前有其他线程正在进行扩容操作，当前线程无法参与扩容操作</span></span><br><span class="line">          <span class="comment">// 表示扩容操作已经有足够的线程参与，当前线程无需参与扩容操作</span></span><br><span class="line">          <span class="comment">// 表示当前线程已经没有数据需要移动</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 使用cas设置sc的值，表示参入扩容线程数+1，注意sc在上一个if中被修改了</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resizeStamp获得扩容戳</p><p><code>n</code> 是当前哈希表的容量，<code>RESIZE_STAMP_BITS</code> 是一个常量，表示扩容戳的长度。该方法首先通过 <code>Integer.numberOfLeadingZeros(n)</code> 方法计算出哈希表容量的前导 0 的个数，然后将该值左移 <code>RESIZE_STAMP_BITS - 1</code> 位，最后通过按位或操作将扩容戳的高位设置为 1。这样就可以得到一个长度为 <code>RESIZE_STAMP_BITS</code> 的扩容戳，其中高位为 1，低位为当前哈希表的容量的前导 0 的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">resizeStamp</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容的灵魂—transfer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">  <span class="comment">// 计算每个线程处理的数据的区间大小，最小是16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">  <span class="comment">// 新数组为空，还未创建，进行初始化，在原来的基础上扩大两倍</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">  <span class="comment">// 用来表示已经迁移完的状态，也就是说</span></span><br><span class="line">  <span class="comment">// 如果某个old数组的节点完成了迁移，则需要更改成fwd</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">      <span class="comment">// 计算负责迁移的区间范围，从后往前数</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 假设数组长度是32</span></span><br><span class="line"><span class="comment">// 第一次 [16(nextBound),31(i)] </span></span><br><span class="line">          <span class="comment">// 第二次 [0,15]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 扩容是否结束</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="type">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="literal">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 得到数组下标为31的位置的值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>) <span class="comment">// 说明当前数组位置为空</span></span><br><span class="line">          <span class="comment">// 直接改成fwd -&gt; 表示迁移完成</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="literal">null</span>, fwd); </span><br><span class="line">      <span class="comment">// 判断是否已经被处理过了，如果是，则进入下一次区间遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 加锁-&gt;针对当前要去迁移的节点</span></span><br><span class="line">          <span class="comment">// 保证迁移过程中，其他线程调用put()方法时，必须要等待</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                  <span class="comment">// 链表与树分开处理</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                      <span class="comment">// 高低位分开迁移</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        <span class="comment">// 高低位分开迁移</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-小结-2"><a href="#2-小结-2" class="headerlink" title="2.小结"></a>2.小结</h4><h5 id="2-1首先解决一些疑问"><a href="#2-1首先解决一些疑问" class="headerlink" title="2.1首先解决一些疑问"></a>2.1首先解决一些疑问</h5><p><strong>1）线程可以辅助扩容，有数量上限吗？扔进helpTransfer就会进行辅助扩容吗？</strong></p><p>答：在helpTransfer中，会判断当前线程是否能够加入扩容操作</p><p>这里会有一系列判断</p><p>判断当前是否处于扩容状态中</p><p>判断当前是否还需要辅助扩容</p><p>判断当前参与扩容的线程数量是否达到了上限等</p><p>全部校验通过，才会调用transfer方法进行实际上的扩容操作</p><p><strong>2）多个线程同时扩容，如何保证扩容过程中，数据迁移不重复，不迁移漏的？</strong></p><p>答：</p><p>在transfer方法中，线程进入该方法后会通过计算得出一个transferIndex值，这个值指向自己负责扩容的数组数据结束位置，从后往前进行迁移；</p><p>而这个线程也只负责一段连续区域内的数据迁移任务而已，它只会执行自己负责区域内的数据迁移任务，迁移完成之后把transferIndex设置成一个负数，表示迁移完成；</p><p>如果没有其他线程进入，这个线程会再获得一个迁移范围，从而进行迁移，直到全部迁移完毕；</p><p>即使用分块的模式，让不同的线程负责不同的块，从而避免了扩容区间重叠，遗漏等问题</p><p><strong>3）在扩容时，有其他线程执行插入&#x2F;删除&#x2F;修改&#x2F;查询等操作怎么办？</strong></p><p>答：在原数组中，迁移过程中，槽都会被锁住，其他线程无法操作，只能阻塞在那里，等待释放锁后再操作</p><p>而当一个线程迁移完一段区域内的数据之后，迁移完成的槽，首位置节点都会设置成fwd，这个节点的hash值被设置成了MOVED，即-1</p><p>因此如果有put进来，根据前面分析，会直接把线程扔给辅助扩容数组，无法put成功，只能等待所有数据都迁移完毕</p><p>而如果调用了get方法呢？由于此时hash值小于0，会进入节点的find方法内部</p><p>此时，由于节点类型为fwd，所以进入的find方法会进入新建立的nextTable中找数据</p><p><em><strong>因此扩容中，槽上锁，get和put操作都不行</strong></em></p><p><em><strong>但是某一个槽迁移完毕后，可以get，不可以put</strong></em></p><p><strong>4）如何判断是在扩容状态还是扩容完毕状态的？</strong></p><p>由上面可知，迁移部分时，迁移完毕的槽会放进去一个fwd节点</p><p>全部迁移完毕后就是一个新的数组了，和之前操作没区别，不用判断状态</p><h5 id="2-2总结下迁移流程"><a href="#2-2总结下迁移流程" class="headerlink" title="2.2总结下迁移流程"></a>2.2总结下迁移流程</h5><ul><li>进入helpTransfer方法，判断当前线程是否能够进入搬迁大军当中</li><li>符合条件的线程，会调用transfer方法进行扩容</li><li>扩容时，会为每个线程分配一块儿区域，这个区域就是线程要进行迁移的范围</li><li>然后就是加锁搬迁</li><li>迁移完毕之后，原数组槽位置放进去一个fwd</li></ul><h3 id="四、元素数量统计"><a href="#四、元素数量统计" class="headerlink" title="四、元素数量统计"></a>四、元素数量统计</h3><h4 id="1-源码-3"><a href="#1-源码-3" class="headerlink" title="1.源码"></a>1.源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">  <span class="comment">// 统计元素个数</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">          <span class="comment">// 会完成CounterCell的初始化以及元素的累加</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 是否要做扩容</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">      <span class="comment">// helpTransfer -&gt; 第一次扩容的场景</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">fullAddCount</span><span class="params">(<span class="type">long</span> x, <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        CounterCell[] as; CounterCell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    <span class="type">CounterCell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterCell</span>(x); <span class="comment">// Optimistic create</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                          <span class="comment">// 针对已经初始化的数组的某个位置</span></span><br><span class="line">                          <span class="comment">// 去添加一个CounterCell</span></span><br><span class="line">                            CounterCell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="literal">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                collide = <span class="literal">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 扩容部分</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line">                      <span class="comment">// 一倍扩容</span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> <span class="title class_">CounterCell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                      <span class="comment">// 遍历加入新数组</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 如果CounterCell为空, 保证在初始化过程的线程安全性</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">          <span class="comment">//一旦cas成功，说明当前线程抢到了锁</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">                  <span class="comment">// 初始化长度为2的数组</span></span><br><span class="line">                    CounterCell[] rs = <span class="keyword">new</span> <span class="title class_">CounterCell</span>[<span class="number">2</span>];</span><br><span class="line">                  <span class="comment">// 把x保存到某个位置</span></span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">CounterCell</span>(x);</span><br><span class="line">                  <span class="comment">// 复制给成员变量counterCells</span></span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                    init = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="comment">// 释放锁</span></span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 最终的情况，直接修改baseCount</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-小结-3"><a href="#2-小结-3" class="headerlink" title="2.小结"></a>2.小结</h4><p>在jdk1.8中，由于存在多线程操作的情况，因此不再使用一个单独的变量来计算map中的元素数量，而是使用了一个数组CounterCell来进行统计</p><p>当put进一个元素后，会调用addCount方法来进行元素数量的增加</p><ul><li>首先会尝试对baseCount进行自增，当新增失败后表示竞争激烈</li><li>此时会使用CounterCell来进行元素统计，进入fullAddCount</li><li>如果CounterCell未初始化，则进行初始化为2，并把新增元素数量x随机放到一个位置</li><li>如果此时还无法放进去，即没有空闲的CounterCell，那么就会新建一个CounterCell，容量是2倍</li><li>然后将旧的都迁移过去，再尝试把x放进去</li></ul><p>大致流程如上</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ConcurrentHashMap使用了大量的CAS锁来保证并发安全，主要是扩容与元素统计略显复杂，putVal的主流程还是十分清晰的</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（四）Condition</title>
      <link href="/2023/03/28/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/03/28/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、线程的通信"><a href="#一、线程的通信" class="headerlink" title="一、线程的通信"></a>一、线程的通信</h3><h4 id="1-通信方式"><a href="#1-通信方式" class="headerlink" title="1.通信方式"></a>1.通信方式</h4><ol><li><strong>共享内存</strong>：多个线程共享同一块内存空间，可以直接在内存中读写数据进行通信。</li><li><strong>互斥锁</strong>：使用互斥锁来实现对共享资源的访问控制，确保同一时间只有一个线程能够访问共享资源，从而避免多个线程同时对资源进行读写而导致数据不一致的问题。</li><li><strong>条件变量</strong>：条件变量通常和互斥锁一起使用，用于线程之间的信号传递。一个线程可以等待某个条件变量被触发，另一个线程可以通过发送信号来触发条件变量，从而唤醒等待该条件变量的线程。</li><li><strong>信号量</strong>：信号量是一种用于线程间同步和互斥的机制。它可以用于多个线程之间的同步，以确保它们在互斥资源上的访问顺序正确。</li><li><strong>管道</strong>：管道是一种用于进程间通信的机制，但也可以用于线程之间的通信。一个线程可以将数据写入管道，另一个线程可以从管道中读取数据，从而实现线程之间的数据传输。</li><li><strong>消息队列</strong>：消息队列是一种用于进程间通信的机制，但也可以用于线程之间的通信。一个线程可以向消息队列发送消息，另一个线程可以从消息队列中读取消息，从而实现线程之间的数据传输。</li></ol><blockquote><p>线程间经常使用wait&#x2F;notify&#x2F;notifyAll进行通信，这种方式属于条件变量通信</p><p>wait&#x2F;notify关键字来源于Object类，属于native标注的Java内置方法，底层由C++来实现</p></blockquote><h4 id="2-同步队列与阻塞队列"><a href="#2-同步队列与阻塞队列" class="headerlink" title="2.同步队列与阻塞队列"></a>2.同步队列与阻塞队列</h4><p><strong>1）同步队列</strong></p><p>同步队列是Java中用于实现线程同步的一种数据结构，通常是一个先进先出（FIFO）的队列。它通常是指一个队列，其中的线程已经持有了锁&#x2F;或者尝试获取锁，但是由于某些原因（例如等待某些资源）无法执行，于是它们在队列中等待锁释放。</p><p>同步队列是通过Java内置的锁机制实现的，当一个线程在获取锁时，如果锁被其他线程持有，则该线程会进入同步队列中排队等待获取锁。当锁被释放时，队列中的线程会按照先进先出的顺序依次尝试获取锁并执行任务。</p><p>同步队列中的线程状态为<strong>BLOCKED</strong>或者<strong>RUNNABLE</strong></p><p><strong>说人话就是，同步队列当中放着持有锁或者正在等待拿锁的线程</strong></p><p><strong>2）等待队列&#x2F;阻塞队列</strong></p><p>一般来说，线程的等待队列是指线程在调用<strong>wait</strong>()方法时进入的一个队列，用于等待条件满足。当一个线程调用了对象的<strong>wait</strong>()方法后，该线程会释放占有的锁，并进入该对象的等待队列中等待被唤醒。线程在等待队列中会处于<strong>WAITING</strong>或<strong>TIMED_WAITING</strong>状态，等待其他线程通过<strong>notify</strong>()或<strong>notifyAll</strong>()方法将其唤醒。</p><h4 id="3-wait-x2F-notify"><a href="#3-wait-x2F-notify" class="headerlink" title="3.wait()&#x2F;notify()"></a>3.wait()&#x2F;notify()</h4><p>通过一个<strong>生产者-消费者</strong>模型来讲解下这两者的作用与关系</p><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; bags;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Queue&lt;String&gt; bags, <span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bags = bags;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    i++;</span><br><span class="line"><span class="keyword">synchronized</span> (bags)&#123; <span class="comment">//抢占锁 </span></span><br><span class="line">              <span class="keyword">if</span>(bags.size()==maxSize)&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;bags 满了&quot;</span>); </span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">//park(); -&gt;JVM -&gt;Native</span></span><br><span class="line">                      bags.wait(); <span class="comment">//满了，阻塞当前线程并且释放Producer抢到的锁 </span></span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">&#125; </span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产者生产:bag&quot;</span>+i); </span><br><span class="line">              bags.add(<span class="string">&quot;bag&quot;</span>+i); <span class="comment">//生产bag</span></span><br><span class="line">        bags.notify(); <span class="comment">//表示当前已经生产了数据，提示消费者可以消费了</span></span><br><span class="line">        &#125; <span class="comment">//同步代码快执行结束 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Queue&lt;String&gt; bags;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Queue&lt;String&gt; bags, <span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.bags = bags;</span><br><span class="line">       <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (bags)&#123;</span><br><span class="line">               <span class="keyword">if</span>(bags.isEmpty())&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;bags为空&quot;</span>); </span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                       bags.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">&#125; </span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">String bag=bags.remove(); </span><br><span class="line">             System.out.println(<span class="string">&quot;消费者消费:&quot;</span>+bag);</span><br><span class="line">bags.notify(); <span class="comment">//这里只是唤醒Producer线程，但是Producer线程并不能马上执行。</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，当生产者发现队列已满时，会调用wait()进行阻塞；当生产了资源之后，可以调用notify()通知消费者可以开始消费了；同理，消费者发现队列为空会陷入阻塞等待唤醒，消费后会尝试唤醒生产者</p><blockquote><p>这里要注意，只有持有锁的对象才可以调用wait()方法，不然会抛出异常</p></blockquote><h4 id="4-join"><a href="#4-join" class="headerlink" title="4.join"></a>4.join</h4><p>join也是基于wait&#x2F;notify来实现，notify是在线程销毁之后调用的</p><p><code>join()</code> 是 Java 中 Thread 类提供的一个方法，可以让一个线程等待另一个线程的结束，直到被等待的线程执行完毕，或者等待一定的时间，或者被中断。</p><p>具体来说，调用 <code>t.join()</code> 方法会让当前线程（通常是主线程）等待线程 <code>t</code> 执行完毕，也就是线程 <code>t</code> 终止之前，当前线程都会处于阻塞状态，等待线程 <code>t</code> 终止后才能继续执行。如果 <code>t</code> 在当前线程调用 <code>join()</code> 方法之前已经终止，那么 <code>join()</code> 方法会立即返回。</p><h4 id="5-Condition"><a href="#5-Condition" class="headerlink" title="5.Condition"></a>5.Condition</h4><p>Condition实际上就是J.U.C版本的wait&#x2F;notify。可以让线程基于某个条件去等待和唤醒</p><p>那么为什么有了wait&#x2F;notify的情况下，还要再去实现一个Condition呢？</p><p>Condition 的出现主要是为了解决 Object 中的 wait() 和 notify() 在多个线程等待同一个锁时的局限性。</p><p>Condition 提供了三个基本操作：</p><ol><li>await(): 使当前线程等待直到其他线程唤醒它。</li><li>signal(): 唤醒一个等待在 Condition 上的线程。</li><li>signalAll(): 唤醒所有等待在 Condition 上的线程。</li></ol><p>与 Object 的 wait() 和 notify() 方法相比，Condition 提供的操作更加灵活。它可以允许多个等待线程同时等待同一个锁，并且可以按照需要唤醒指定的线程或者所有线程。</p><p>另外，Condition 对象必须和一个 Lock 对象绑定使用，因为 Condition 需要依赖于锁来实现等待和唤醒操作</p><p><strong>Condition设计猜想</strong></p><ul><li><strong>作用</strong>: 实现线程的阻塞和唤醒 </li><li><strong>前提条件</strong>: 必须先要获得锁 await&#x2F;signal&#x2F;signalAll<ul><li>await -&gt; 让线程阻塞， 并且释放锁 </li><li>signal -&gt; 唤醒阻塞的线程</li></ul></li><li>加锁的操作，必然会涉及到AQS的阻塞队列</li><li>await 释放锁的时候，-&gt; AQS队列中不存在已经释放锁的线程 -&gt; 这个被释放的线程去了哪里? </li><li>signal 唤醒被阻塞的线程 -&gt; 从哪里唤醒?</li></ul><blockquote><p>通过await方法释放的线程，必须要有一个地方来存储，并且还需要被阻塞—–因此需要有一个等待队列</p><p>signal——从上面猜想到的等待队列中，唤醒一个线程——唤醒后放哪里去? 是不是应该再放到AQS队列?</p></blockquote><h3 id="二、Condition"><a href="#二、Condition" class="headerlink" title="二、Condition"></a>二、Condition</h3><h4 id="1-接口介绍"><a href="#1-接口介绍" class="headerlink" title="1.接口介绍"></a><strong>1.接口介绍</strong></h4><p>先来看看Condition接口定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Condition 对象必须和一个 Lock 对象绑定使用，因为 Condition 需要依赖于锁来实现等待和唤醒操作。例如，可以通过调用 Lock 的 newCondition() 方法来创建一个 Condition 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure><p>在使用 Condition 时，通常的流程是：</p><ol><li>获得锁。</li><li>判断条件是否满足，如果满足则执行相应的操作，否则执行 await() 方法将线程加入到等待队列中。</li><li>等待其他线程唤醒自己。</li><li>被唤醒后再次获得锁。</li><li>执行相应的操作并释放锁。</li></ol><h4 id="2-await方法"><a href="#2-await方法" class="headerlink" title="2.await方法"></a>2.await方法</h4><p>Condition是一个接口，本身是不包含方法的实现的，它在并发编程工具类之中，主要在两个类之中被使用，分别是<code>AbstractQueuedLongSynchronizer</code>与<code>AbstractQueuedSynchronizer</code>，后者正是前文提到过的AQS框架</p><blockquote><p>下面分析主要依据AQS框架之中实现Condition接口的内部类ConditionObject来分析</p></blockquote><p>在AQS框架之中，ConditionObject属于内部类，实现了Condition接口定义的诸多方法，其中await方法的实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">  <span class="comment">// 添加到等待队列</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter(); <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 完整的释放锁(考虑重入问题)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node); <span class="comment">// 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;  <span class="comment">// 3</span></span><br><span class="line">      <span class="comment">// 上下文切换(程序计数器、寄存器) 用户态-内核态的转化(上下文切换)</span></span><br><span class="line">      <span class="comment">// 阻塞当前线程(当其他线程调用signal()方法时，该线程会从这个位置去执行)</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">      <span class="comment">// 要判断当前被阻塞的线程是否是因为interrupt()唤醒</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>) <span class="comment">// 4</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 重新竞争锁，savedState表示的是被释放的锁的重入次数.</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)  <span class="comment">// 5</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 用于判断线程在等待过程中是否被中断，如果被中断，会设置线程的中断状态。</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意<code>LockSupport.park(this);</code>将线程阻塞在了这里</p></blockquote><p>概述上述方法执行步骤如下：</p><ol><li>获取当前线程的独占锁，并将状态设置为等待状态；</li><li>将当前线程加入等待队列中，等待唤醒；</li><li>释放独占锁，允许其他线程访问；</li><li>等待被唤醒，被唤醒后重新尝试获取独占锁；</li><li>获取到锁后，将等待状态清除。</li></ol><p>具体的，代码分析如下：</p><p>1.首先，调用了addConditionWaiter获得封装的节点，方法具体实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter; <span class="comment">// 最后一个等待节点</span></span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters(); <span class="comment">// 从头开始，清除所有CANCELLED状态的节点</span></span><br><span class="line">        t = lastWaiter; <span class="comment">// t始终指向最后一个等待队列的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 封装node为当前线程 设置为等待状态</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.用于完全释放独占锁或者共享锁，即如果node当前持有锁，则释放之；就是将持有锁的<strong>state</strong>值恢复为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;  <span class="comment">// 释放锁</span></span><br><span class="line">            failed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.用于判断指定的线程是否在 AQS 同步队列中，如果是，则需要将其从同步队列中移除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.其作用是在当前线程等待过程中检查中断状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// REINTERRUPT表示重置线程的中断状态，即线程在等待时被中断，</span></span><br><span class="line"><span class="comment">// 但是不能抛出异常，需要重置中断状态，让线程继续执行。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REINTERRUPT</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line"><span class="comment">// THROW_IE表示抛出InterruptedException异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROW_IE</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* transferAfterCancelledWait 方法的作用就是当一个线程被意外唤醒后，将该线程重新加入到等待队列中。</span></span><br><span class="line"><span class="comment">* 具体来说，该方法会将该线程从同步队列中删除，并重新将该线程加入到等待队列中，然后会对该线程进行自旋，等待被唤醒。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>5.<code>acquireQueued</code>是AQS中的一个核心方法，主要用于实现独占模式下的获取锁操作。该方法会在一个循环中不断尝试获取锁，如果获取不到，则会将当前线程包装成一个Node节点，并将其加入等待队列中，最后通过调用<code>parkAndCheckInterrupt</code>方法使线程阻塞等待唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-signal方法"><a href="#3-signal方法" class="headerlink" title="3.signal方法"></a>3.signal方法</h4><ul><li><p>要把被阻塞的线程，先唤醒(signal、signalAll) </p></li><li><p>把等待队列中被唤醒的线程转移到AQS队列中</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;<span class="comment">// 得到当前等待队列</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 唤醒等待队列中的一个线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唤醒操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">  <span class="comment">// 被取消，不能唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 这里是把当前等待队列中头部节点---&gt;保存到AQS队列</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唤醒之后，还记得上await方法中的<code>LockSupport.park(this);</code>吗？当时阻塞在这里，现在唤醒之后会继续往下执行</p><h4 id="4-Condition的实际应用"><a href="#4-Condition的实际应用" class="headerlink" title="4.Condition的实际应用"></a>4.Condition的实际应用</h4><p>-&gt;实现阻塞队列(业务组件) </p><p>-&gt; 在线程池中会用到阻塞队列 </p><p>-&gt; 生产者消费者</p><p>-&gt; 流量缓冲</p><h3 id="三、阻塞队列"><a href="#三、阻塞队列" class="headerlink" title="三、阻塞队列"></a>三、阻塞队列</h3><h4 id="1-什么叫阻塞队列"><a href="#1-什么叫阻塞队列" class="headerlink" title="1.什么叫阻塞队列?"></a>1.什么叫阻塞队列?</h4><p>队列是一种只允许在一端进行删除操作，在另一端进行插入操作的线性表，允许插入的一端称为队尾、<br>允许删除的一端称为队头。<br>那么阻塞队列，实际上是在队列的基础上增加了两个操作。</p><ul><li>支持阻塞插入:队列满了的情况下，会阻塞继续往队列中添加数据的线程，直到队列元素被释放。</li><li>只是阻塞移除:队列为空的情况下，会阻塞从队列中获取元素的线程，直到队列添加了新的元素。</li></ul><h4 id="2-阻塞队列中的方法"><a href="#2-阻塞队列中的方法" class="headerlink" title="2.阻塞队列中的方法"></a>2.阻塞队列中的方法</h4><p>添加元素</p><blockquote><p>针对队列满了之后的不同的处理策略</p></blockquote><ul><li>add -&gt; 如果队列满了，抛出异常</li><li>offer -&gt; true&#x2F;false ， 添加成功返回true，否则返回false</li><li>put -&gt; 如果队列满了，则一直阻塞</li><li>offer(timeout) , 带了一个超时时间。如果添加一个元素，队列满了，此时会阻塞timeout 时长，超过阻塞时长，返回false。</li></ul><p>移除元素</p><ul><li>element-&gt; 队列为空，抛异常</li><li>peek -&gt; true&#x2F;false ， 移除成功返回true，否则返回false take -&gt; 一直阻塞</li><li>poll(timeout) -&gt; 如果超时了，还没有元素，则返回null</li></ul><p>dequeue -&gt; LIFO , FIFO的队列.</p><h4 id="3-JUC中的阻塞队列"><a href="#3-JUC中的阻塞队列" class="headerlink" title="3.JUC中的阻塞队列"></a>3.JUC中的阻塞队列</h4><ul><li>ArrayBlockingQueue 基于数组结构 </li><li>LinkedBlockingQueue 基于链表结构 </li><li>PriorityBlcokingQueue 基于优先级队列 </li><li>DelayQueue 允许延时执行的队列 </li><li>SynchronousQueue 没有任何存储结构的的队列</li></ul><h4 id="4-ArrayBlockingQueue"><a href="#4-ArrayBlockingQueue" class="headerlink" title="4.ArrayBlockingQueue"></a>4.ArrayBlockingQueue</h4><p>变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The queued items */</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** items index for next take, poll, peek or remove */</span></span><br><span class="line"><span class="type">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** items index for next put, offer, or add */</span></span><br><span class="line"><span class="type">int</span> putIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of elements in the queue */</span></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Concurrency control uses the classic two-condition algorithm</span></span><br><span class="line"><span class="comment"> * found in any textbook.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Main lock guarding all access */</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><p>最终的入队方法，本质就是一个数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    items[putInd、ex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-LinkedBlockingQueue"><a href="#5-LinkedBlockingQueue" class="headerlink" title="5.LinkedBlockingQueue"></a>5.LinkedBlockingQueue</h4><p>本质就是一个单向链表，因此是无界阻塞队列</p><h4 id="6-PriorityBlcokingQueue"><a href="#6-PriorityBlcokingQueue" class="headerlink" title="6.PriorityBlcokingQueue"></a>6.PriorityBlcokingQueue</h4><p>双向链表组成的队列.</p><p>支持双向插入和移除. </p><p>在一定程度上能够解决多线程的竞争问题</p><h4 id="7-SynchronousQueue"><a href="#7-SynchronousQueue" class="headerlink" title="7.SynchronousQueue"></a>7.SynchronousQueue</h4><p>SynchronousQueue 是 Java 并发包中的一个特殊的 BlockingQueue 实现。它在一定程度上类似于管道，允许线程在管道两端之间进行信息传递，但它具有阻塞和同步的特性。</p><p>SynchronousQueue 的特点是容量为 0，也就是说在一个线程放入元素之前必须有另一个线程等待从队列中取走该元素。如果没有线程等待取元素，那么就无法插入元素，因此 put 操作将会一直阻塞，直到有另一个线程取走该元素。</p><p>SynchronousQueue 的主要用途是让一个线程等待另一个线程的结果，例如一个生产者线程等待一个消费者线程处理完数据。它可以用于生产者消费者模式、任务提交和任务执行的协调等场景，也可以用于一些特殊的任务调度场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SynchronousQueue</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> <span class="title class_">TransferQueue</span>&lt;E&gt;() : <span class="keyword">new</span> <span class="title class_">TransferStack</span>&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newCachedThreadPool线程池的实现队列，由于其容量为0，最大线程数基本处于最大，这种情况下可以创建大量线程，快速响应操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、阻塞队列的使用"><a href="#四、阻塞队列的使用" class="headerlink" title="四、阻塞队列的使用"></a>四、阻塞队列的使用</h3><h4 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1.CountDownLatch"></a>1.CountDownLatch</h4><blockquote><p>实现原理</p><ul><li>它可以让一个线程阻塞</li><li>也可以让多个线程阻塞</li></ul><p>共享锁的实现</p><p>可以允许多个线程同时抢占到锁，然后等到计数器归零的时候，同时唤醒. state记录计数器.</p><p>countDown的时候，实际上就是 state–</p></blockquote><p>CountDownLatch可以让许多线程阻塞，调用countDown直到计数器state为0后同时释放</p><p>因此它有两种使用方法</p><p>1.初始时设置state的值，在某一公共处调用await方法，所有操作都会阻塞在那里，在某些线程内调用countDown不断减小计数器，直到某一状态时统一放行；比如多线程处理某任务，阻塞主线程，等多线程任务处理完毕再统一放行；</p><p>2.在多线程内部调用await阻塞，将每个线程都拦在指定位置，然后调用一次countDown即可为所有线程放行</p><p>CountDownLatch用到的是AQS的共享锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS内方法，尝试获取共享锁，获取不到就封装入队，先自旋再次尝试获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Semaphore"><a href="#2-Semaphore" class="headerlink" title="2.Semaphore"></a>2.Semaphore</h4><p>信号灯.</p><p>限流器,限制资源的访问.</p><p>本质上: 抢占一个令牌. -&gt; 如果抢占到令牌，就通行， 否则，就阻塞!</p><ul><li>acquire() 抢占一个令牌 </li><li>release() 释放一个令牌.</li></ul><h4 id="3-CyclicBarrier"><a href="#3-CyclicBarrier" class="headerlink" title="3.CyclicBarrier"></a>3.<strong>CyclicBarrier</strong></h4><p>可重复的栅栏</p><p>相当于，多个线程通过CountDownLatch的await</p><p>然后另外一个线程使用countDown方法来唤醒</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶之并发编程（三）AQS详解</title>
      <link href="/2023/03/27/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/03/27/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是JUC"><a href="#一、什么是JUC" class="headerlink" title="一、什么是JUC"></a>一、什么是JUC</h3><p>JUC指的是Java并发编程工具包（Java Concurrency Utilities），它提供了一系列的工具类和接口，用于简化并发编程的开发。虽然Java语言中已经提供了synchronized关键字来支持多线程并发编程，但是JUC提供了更加灵活和高效的实现方式，以满足更加复杂的并发编程需求。</p><p>具体来说，JUC提供了以下几个重要的类和接口：</p><ol><li>Lock和Condition：Lock和Condition是替代synchronized关键字的工具，它们提供了更加灵活和可控的线程同步机制，使得在高并发情况下能够更加高效地协调线程之间的交互。</li><li>Semaphore：Semaphore是一种计数信号量，它可以用来控制同时访问某个资源的线程数量。</li><li>CountDownLatch：CountDownLatch是一种倒计数器，它可以让一个线程等待多个其他线程执行完毕后再继续执行。</li><li>CyclicBarrier：CyclicBarrier也是一种倒计数器，它可以让多个线程相互等待，直到所有线程都到达某个屏障点后再一起继续执行。</li><li>Executor和ExecutorService：Executor和ExecutorService是线程池的实现，它们可以有效地管理和控制线程的数量，从而避免创建过多的线程导致系统资源浪费和性能下降。</li></ol><p>综上所述，虽然synchronized关键字可以实现基本的线程同步和互斥，但在高并发情况下，JUC提供的工具类和接口能够更加灵活和高效地协调线程之间的交互，从而提高程序的性能和可靠性。</p><p>在正式介绍JUC之前，先思考一个问题，那就是如果让我们自己实现一个类似sychronized的锁机制，我们要如何去设计呢？</p><p><strong>锁设计猜想</strong></p><ul><li><p>一定会设计到锁的抢占 ， 需要有一个标记来实现互斥。 全局变量(0，1)</p></li><li><p>抢占到了锁，怎么处理(不需要处理.)</p></li><li><p>没抢占到锁，怎么处理</p><ul><li>需要等待(让处于排队中的线程，如果没有抢占到锁，则直接先阻塞-&gt;释放CPU资源)。 <ul><li>如何让线程等待?<ul><li>wait&#x2F;notify(线程通信的机制，<strong>无法指定唤醒某个线</strong>程)</li><li><strong>LockSupport.park&#x2F;unpark</strong>(阻塞一个指定的线程，唤醒一个指定的线程) Condition</li></ul></li></ul></li><li>需要排队(允许有N个线程被阻塞，此时线程处于活跃状态)。 <ul><li>通过一个数据结构，把这N个排队的线程存储起来。</li></ul></li></ul></li><li><p>抢占到锁的释放过程，如何处理</p><ul><li>LockSupport.unpark() -&gt; 唤醒处于队列中的指定线程.</li></ul></li><li><p>锁抢占的公平性(是否允许插队)</p></li><li><p>公平 </p></li><li><p>非公平</p></li></ul><p>在JUC中，AQS（AbstractQueuedSynchronizer）即是实现上述过程的一个框架类</p><h3 id="二、AQS"><a href="#二、AQS" class="headerlink" title="二、AQS"></a>二、AQS</h3><p>AQS（AbstractQueuedSynchronizer）是一个用于构建锁、同步器等并发组件的框架，它是Java并发包（java.util.concurrent）的核心组件之一。</p><p>首先介绍一下AQS中用到的一些类与变量</p><h4 id="1-内部类—Node"><a href="#1-内部类—Node" class="headerlink" title="1.内部类—Node"></a>1.内部类—Node</h4><p>Node作为等待队列节点类，在线程竞争锁失败后，AQS会将线程封装成一个Node节点，放入等待队列当中，自旋等待，自旋竞争再次失败后就会进入等待状态，等待被唤醒再次竞争锁</p><p>Node类包含以下主要字段：</p><ol><li>prev：指向前一个节点的指针。</li><li>next：指向后一个节点的指针。</li><li>thread：持有该节点的线程对象。</li><li>waitStatus：用于表示线程的状态，包括取消、阻塞、等待等。</li><li>nextWaiter：用于在等待队列中链接不同条件的线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     +------+  prev +-----+       +-----+</span><br><span class="line">head |      | &lt;---- |     | &lt;---- |     |  tail</span><br><span class="line">     +------+       +-----+       +-----+</span><br></pre></td></tr></table></figure><p>Node类源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">/** 标识共享模式的静态常量，它被用于表示线程等待的条件是共享的，而不是独占的 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="comment">/** 标识独占模式的静态常量，它被用于表示线程等待的条件是独占的，而不是共享的 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 用于标记一个节点已经被取消，不再参与同步操作 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** 用于表示一个节点已经被唤醒，并且可以尝试竞争同步资源 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">  *是一个表示节点所属的条件队列的静态常量。它被用于区分节点所属的等待队列和条件队列</span></span><br><span class="line"><span class="comment">  * 每个节点在创建时，都会与一个特定的条件队列相关联。</span></span><br><span class="line"><span class="comment">* 当节点被添加到等待队列中时，它的CONDITION字段会被设置为与它相关联的条件队列。</span></span><br><span class="line"><span class="comment">* 在等待队列中，节点的状态为WAITING或SIGNAL；而在条件队列中，节点的状态为CONDITION。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/** 标志表示当前节点需要向后传播唤醒信号，通知后继节点可以尝试获取锁 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"><span class="comment">/** 表示持有锁或正在等待锁的线程 */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 指向同步队列头</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指向同步队列尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure><p>同步队列是AQS中一个重要的概念，用于实现线程的阻塞和唤醒，以及线程的竞争获取同步状态。</p><p>AQS中包含了三种队列概念：等待队列、条件队列和同步队列。</p><ol><li><strong>等待队列</strong>（Wait Queue）：等待队列是AQS中用于存放<strong>被阻塞</strong>的线程的数据结构。当一个线程需要获取同步状态，但是当前同步状态已经被其他线程占用时，该线程会被封装成一个Node节点并加入到等待队列中。等待队列是一个FIFO队列，可以保证等待时间最长的线程先被唤醒。</li><li><strong>条件队列</strong>（Condition Queue）：条件队列是<strong>基于等待队列</strong>实现的，用于支持条件变量的功能。当一个线程需要等待一个条件变量时，它会被封装成一个Node节点并加入到条件队列中，而不是等待队列中。当满足条件时，条件队列中的线程会被转移至等待队列中等待获取同步状态。</li><li><strong>同步队列</strong>（Sync Queue）：同步队列是AQS中存放<strong>已经获取到同步状态的线程（即通过acquire获取成功）</strong>的数据结构。当一个线程获取到同步状态后，它会从等待队列中转移到同步队列中，并且会释放之前占有的同步状态。同步队列的管理是通过head和tail指针实现的，head指向同步队列的第一个节点，tail指向同步队列的最后一个节点。</li></ol><blockquote><p>此外，还需要注意<code>exclusiveOwnerThread</code>这个变量，它来自于AQS的抽象父类<code>AbstractOwnableSynchronizer</code>，该类就两个方法，分别是设置和获取该变量<code>exclusiveOwnerThread</code></p></blockquote><h4 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a>3.方法</h4><p>AQS中的几个重要方法如下：</p><ol><li>acquire(int arg)：尝试获取独占锁，如果获取失败，则将当前线程加入同步队列并进行自旋或者阻塞，直到获取成功或者被中断。</li><li>acquireShared(int arg)：尝试获取共享锁，如果获取失败，则将当前线程加入同步队列并进行自旋或者阻塞，直到获取成功或者被中断。</li><li>release(int arg)：释放独占锁。</li><li>releaseShared(int arg)：释放共享锁。</li><li>tryAcquire(int arg)：尝试获取独占锁，如果获取成功，则返回true，否则返回false。</li><li>tryAcquireShared(int arg)：尝试获取共享锁，如果获取成功，则返回一个大于等于0的值，表示获取共享锁的线程数，否则返回负数。</li><li>tryRelease(int arg)：尝试释放独占锁，如果成功则返回true，否则返回false。</li><li>tryReleaseShared(int arg)：尝试释放共享锁，如果成功则返回true，否则返回false。</li><li>acquireInterruptibly(int arg)：尝试获取独占锁，如果获取失败，则将当前线程加入同步队列并进行自旋或者阻塞，直到获取成功或者被中断。</li></ol><p>这些方法是AQS中的核心方法，用于实现同步和互斥。</p><ul><li><p>acquire()、acquireShared()、release()、releaseShared() 是AQS中最常用的同步方法</p></li><li><p>tryAcquire()、tryAcquireShared()、tryRelease()、tryReleaseShared() 则是尝试获取&#x2F;释放同步状态，这些方法一般是被重载后使用。</p></li><li><p>acquireInterruptibly() 方法也是尝试获取独占锁，不过它会响应中断。</p></li></ul><h5 id="1）compareAndSetState"><a href="#1）compareAndSetState" class="headerlink" title="1）compareAndSetState"></a><strong>1）compareAndSetState</strong></h5><p>AQS中通过state变量来标识同步状态，为了保证state参数修改的可见性、原子性，在AQS当中使用CAS机制来进行state的修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）acquire"><a href="#2）acquire" class="headerlink" title="2）acquire"></a><strong>2）acquire</strong></h5><p>尝试获取独占锁，如果获取失败，则将当前线程加入同步队列并进行自旋或者阻塞，直到获取成功或者被中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>tryAcquire</code> 是 AQS 中一个抽象方法，需要用户自定义实现。在 AQS 中，同步状态的获取和释放都是通过 <code>tryAcquire</code> 和 <code>tryRelease</code> 方法实现的，因此用户可以根据自己的需求来定义同步状态的获取和释放逻辑。</p><p><code>addWaiter</code> 方法是 AQS 中的一个辅助方法，用于将一个新的 <code>Node</code> 节点加入到等待队列中，并返回这个新节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，AQS中的<code>enq</code>方法用于将线程加入到等待队列中，实现方式是通过CAS（compare-and-swap）操作将节点插入到队尾，保证线程的插入是原子性的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquireQueued传入<code>addWaiter</code> 方法返回的节点，一丝是在线程被包装成节点入队之后，还会尝试调用自旋来获取锁，步骤如下：</p><ol><li>尝试获取锁，如果成功则直接返回。</li><li>如果获取锁失败，则线程会进入自旋状态，不断地检查前驱节点的状态是否为 SIGNAL。</li><li>如果前驱节点状态为 SIGNAL，说明当前线程可以尝试获取同步状态了，于是调用tryAcquire方法再次尝试获取锁。</li><li>如果获取锁成功，则当前线程会从等待队列中移除，并返回。</li><li>如果tryAcquire方法返回false，则当前线程会继续自旋等待前驱节点唤醒自己。</li></ol><blockquote><p>acquireQueued方法中的自旋是在等待前驱节点释放锁的过程中进行的，如果等待时间过长，一般是由于前驱节点无法释放锁，这时会进入阻塞状态。在进入阻塞状态前，会将自己的节点状态设置为WAITING，并通过LockSupport.park()方法挂起线程，等待前驱节点的唤醒。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node表示当前来抢占锁的线程</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 自旋</span></span><br><span class="line">          <span class="comment">// 尝试去获得锁</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 返回true，不需要等待直接返回</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 否则让线程去阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于在当前线程上阻塞，直到被其他线程唤醒或中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>); <span class="comment">// 使当前线程阻塞</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 返回当前线程中断状态，即是否被中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3）acquireShared"><a href="#3）acquireShared" class="headerlink" title="3）acquireShared"></a><strong>3）acquireShared</strong></h5><p>尝试获取共享锁，如果获取失败，则将当前线程加入同步队列并进行自旋或者阻塞，直到获取成功或者被中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4）release"><a href="#4）release" class="headerlink" title="4）release"></a><strong>4）release</strong></h5><p>释放独占锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，tryRelease交给子类实现</p><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p>AQS是一个用于构建同步器的框架，它为子类提供了许多方法，使得子类仅需要重写部分方法就可以方便的实现同步功能，下面是AQS为子类提供的一些公共功能</p><ol><li>获取&#x2F;释放锁：AQS提供了acquire()和release()两个方法，这两个方法是获取锁和释放锁的基础。</li><li>等待队列的操作：AQS提供了许多操作等待队列的方法，例如enq()、deq()、transferForSignal()等等。这些方法让子类能够方便地实现等待队列的管理。</li><li>条件队列的操作：AQS还提供了一些操作条件队列的方法，例如addConditionWaiter()、transferAfterCancelledWait()等等。这些方法可以让子类方便地实现条件队列的管理。</li><li>重入锁的实现：AQS还提供了一些方法，可以方便地实现重入锁。例如tryAcquire()、tryRelease()等等。</li><li>共享锁的实现：AQS提供了一些方法，可以方便地实现共享锁。例如tryAcquireShared()、tryReleaseShared()等等。</li><li>线程的中断处理：AQS提供了interruptMode()和clearInterruptsForReentry()两个方法，可以方便地处理线程中断的情况。</li></ol><p>总的来说，AQS并没有定义具体的加锁和释放锁的逻辑，而是通过子类来实现这些逻辑，同时提供了一些钩子方法，使得子类可以在特定的时间点进行扩展和定制。这种设计能够提高复用性和灵活性，使得开发者可以快速地构建出各种同步器，以满足不同的需求。</p><p>其中，子类至少需要重写以下方法：</p><ol><li><strong>tryAcquire</strong>(int)：尝试以独占模式获取同步状态，如果获取成功，返回true，否则返回false。</li><li><strong>tryRelease</strong>(int)：尝试以独占模式释放同步状态，如果释放成功，返回true，否则返回false。</li><li><strong>tryAcquireShared</strong>(int)：尝试以共享模式获取同步状态，如果获取成功，返回大于等于0的值，否则返回小于0的值。</li><li><strong>tryReleaseShared</strong>(int)：尝试以共享模式释放同步状态，如果释放成功，返回true，否则返回false。</li></ol><h3 id="三、ReentrantLock类"><a href="#三、ReentrantLock类" class="headerlink" title="三、ReentrantLock类"></a>三、ReentrantLock类</h3><h4 id="1-基础分析"><a href="#1-基础分析" class="headerlink" title="1.基础分析"></a>1.基础分析</h4><p>ReentrantLock并不是直接继承了AQS抽象类，而是定义了一个内部类来继承AQS，并在此基础上分别实现了公平锁与非公平锁两种同步类型，宏观上看代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 默认实现非公平锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在不指定锁类型时，声明的就是非公平锁，如果传入了boolean值，则判断后生成公平或者非公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-非公平锁-加锁"><a href="#2-非公平锁-加锁" class="headerlink" title="2.非公平锁-加锁"></a>2.非公平锁-加锁</h4><p>首先看加锁过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 无论AQS中是否有排队情况，都会尝试插队抢占锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 插队失败后执行AQS中的acquire方法</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面已经分析过acquire方法，这里不再赘述，简单来说就是一个封装线程为节点入队，并在入队后自旋尝试继续获取锁的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由ReentrantLock实现的非公平锁加锁过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 无锁状态</span></span><br><span class="line">      <span class="comment">// 不管队列情况，直接抢锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//CAS(#Lock) -&gt; 原子操作| 实现互斥的判断</span></span><br><span class="line">            setExclusiveOwnerThread(current); <span class="comment">//把获得锁的线程保存到exclusiveOwnerThread中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//如果当前获得锁的线程和当前抢占锁的线程是同一个，表示重入</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires; <span class="comment">// 增加重入次数</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc); <span class="comment">// 保存state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-公平锁-加锁"><a href="#3-公平锁-加锁" class="headerlink" title="3.公平锁-加锁"></a>3.公平锁-加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试抢占一把锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS中定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试获取锁</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 注意与非公平锁的tryAcquire方法区别在这里</span></span><br><span class="line">      <span class="comment">// hasQueuedPredecessors用来判断当前线程是否有前驱节点，如果有就不能抢占</span></span><br><span class="line">      <span class="comment">// 即需要按照入队顺序依次获取锁，如果当前线程前面有线程未获得锁，当前线程也不能抢占</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-解锁"><a href="#4-解锁" class="headerlink" title="4.解锁"></a>4.解锁</h4><p>ReentrantLock类内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AQS中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 判断是否完全释放了锁，即state为0</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 队列不为空，尝试唤醒</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases; <span class="comment">// state新值</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">//判断释放锁的线程是否持有锁</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">//完全释放了锁</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>); <span class="comment">// 释放独占标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) <span class="comment">// 表示可以唤醒状态</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>); <span class="comment">// 恢复状态值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">// 说明这个线程已经被销毁，或者存在异常</span></span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 从tail往head进行遍历</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 查找状态小于等于0，表示需要被唤醒</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 最后找到的是head后面第一个能唤醒的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);<span class="comment">// 唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是waitStatus的取值与代表意义</p><ul><li>SIGNAL(-1)：表示当前节点的后继节点需要被唤醒。</li><li>CANCELLED(1)：表示当前节点已经取消等待。</li><li>CONDITION(2)：表示当前节点在条件队列中等待。</li><li>PROPAGATE(-3)：用于共享模式下，表示后继节点需要向前传播唤醒信号。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶之并发编程（二）volatile关键字</title>
      <link href="/2023/03/25/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/03/25/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是线程安全的可见性与有序性"><a href="#一、什么是线程安全的可见性与有序性" class="headerlink" title="一、什么是线程安全的可见性与有序性"></a>一、什么是线程安全的可见性与有序性</h3><p>先看如下案例，在该样例中，线程外将stop改为true之后，理论上线程会跳出while循环进而终止，但是实际运行会发现线程依然继续运行，为什么会出现这种情况呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> stop=<span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">               i++;</span><br><span class="line">&#125; </span><br><span class="line">       &#125;);</span><br><span class="line">       t1.start();</span><br><span class="line">       System.out.println(<span class="string">&quot;begin start thread&quot;</span>);</span><br><span class="line">       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       stop=<span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为现代JVM实现（如HotSpot JVM）中的即时编译器会对程序进行代码优化，从而导致对<code>stop</code>变量的读取在循环中只被执行一次，即初始状态下读取到的true，而外部对<code>stop</code>的修改并不能被线程内部的<code>stop</code>所获取到，这就是所谓的<strong>可见性</strong>问题</p><p>想解决上述代码可见性问题，只需要增加一个<code>volatile</code>关键字即可，该关键字可以保证代码的可见性</p><p>那什么是有序性问题呢？看如下案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderingDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        x = <span class="number">42</span>;  <span class="comment">// 写操作</span></span><br><span class="line">        flag = <span class="literal">true</span>;  <span class="comment">// 写操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;  <span class="comment">// 读操作</span></span><br><span class="line">            System.out.println(x);  <span class="comment">// 读操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ReorderingDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReorderingDemo</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        demo.writer();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        demo.reader();</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上述代码中，线程1调用了<code>writer</code>方法，而线程2调用了<code>reader</code>方法。由于没有使用同步机制或者<code>volatile</code>关键字，线程2可能会看到变量<code>flag</code>为<code>true</code>，但是变量<code>x</code>的值还没有被写入，从而导致输出的x值为0</p><p>这是因为在java当中，如果一段代码没有强依赖关系，那么在多线程条件下这些代码可能会被重排序，从而导致并发顺序问题；此外，<code>x = 42</code>并不是一个原子性操作，而是由初始化x为0和将42赋值给x两步组成的，因此多线程条件下可能会先拿到为0的x值，这就是线程的有序性问题</p><h3 id="二、为什么会出现可见性问题"><a href="#二、为什么会出现可见性问题" class="headerlink" title="二、为什么会出现可见性问题"></a>二、为什么会出现可见性问题</h3><h4 id="1-为了性能处理所做的优化"><a href="#1-为了性能处理所做的优化" class="headerlink" title="1.为了性能处理所做的优化"></a>1.为了性能处理所做的优化</h4><p>在整个计算机的发展历程中，除了CPU、内存以及I&#x2F;O设备不断迭代升级来提升计算机处理性能之外， 还有一个非常核心的矛盾点，就是这三者在处理速度的差异。CPU的计算速度是非常快的，其次是内存、最后是IO设备(比如磁盘)，也就是CPU的计算速度远远高于内存以及磁盘设备的I&#x2F;O速度。</p><p>为了平 衡这三者之间的速度差异，最大化的利用CPU。所以在硬件层面、操作系统层面、编译器层面做出了很 多的优化</p><ul><li>CPU增加了高速缓存</li><li>操作系统增加了进程、线程。通过CPU的时间片切换最大化的提升CPU的使用率 </li><li>编译器的指令优化，更合理的去利用好CPU的高速缓存</li></ul><p>每一种优化，都会带来相应的问题，而这些问题是导致线程安全性问题的根源，那接下来我们逐步去了<br>解这些优化的本质和带来的问题。</p><h4 id="2-CPU层面的缓存"><a href="#2-CPU层面的缓存" class="headerlink" title="2.CPU层面的缓存"></a>2.CPU层面的缓存</h4><p>CPU在做计算时，和内存的IO操作是无法避免的，而这个IO过程相对于CPU的计算速度来说是非常耗时，基于这样一个问题，所以在CPU层面设计了高速缓存，这个缓存行可以缓存存储在内存中的数据，CPU每次会先从缓存行中读取需要运算的数据，如果缓存行中不存在该数据，才会从内存中加载，通过这样一个机制可以减少CPU和内存的交互开销从而提升CPU的利用率。</p><p>对于主流的x86平台，cpu的缓存行(cache)分为L1、L2、L3总共3级。</p><p><img src="https://static-2w2.pages.dev/post/levelCache.png" alt="image-20230327011219482"></p><p><strong>1）缓存一致性问题</strong></p><p>CPU高速缓存的出现，虽然提升了CPU的利用率，但是同时也带来了另外一个问题—缓存一致性问题， 这个一致性问题体现在。</p><p>在多线程环境中，当多个线程并行执行加载同一块内存数据时，由于每个CPU都有自己独立的L1、L2缓存，所以每个CPU的这部分缓存空间都会缓存到相同的数据，并且每个CPU执行相关指令时，彼此之间不可见，就会导致缓存的一致性问题。</p><p><strong>2）缓存一致性协议</strong></p><p>为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，常 见的协议有MSI，MESI，MOSI等。最常见的就是MESI协议。接下来简单讲解一下MESI。</p><p><strong>MESI表示缓存行的四种状态，分别是</strong></p><ul><li>M(Modify) 表示共享数据只缓存在当前CPU缓存中，并且是被修改状态，也就是缓存的 数据和主内存中的数据不一致</li><li>E(Exclusive) 表示缓存的独占状态，数据只缓存在当前CPU缓存中，并且没有被修改</li><li>S(Shared) 表示数据可能被多个CPU缓存，并且各个缓存中的数据和主内存数据一致</li><li>I(Invalid) 表示缓存已经失效</li></ul><p>在CPU的缓存行中，每一个Cache一定会处于以下三种状态之一</p><ol><li><strong>Shared状态</strong>：表示该缓存块正在被多个处理器共享。在该状态下，缓存块的副本位于多个处理器的缓存中，这些副本之间的数据应该是相同的，因此任何一个处理器的缓存更改都必须与其他处理器的缓存同步。</li><li><strong>Exclusive状态</strong>：表示该缓存块只存在于当前处理器的缓存中。在这种情况下，当前处理器是唯一可以访问该缓存块的处理器，并且其他处理器无法访问该缓存块。如果其他处理器需要访问该缓存块，则必须先使其从Exclusive状态转换为Shared状态。</li><li><strong>Invalid状态</strong>：表示该缓存块无效或者已经过期，不能被任何处理器使用。当某个处理器修改了一个缓存块的数据时，该缓存块的状态会变为Invalid状态，此时其他处理器需要刷新其缓存中的数据，以确保其缓存中的数据与内存中的数据一致。</li></ol><blockquote><p>即共享，独占和无效</p></blockquote><p>但是，缓存一致性协议情况下依然可能会存在<strong>指令重排序</strong>问题，一般采用<strong>内存屏障</strong>来处理，保证指令有序性与可见性</p><p>也可以使用<strong>缓存锁&#x2F;总线锁</strong>等机制解决</p><h4 id="3-指令重排序问题"><a href="#3-指令重排序问题" class="headerlink" title="3.指令重排序问题"></a>3.指令重排序问题</h4><p><strong>CPU层面</strong>的指令重排序问题是指在现代处理器中，为了提高指令执行效率，处理器内部可能会对指令进行重排序，从而可能导致指令的执行顺序发生变化。这种重排序通常不会影响程序的语义，但是在多线程环境下，如果不加以控制，就可能会导致线程之间的数据竞争和有序性问题。</p><p>比如存在a和b两个普通共享变量，a变量被一个线程修改后，有缓存还没有更新a值，这时候b变量用到了a变量的值，但是读取到了修改前的值，从而导致线程安全问题</p><p><strong>Java层面</strong>的指令重排序问题是指在Java程序中，由于JVM的优化机制和编译器的优化策略，可能会导致程序中的指令执行顺序发生变化。这种重排序通常不会影响单线程程序的语义，但是在多线程环境下，如果不加以控制，就可能会导致线程之间的数据竞争和有序性问题。</p><p>java层面，最常见解决可见性与有序性问题的手段是使用<code>volatile</code>关键字或者加锁</p><p>本质是采用了内存屏障的技术</p><h4 id="4-内存屏障"><a href="#4-内存屏障" class="headerlink" title="4.内存屏障"></a>4.内存屏障</h4><p>内存屏障（Memory Barrier），也叫内存栅栏，是一种CPU硬件提供的指令，用于限制处理器和内存的乱序执行和重排序。内存屏障可以被用来保证指令的执行顺序、控制CPU和内存之间的同步、保证内存可见性等。内存屏障通常分为以下几种：</p><ol><li><strong>Load Barrier</strong>（读屏障）：它保证在读取某个变量的值之前，其它变量的值已经被加载到处理器的缓存中。读屏障确保了程序的有序性和可见性，避免了程序中出现未初始化的变量或无效的数据。</li><li><strong>Store Barrier</strong>（写屏障）：它保证在修改某个变量的值之后，其它变量的值被刷新到内存中。写屏障确保了程序的有序性和可见性，避免了出现脏数据或不一致的数据。</li><li><strong>Full Barrier</strong>（全屏障）：它同时包括了读屏障和写屏障的功能，保证了程序的所有操作都是有序的。全屏障一般比较耗费资源，只在特定情况下使用。</li></ol><p>在Java中，<code>volatile</code>关键字使用的内存屏障主要包括<code>store-store</code>屏障、<code>load-load</code>屏障和<code>store-load</code>屏障，它们合起来构成了一种全屏障的机制。</p><ul><li><code>store-store</code>屏障会保证在该屏障之前的所有<code>store</code>指令都已经完成，确保该屏障之前的所有修改对其他线程可见；</li><li><code>load-load</code>屏障会保证在该屏障之后的所有<code>load</code>指令都能够读取到最新的值，确保该屏障之后的所有读操作都是有效的；</li><li><code>store-load</code>屏障会保证在该屏障之前的所有<code>store</code>指令都已经完成，确保该屏障之前的所有修改对其他线程可见，同时会强制所有之后的<code>load</code>指令重新从内存中读取数据，而不是使用之前的缓存数据，确保该屏障之后的所有读操作都能够读取到最新的值。</li></ul><h3 id="三、JMM模型"><a href="#三、JMM模型" class="headerlink" title="三、JMM模型"></a>三、JMM模型</h3><p>简单来说，<strong>Java内存模型（JMM）定义了多线程程序中，线程之间通过内存进行通信的规则和限制。</strong></p><p>具体的，Java内存模型规定了所有的变量都存储在<strong>主内存</strong>中，每条线程还有自己的<strong>工作内存</strong>，线程的工作内存中保存了这个线程中用到的变量的<strong>主内存副本拷贝</strong>，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。</p><p>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行，流程图如下:</p><img src="https://static-2w2.pages.dev/post/jmm.jpeg" alt="image-20230327011219482" style="zoom: 67%;" /><p>目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重<br>排序、处理器会对代码乱序执行等带来的问题</p><blockquote><p>本地内存是JMM的一个抽象概念，并不真实存在。</p><p>它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p></blockquote><p>上面的可见性与有序性问题主要是通过volatile关键字来解决的，那有哪些情况是，不需要通过增加volatile关键字，也能保证在多线程环境下的可见性和有序性的呢?</p><p>从JDK1.5开始，引入了一个<strong>happens-before</strong>的概念来阐述多个线程操作共享变量的可见性问题。所以我们可以认为在JMM中，如果一个操作执行的结果需要对另一个操作课件，那么这两个操作必须要存在 happens-before关系。这两个操作可以是同一个线程，也可以是不同的线程。</p><h4 id="1-happens-before-规则"><a href="#1-happens-before-规则" class="headerlink" title="1.happens-before 规则"></a>1.happens-before 规则</h4><p>“<strong>happens-before</strong>“ 是 Java 内存模型（JMM）中的一个概念，用来描述多线程程序中各个线程之间操作的先后顺序。</p><p>具体来说，如果操作 A happens-before 操作 B，那么 A 一定在 B 之前执行，且 B 可以看到 A 执行的结果。happens-before 规则定义了一组顺序关系，用来保证多线程程序中的操作顺序，从而确保程序的正确性和可移植性。</p><p>happens-before 规则包括以下几个方面：</p><ol><li><strong>传递性</strong>（Transitivity）规则：如果事件 A 在事件 B 之前发生，事件 B 在事件 C 之前发生，那么事件 A 必须在事件 C 之前发生。</li><li><strong>volatile</strong> 变量规则：如果一个线程先写一个 volatile 变量，然后另一个线程读取该变量，那么这个写操作将 happen-before 于这个读操作。</li><li><strong>监视器锁</strong>规则：如果一个线程获得了一个监视器锁并释放了它，那么这个获得操作将 happen-before 于这个释放操作。</li><li><strong>start</strong> 规则：如果线程 A 启动线程 B，那么线程 A 的 start 操作将 happen-before 于线程 B 的任意操作。</li><li><strong>join</strong> 规则：如果线程 A 等待线程 B 结束，那么线程 B 的任意操作都将 happen-before 于线程 A 的 join 操作返回。</li></ol><h4 id="2-as-if-serial"><a href="#2-as-if-serial" class="headerlink" title="2.as-if-serial"></a>2.as-if-serial</h4><p>“as-if-serial” 是指，虚拟机可以对指令进行重排序，只要重排序后的执行结果与原来的执行结果一致，就可以保证程序的正确性。换句话说，虚拟机可以将指令序列中无关联的操作进行并行执行，只要保证最终的结果与串行执行的结果一致即可。</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶之并发编程（一）synchronized关键字</title>
      <link href="/2023/03/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/03/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="并发编程基础篇"><a href="#并发编程基础篇" class="headerlink" title="并发编程基础篇"></a>并发编程基础篇</h2><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><ol><li><strong>QPS</strong>（Queries Per Second）：每秒查询率，指的是一个系统或服务在一秒内能够处理的查询次数。例如，如果一个网站每秒钟能够处理100个请求，那么它的QPS为100。</li><li><strong>TPS</strong>（Transactions Per Second）：每秒事务数，指的是一个系统或服务在一秒内能够完成的事务数。一个事务通常指的是一组相关的操作，例如在数据库中执行一次读写操作。TPS是一个系统的性能指标之一，可以用来衡量系统的稳定性和响应能力。</li><li><strong>CPU</strong>（Central Processing Unit，中央处理器）：CPU是计算机的核心部件，它负责执行计算机指令。在并发编程中，CPU的主要限制是它的计算能力，它能够处理的任务数量受到CPU核心数、频率和指令集等因素的影响。为了充分利用CPU的性能，可以采用多线程、异步编程等方式来并发执行任务。</li><li><strong>内存</strong>（Memory）：内存是计算机中用于存储数据和程序的临时存储器，它的容量和速度对并发编程也有很大的影响。如果程序需要频繁地读写内存，那么内存的带宽和延迟就会成为瓶颈。为了减少内存的使用，可以采用一些优化策略，如对象池、缓存等方式。</li><li><strong>磁盘</strong>（Disk）：磁盘是计算机用于存储数据的永久性存储器，它的容量和速度也会对并发编程造成影响。磁盘的读写速度相对于内存来说较慢，因此频繁地进行磁盘读写会成为程序的瓶颈。为了优化磁盘的使用，可以采用一些策略，如异步I&#x2F;O、缓存、压缩等方式。</li><li><strong>网卡</strong>（Network Interface Card）：网卡是计算机用于连接网络的接口，它的带宽和延迟对网络通信的性能有很大的影响。在并发编程中，网络通信是一种常见的场景，因此优化网络通信的性能非常重要。可以采用一些策略，如连接池、异步I&#x2F;O、压缩等方式来优化网络通信的性能。</li><li><strong>I&#x2F;O</strong>（Input&#x2F;Output）是计算机系统中，用于实现计算机与外部设备交互的操作。在并发编程中，I&#x2F;O操作的限制主要包括磁盘、网络和数据库等方面的性能瓶颈。磁盘的读写速度相对于内存来说较慢，因此频繁进行磁盘读写会成为程序的瓶颈。网络通信的带宽和延迟也会影响I&#x2F;O操作的性能，需要采用一些策略来优化，如使用缓存、压缩、连接池等方式。在使用数据库时，频繁进行数据库的读写操作也会成为系统的瓶颈，需要采用一些策略来优化，如使用数据库连接池、使用索引等。</li></ol><blockquote><p>此外，在并发编程之中，进程和线程的概念是必须熟练掌握的</p></blockquote><ul><li><p>进程是指一个程序的运行实例，它拥有自己的地址空间、文件描述符、环境变量、堆栈等资源，是操作系统进行资源分配和调度的基本单位。</p></li><li><p>线程是进程内的一个执行单元，一个进程可以包含多个线程，线程共享进程的地址空间和资源，但是每个线程都有自己的堆栈和寄存器，可以独立执行。线程的并发性相对于进程更高，可以更好地利用计算机的多核处理器，提高程序的性能。</p></li></ul><p><strong>区别：</strong></p><ol><li>进程是操作系统资源分配的基本单位，线程是进程的执行单元，进程可以包含多个线程。</li><li>进程拥有自己的地址空间、文件描述符、环境变量等资源，而线程共享进程的地址空间和资源。</li><li>进程之间相互独立，线程之间共享进程的资源。</li><li>进程切换需要保存当前进程的状态和上下文，开销较大，线程切换开销较小，切换速度更快。</li><li>进程通信需要使用进程间通信机制，如管道、消息队列、共享内存等，线程之间可以直接共享数据。</li></ol><p>总的来说，进程和线程都是用于实现多任务的机制，但是它们的性质和使用方式不同，应该根据具体情况选择适合的机制来实现多任务。</p><h3 id="二、线程相关"><a href="#二、线程相关" class="headerlink" title="二、线程相关"></a>二、线程相关</h3><h4 id="1-线程生命周期"><a href="#1-线程生命周期" class="headerlink" title="1.线程生命周期"></a>1.线程生命周期</h4><p>线程的生命周期可以被分为五个不同的阶段：创建、就绪、运行、阻塞和终止。</p><ol><li>创建阶段：线程被创建，分配了必要的系统资源，但还未开始运行。</li><li>就绪阶段：线程已经准备好运行，但还未被CPU调度执行。</li><li>运行阶段：CPU选择了一个就绪状态的线程，将其放入运行状态，并执行线程的run()方法。</li><li>阻塞阶段：线程进入了一个阻塞状态，例如等待某个事件发生或者等待输入输出操作完成。</li><li>终止阶段：线程执行完了run()方法或者抛出了一个未被捕获的异常，或者被强制中断，线程将进入终止状态。</li></ol><blockquote><p>需要注意的是，在java代码当中，线程具有六个状态，和线程生命周期并不完全匹配</p><p>NEW 新建,RUNNABLE 就绪,BLOCKED 阻塞,WAITING 等待,TIMED_WAITING 时间等待,TERMINATED 终止</p></blockquote><p>不同状态之间的转换可以由以下事件触发：</p><ol><li>创建状态转换为就绪状态：当线程被创建并分配了系统资源之后，它就进入了就绪状态。这个状态转换是自动发生的。</li><li>就绪状态转换为运行状态：当线程被操作系统的调度器选择并分配了CPU资源后，线程进入运行状态。</li><li>运行状态转换为阻塞状态：当线程在执行过程中遇到了阻塞事件（如等待输入&#x2F;输出操作完成、等待某个锁等待等），线程会被挂起，进入阻塞状态。</li><li>阻塞状态转换为就绪状态：当线程被阻塞的原因消除后（如输入&#x2F;输出操作完成或某个锁被释放），线程就会转换为就绪状态，等待操作系统调度器重新分配CPU资源。</li><li>运行状态转换为终止状态：当线程执行完了run()方法或抛出了未被捕获的异常或被强制中断时，线程就会进入终止状态。</li></ol><h4 id="2-实现线程的方法"><a href="#2-实现线程的方法" class="headerlink" title="2.实现线程的方法"></a>2.实现线程的方法</h4><p>1.继承Thread类</p><p>2.实现Runnable接口</p><p>3.实现Callable接口</p><p>4.使用线程池ThreadPoolExecutor</p><h4 id="3-线程中断"><a href="#3-线程中断" class="headerlink" title="3.线程中断"></a>3.线程中断</h4><blockquote><p>线程可以使用stop()来中断，但是这种方法会不论当前线程状态直接将线程中断掉，容易造成未知影响，已经逐渐废弃</p></blockquote><p>更普遍的，可以使用interrupt()方法来中断线程，相当于给正在运行的线程发送了一个信号，通知线程可以中断了，可以用isInterrupted()方法来判断是否启用了线程中断，如果处于中断命令状态，用户可以执行相应操作</p><p>需要注意的是，如果线程内run使用类似如下语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!Thread.currentThread.isInterrupted())&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下在线程外调用interrupt()方法是可以将线程正常中断掉的，而这种状态下的中断其实和使用volatile声明一个共享变量来做线程通信的原理是相似的</p><p><code>interrupt()</code>方法并不会直接中断一个正在运行状态的线程，而是将中断标志位设置为<strong>true</strong>，在线程内可以通过对中断标志位的判断，来决定何时中断当前线程，此外，<code>interrupt()</code>方法对不同状态的线程影响不同：</p><ol><li>如果线程处于运行状态，那么中断标志位将被设置为<code>true</code>，但线程并不会立即停止执行，而是可以通过对中断标志位的检查来决定是否停止执行。</li><li>如果线程处于阻塞状态，那么调用<code>interrupt()</code>方法会立即抛出<code>InterruptedException</code>异常，这样可以提前结束线程的阻塞状态并抛出异常，从而使线程退出阻塞状态继续执行。</li><li>如果线程处于等待状态，例如调用了<code>Object.wait()</code>方法或<code>Thread.join()</code>方法等待其他线程的通知或执行完成，那么调用<code>interrupt()</code>方法也会立即抛出<code>InterruptedException</code>异常，从而使线程退出等待状态继续执行。</li><li>如果线程处于新建状态或者已经终止，那么调用<code>interrupt()</code>方法不会有任何效果，中断标志位会被设置为<code>true</code>，但线程并不会中断执行。</li></ol><blockquote><p>需要注意的是，抛出<code>InterruptedException</code>异常之后，运行线程会将中断标志位重新置为<code>false</code>，即退出了中断状态，为什么这样设计呢？</p><p>这种设计主要是为了线程安全性考虑，当某个线程中断标志位设置为<code>true</code>之后，如果其他线程来获取这个线程状态，会获得<code>true</code>结果，但是这个线程其实并不是在中断标志位被设置为<code>true</code>后就立即进入中断状态了，它可能还会有一些自己的处理，因此需要将中断标志位重置。同时，这也是将中断交给用户来处理的一个操作，使得用户可以更加灵活的处理中断情况，而如果用户想真的中断这个线程时，可以在run内部调用<code>Thread.currentThread().interrupt()</code>来实现线程真正的中断。</p></blockquote><p>如下所示，就是一个调用<code>interrupt()</code>后能抛出<code>InterruptedException</code>异常的run内写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!Thread.currentThread.isInterrupted())&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(InterruptException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-cpu飙升问题排查"><a href="#4-cpu飙升问题排查" class="headerlink" title="4.cpu飙升问题排查"></a>4.cpu飙升问题排查</h4><p>当CPU飙升时，可能是因为某个进程或线程在消耗大量的CPU资源，导致CPU使用率过高。要解决这个问题，可以通过以下步骤进行排查：</p><ol><li>查看系统负载：可以通过命令<code>top</code>或<code>htop</code>来查看系统的负载情况，包括CPU使用率、内存使用率、进程数量等信息。如果CPU使用率很高，可以查看哪些进程或线程占用了大量的CPU资源。</li><li>查看进程信息：可以通过命令<code>ps</code>或<code>pidstat</code>来查看进程的详细信息，包括进程ID、CPU使用率、内存使用率、线程数量等信息。可以根据进程ID定位到具体的进程，并查看其线程的详细信息。<strong>（top命令看进程信息，找到占用cpu过高的进程）</strong></li><li>分析线程堆栈信息：可以通过工具如jstack、jvisualvm等来获取线程堆栈信息，从而了解线程的执行情况。通过分析线程堆栈信息，可以确定哪些线程占用了大量的CPU资源，并查找问题所在。<strong>（jstack查看线程信息，找到占用cpu过高的线程）</strong></li><li>分析代码：根据线程堆栈信息，可以定位到具体的代码位置，进一步分析代码的执行情况。如果是某个代码块或方法导致CPU使用率过高，可以考虑对其进行优化或改进。<strong>（根据dump文件，使用jmap分析是否有死锁，内存泄漏等问题，定位到对应代码块）</strong></li><li>调整系统参数：如果以上步骤都无法解决问题，可以考虑调整系统参数，例如增加CPU数量、增加内存容量、调整线程池大小等，以提高系统性能。</li></ol><p>需要注意的是，CPU飙升问题可能有多种原因，可能是代码问题，也可能是系统配置问题。在排查问题时，需要综合考虑各种因素，并根据具体情况采取相应的措施。</p><blockquote><p>注意，死锁不一定会导致CPU飙升</p><p>首先分析会导致CPU飙升的死锁，这种情况就是多个进程存在死锁，然后不断重试去尝试获取资源，从而导致占用大量CPU资源，导致CPU使用率飙升</p><p>那么不会使CPU飙升的死锁是什么样的呢？考虑以下场景</p><ul><li>进程A获取了锁1，正在等待锁2</li><li>进程B获取了锁2，正在等待锁1</li></ul><p>在这种情况下，A和B进程都进入了阻塞状态，这种状态是不会对CPU资源进行占用的，但是这种死锁不释放也会对资源进行占用，需要及时发现并处理。</p></blockquote><h3 id="三、并发编程之同步锁"><a href="#三、并发编程之同步锁" class="headerlink" title="三、并发编程之同步锁"></a>三、并发编程之同步锁</h3><h4 id="1-synchronized关键字"><a href="#1-synchronized关键字" class="headerlink" title="1.synchronized关键字"></a>1.synchronized关键字</h4><p>synchronized关键字只能作用于<strong>代码块</strong>或者<strong>方法</strong>，并不能直接作用于变量，但是可以声明一个对象放在sychronized锁住代码块的小括号里，作为共享对象进行并发控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时引出了另一个问题，sychronized关键字都可以怎么使用？不同方法锁住的都是什么？</p><ul><li>锁在普通方法上：这种情况下，sychronized锁住的就是当前实例对象本身，也就是this</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>锁在静态方法上：这种情况下，锁对象通常是类对象，也就是说，锁住的是当前类对象的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>锁在代码块上：这种情况下，锁对象可以是任何的Java对象，通常是使用一个专门声明的私有final对象，防止其他对象意外使用该对象导致竞争发生</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，锁的也可以是ClassName.class形式的对象，表示对这个类加了锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (ClassName.class) &#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么叫对类进行加锁呢？</p><p>在JVM当中，每个类在其中都有一个对应的Class对象，这个Class对象是全局唯一的，因此当使用synchronized关键字对类进行加锁时，类所有实例对象的静态变量和静态方法也都是被锁住的，但是对于这个类的实例来说，非静态方法与变量是可以被其他线程正常访问的；所以类锁其实只会锁住一个类的静态方法与静态变量；</p><p>类锁控制的资源范围更大，锁的粒度也更大，可以保证多线程条件下类的静态资源的并发安全性，经典的用例便是单例模式的双重校验锁中对单例类的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// private constructor</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了一个 <code>volatile</code> 关键字来保证在多线程环境下，instance 变量的可见性和有序性，为什么要使用它呢？</p><p>如果没有使用 volatile 关键字，可能会出现以下问题：</p><ol><li>线程 A 进入双重校验锁，执行第一个步骤，此时实例还未被创建，然后线程 B 也进入双重校验锁。</li><li>线程 B 获取到锁，执行第一个步骤，此时实例还未被创建，然后线程 A 获取到锁，执行第二个步骤，创建实例。</li><li>线程 B 继续执行第二个步骤，创建另一个实例，并返回。</li></ol><p>因为指令重排序的原因，线程 B 可能会在实例还未被创建的时候获取到锁，并返回一个未完成初始化的实例。如果其他线程使用这个实例，可能会导致程序出错。</p><blockquote><p>双重校验锁实现的单例并不完美，具体问题与优化可以参考<a href="https://yzj.life/2023/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Java进阶之设计模式</a>中的单例模式介绍</p></blockquote><h4 id="2-抢占锁的本质是什么"><a href="#2-抢占锁的本质是什么" class="headerlink" title="2.抢占锁的本质是什么"></a>2.抢占锁的本质是什么</h4><p>抢占锁是指多个线程竞争同一把锁时，其中一个线程成功获得了锁并持有锁的情况下，其他线程将被阻塞，无法进入临界区进行操作，只有等到锁被释放后才能继续竞争锁并进入临界区。</p><p>抢占锁的本质是通过锁来保证多个线程对共享资源的访问是互斥的，从而保证了线程安全。当一个线程获取锁时，它会进入临界区，执行相关操作，直到完成后才会释放锁。其他线程在没有获得锁之前，无法进入临界区，从而避免了多个线程同时对共享资源进行修改而导致的数据不一致问题。</p><h4 id="3-MarkWord对象头"><a href="#3-MarkWord对象头" class="headerlink" title="3.MarkWord对象头"></a>3.MarkWord对象头</h4><p>在Java对象头中，用于表示锁状态的部分称为mark word（标记字段）。mark word通常包含了三种信息：</p><ul><li>对象的hashCode值</li><li>对象的分代年龄</li><li>锁状态</li></ul><p>其中，锁状态一般使用2bit位来表示，但是在无锁或者偏向锁时，会用3bit位来表示锁状态</p><ul><li>0 01表示无锁状态</li><li>1 01表示是偏向锁状态</li><li>00表示是轻量级锁状态</li><li>10表示是重量级锁状态</li><li>11则是用到的GC标志</li></ul><p>mark word的指针并不是一直不变的，在不同的锁状态下指向不同的对象，用于实现不同需求</p><ul><li>在偏向锁状态下，mark word的指针指向线程ID，用于记录哪个线程拥有该对象。</li><li>在轻量级锁状态下，mark word的指针指向锁记录的地址，锁记录用于存储锁定对象的线程ID和锁的状态信息。</li><li>在重量级锁状态下，mark word的指针指向重量级锁的互斥量。</li></ul><p>下面分别介绍这几种锁</p><blockquote><p>在jdk6之后才对sychronized进行了细化区分，在5和之前都是用的重量级锁</p></blockquote><p><strong>1.偏向锁</strong></p><p>偏向锁的核心思想是，如果一个线程获得了对象的锁，那么在之后的执行中，该线程就可以直接进入临界区，而不用再次获取锁了。偏向锁可以消除大量的同步操作，因为大部分情况下，锁总是由同一个线程多次获得的。如果加入了偏向锁，当这个线程再次进入临界区时，就不用再去尝试获取锁，因为锁已经被偏向该线程了。</p><blockquote><p>注意，并不是说一个线程拿到某一对象置为偏向锁后，这个对象的偏向锁就只能是该线程了，偏向锁存在一个偏向锁撤销的可能，偏向锁撤销可能会升级成轻量级锁，也可能重新变成无锁状态，由以下状态情况触发回到无锁状态</p><ul><li>使用-XX:BiasedLockingStartupDelay参数设置了偏向锁持有时间，到达时间后偏向锁会被撤销</li><li>在并发标记过程中，遇到了安全点，会暂停所有线程，并且把对象头中的偏向锁撤销</li></ul><p>其他一些情况不再细谈，撤销偏向锁其实是一个比较耗费资源的操作，所以有时候jvm会直接把对象设置为“不可偏向”状态，此时再有线程过来尝试获取锁直接升级为轻量级锁</p></blockquote><p><strong>2.轻量级锁</strong></p><p>当一个线程尝试获取一个有偏向锁的对象时，如果这个对象的偏向锁标识符与线程的标识符不同，说明有另一个线程已经竞争这个锁了，那么就会将偏向锁升级为轻量级锁，并使用CAS操作来竞争锁。所以，一般情况下，偏向锁升级为轻量级锁是在第二个线程尝试获取锁时发生的。</p><p>轻量级锁适合使用在有<strong>多个线程在不同时刻</strong>轮流获取锁的情况，如果竞争较为激烈，重量级锁的性能表现会更好</p><p>轻量级锁采用CAS机制来尝试获取锁，如果获取锁失败则会自旋尝试再次获取锁，默认会在10次获取失败后升级成重量级锁，但是这个参数可用通过JVM参数控制</p><p><strong>3.重量级锁</strong></p><p><code>synchronized</code> 的重量级锁是指当竞争激烈时，锁会升级为重量级锁（也叫监视器锁）。在重量级锁的实现中，会使用操作系统的<strong>互斥量</strong>来实现锁，因此在争用同步资源时会发生<strong>内核态与用户态</strong>之间的切换，这种切换的代价比较高，因此重量级锁在性能方面比较差，适合用于保护竞争激烈的共享资源。</p><p>那么操作系统的互斥量是指的什么呢？重量级锁又是如何实现的呢？</p><p>简单来说，Java虚拟机通过对对象的监视器（<code>monitor</code>）进行操作，来达到对对象的加锁和解锁目的</p><p><code>monitorenter</code> 和 <code>monitorexit</code> 是 Java 虚拟机的两条指令，当 JVM 执行 <code>monitorenter</code> 指令时，会先判断对象的 <code>monitor</code> 是否处于无锁状态，如果是，就将 <code>monitor</code> 设置为当前线程持有，并将锁的计数器加1。如果 monitor 已经被当前线程持有，就直接将计数器加1即可，这样可以重入锁。如果 <code>monitor</code> 已经被其他线程持有，则当前线程就会进入阻塞状态，直到 <code>monitor</code> 变为可用。</p><p>当 JVM 执行 <code>monitorexit</code> 指令时，会先判断当前线程是否持有 <code>monitor</code>，如果是，就将 <code>monitor</code> 的计数器减1。如果计数器减为0，说明该线程已经释放了 <code>monitor</code>，可以将 <code>monitor</code> 设置为无锁状态，并唤醒等待在 <code>monitor</code> 上的其他线程。</p><blockquote><p>本质上就是JVM通过对<code>monitor</code>的状态进行操作，来进行加锁和解锁，那么更进一步了解，<code>monitor</code>又是如何实现的呢？</p><p><code>monitor</code> 是一种同步原语，用于实现互斥锁等同步操作。<code>monitor</code> 可以看作是一种抽象的概念，实际上是通过操作系统的互斥量（mutex）来实现的。</p><p><strong>mutex enter</strong>和<strong>mutex exit</strong>就是操作系统中用于实现互斥量的原语。</p></blockquote><h3 id="四、CAS机制"><a href="#四、CAS机制" class="headerlink" title="四、CAS机制"></a>四、CAS机制</h3><p><strong>1.简介</strong></p><p>CAS（Compare And Swap）是一种基于原子性操作的并发编程技术，主要用于多线程环境下的共享变量的操作，可以保证线程安全。</p><p>在CAS操作中，主要包含三个参数：内存地址V、旧的预期值A和新的值B。操作步骤如下：</p><ol><li>读取V的当前值，记为A。</li><li>判断A是否等于预期值，如果相等，则执行步骤3，否则不执行。</li><li>将V的值设置为新值B，如果操作成功，则返回true，否则返回false。</li></ol><p>CAS操作通过比较内存地址V中的旧值A与预期值是否相等来判断是否执行更新操作，如果相等，则将新值B写入到内存地址V中，如果不相等，则不执行更新操作。在更新操作期间，如果其他线程修改了内存地址V中的值，那么CAS操作会失败，需要重新尝试执行CAS操作。</p><p>在java中使用<code>unsafe.compareAndSwapXXX</code>方法来实现cas操作，传递四个值，两个是用来对内存地址定位，相当于内存地址V</p><p><strong>2.ABA问题</strong></p><p>CAS操作存在ABA问题，即如果一个值由A变为B，又变回A，那么CAS操作就可能认为这个值没有变化，从而可能产生问题。为了解决ABA问题，Java提供了AtomicStampedReference类和AtomicMarkableReference类。</p><blockquote><p>AtomicStampedReference使用一个整数类型的stamp（可以理解为版本号）来记录对象被修改的次数。在执行CAS操作时，除了比较对象是否相同，还需要比较版本号是否相同，从而确保不会出现ABA问题。</p><p>AtomicMarkableReference则是使用一个boolean类型的标记位来记录对象是否被修改过。在执行CAS操作时，除了比较对象是否相同，还需要比较标记位是否相同，从而确保不会出现ABA问题。</p></blockquote><p><strong>3.CAS如何实现并发安全</strong></p><p>在单CPU情况下，CAS利用来硬件的原子性指令，将比较与交换同时完成，因此可以保证执行的原子性，从而保证了并发安全</p><p>在多CPU的情况下，单个CPU的原子性指令并不能保证夸CPU实现原子性，因此在多CPU的情况下，底层实际上是加了一个LOCK锁，可以称为缓存锁或总线锁，因此本质还是使用锁来保证的原子性</p><p>关于总线锁，后面会再展开篇幅进行介绍</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶之设计模式</title>
      <link href="/2023/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="一、设计原则"><a href="#一、设计原则" class="headerlink" title="一、设计原则"></a>一、设计原则</h3><h4 id="1-接口隔离原则"><a href="#1-接口隔离原则" class="headerlink" title="1.接口隔离原则"></a>1.接口隔离原则</h4><p><strong>核心思想：</strong>将接口拆分成多个小的、专门的接口，避免大而全的接口导致实现类必须实现无用的方法，从而提高代码的灵活性、可扩展性和可维护性。</p><p>解析：即接口要分割的足够小，功能尽量高内聚，不要太多冗余方法</p><p>以下是一个满足接口隔离原则的<strong>正例</strong>。假设我们有一个图形类<code>Shape</code>，它有一个计算面积的方法<code>calculateArea()</code>和一个计算周长的方法<code>calculatePerimeter()</code>。我们可以将这两个方法拆分成两个接口<code>AreaCalculatable</code>和<code>PerimeterCalculatable</code>，然后让实现<code>Shape</code>类的类只实现它们需要的接口。这个设计可以避免实现一个不需要的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AreaCalculatable</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PerimeterCalculatable</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculatePerimeter</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">AreaCalculatable</span>, PerimeterCalculatable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">double</span> width, <span class="type">double</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculatePerimeter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (width + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>反例</strong>，假设有一个动物接口，它定义了一系列方法，包括吃、喝、跑和飞等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drink</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而实际上，一个动物很可能并不具有所有的这些能力，比如企鹅不会飞，老鹰也不一定会游泳，这里违背了接口隔离原则，需要接口功能更加细化</p><h4 id="2-迪米特法则"><a href="#2-迪米特法则" class="headerlink" title="2.迪米特法则"></a>2.迪米特法则</h4><p><strong>核心思想：</strong>也叫作最少知识原则（Least Knowledge Principle，LKP），是一种面向对象设计原则，它要求一个对象应当对其他对象有<strong>尽可能少</strong>的了解，也就是说一个对象应当尽可能少地与其他对象发生相互作用。迪米特法则的核心思想是“不和陌生人说话”，它的目的是降低类之间的耦合度，从而提高系统的灵活性和可维护性。</p><p><strong>解析：</strong>主要是为了降低类之间的耦合度，便于后期维护与阅读，同时满足高内聚低耦合的设计思想，具体优点如下</p><ul><li>降低耦合度：迪米特法则可以降低类之间的耦合度，避免不必要的依赖关系，从而提高系统的灵活性和可维护性。</li><li>提高可重用性：迪米特法则可以将类的内部实现和外部接口进行分离，使得类的实现更加独立和可重用。</li><li>易于测试：迪米特法则可以降低类之间的依赖关系，使得单元测试更加容易进行。</li><li>易于扩展：迪米特法则可以降低类之间的耦合度，使得系统更加容易扩展和维护。</li></ul><p>下面是一个违反迪米特法则的反例。假设有一个电视类，它需要调用遥控器类的turnOn和turnOff方法来控制电视的开关状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RemoteControl remoteControl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TV</span><span class="params">(RemoteControl remoteControl)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.remoteControl = remoteControl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOn</span><span class="params">()</span> &#123;</span><br><span class="line">        remoteControl.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOff</span><span class="params">()</span> &#123;</span><br><span class="line">        remoteControl.turnOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Remote control is turning on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Remote control is turning off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个设计看起来很简单，但是如果在实际应用中，遥控器类还包含其他方法，比如换台、调音量等，而电视类只需要控制开关状态，这时候就违反了迪米特法则。因为电视类并不需要知道遥控器类的所有方法，但是它的构造函数却依赖于遥控器类的实例，这就增加了类之间的耦合度，使得系统更加脆弱和难以维护。</p><p>一个更好的设计是将电视类与遥控器类解耦，电视类只需要定义自己的方法，而遥控器类也只需要定义自己的方法，两者之间通过一个控制器类来进行连接</p><h4 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="3.里氏替换原则"></a>3.里氏替换原则</h4><p><strong>核心思想：</strong>是面向对象设计的一个重要原则，由Barbara Liskov和Jeannette Wing提出。该原则指出，任何基类可以出现的地方，子类一定可以出现，且替换后程序不会出错。</p><p><strong>解析：</strong>里氏替换原则的使用场景包括</p><ul><li>多态场景：在多态场景中，一个方法可以接受基类的实例，但实际上会传入子类的实例，这时就需要保证子类能够替换基类，不影响程序的正确性。</li><li>继承场景：在继承场景中，子类继承了父类的属性和方法，但子类还可以增加自己的属性和方法，这时需要保证子类与父类的替换性，不破坏原有的逻辑。</li><li>接口场景：在接口场景中，一个类实现了一个接口，就需要保证它的子类也能够实现这个接口，保证替换性和扩展性。</li></ul><p>实际的使用案例，如集合框架中，List是一个接口，ArrayList和LinkedList是它的两个实现类。由于它们都实现了List接口，所以在使用List的地方，可以用ArrayList或者LinkedList来代替。这里就保证了子类的替换性。</p><p>在Spring框架的AOP（面向切面编程）中，切面（Aspect）需要实现Advice接口，Spring提供了很多Advice的实现类，例如BeforeAdvice、AfterAdvice、AroundAdvice等等。用户可以根据自己的需要来选择实现哪个Advice接口，然后把它作为切面的一部分来使用，这里也保证了子类的替换性和扩展性。</p><h4 id="4-合成复用原则"><a href="#4-合成复用原则" class="headerlink" title="4.合成复用原则"></a>4.合成复用原则</h4><p><strong>核心思想：</strong>是面向对象设计的一个重要原则，它强调要优先使用对象组合（Composition）和聚合（Aggregation）关系来复用代码，而不是通过继承关系来复用代码。</p><p><strong>解析：</strong>该原则的基本思想是，在设计时要优先考虑对象的<strong>组合关系</strong>，<strong>而不是继承关系</strong>，通过将多个对象组合在一起来实现功能的复用。这种方法比继承更加灵活、可靠，同时也减少了代码的耦合度，提高了代码的可维护性和可扩展性。</p><p>假设有一个汽车类（Car），它有多个组成部分，例如引擎（Engine）、车轮（Wheel）等等。我们可以使用合成复用原则来实现汽车类的设计，将组成部分作为汽车的属性来组合起来，而不是通过继承来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line">    <span class="keyword">private</span> Wheel[] wheels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;</span><br><span class="line">        engine = <span class="keyword">new</span> <span class="title class_">Engine</span>();</span><br><span class="line">        wheels = <span class="keyword">new</span> <span class="title class_">Wheel</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            wheels[i] = <span class="keyword">new</span> <span class="title class_">Wheel</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Wheel wheel : wheels) &#123;</span><br><span class="line">            wheel.rotate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Engine start.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Engine stop.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wheel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Wheel rotate.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-开闭原则"><a href="#5-开闭原则" class="headerlink" title="5.开闭原则"></a>5.开闭原则</h4><p><strong>核心思想：</strong>一个软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着，当需要对一个软件实体进行改动时，应该尽量通过扩展来实现新功能，而不是通过修改已有的代码来实现。</p><p><strong>解析：</strong>开闭原则是java里面经常提到的设计原则，简单来说就是对扩展开放，对修改关闭。当我们需要新增或者修改功能时，尽量使用新的类或方法去实现新功能，而不是在已存在的类上去修改，因为这样会导致系统稳定性变差，并且容易造成功能冗余，新的修改也不确定会不会造成新的问题，降低软件风险。</p><p>策略模式就是符合开闭原则的很好实现，它是一种行为型设计模式，它定义了一系列算法，将每个算法都封装起来，并且使它们之间可以互换。通过使用策略模式，可以在运行时动态地选择算法，而不需要在代码中显式地指定。这样，当需要添加新的算法时，只需要编写新的策略类并且注册到上下文中即可，而不需要修改原有的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> <span class="keyword">implements</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 冒泡排序算法的具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> <span class="keyword">implements</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 快速排序算法的具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SortStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(SortStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        strategy.sort(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-依赖倒置原则"><a href="#6-依赖倒置原则" class="headerlink" title="6..依赖倒置原则"></a>6..依赖倒置原则</h4><p><strong>核心思想：</strong>依赖倒置原则（Dependency Inversion Principle，DIP）是面向对象设计中的一个重要原则，它提倡高层模块不应该依赖低层模块，二者都应该依赖于抽象接口。同时，抽象接口不应该依赖于具体实现，具体实现应该依赖于抽象接口。这个原则可以简单地表述为“依赖于抽象而不是具体实现”。</p><p><strong>解析：</strong>依赖倒置原则核心就在“<strong>依赖于抽象而不是具体实现</strong>”这句话上，依赖于抽象的设计有助于简历松耦合的模块关系，从而使系统更容易扩展、修改和维护。同时，在使用依赖倒置原则的时候，我们可以更容易地进行模块的替换，例如我们可以通过更换实现某个接口的具体类来实现模块的替换，而不需要修改其他模块的代码。</p><p>下面来看一下不使用依赖倒置原则和使用依赖倒置原则来优化的案例，假设我们有一个图形库，其中包括三个类：Circle、Rectangle和Graphics，它们的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a rectangle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graphics</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        circle.draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个图形库中，我们有两个具体的形状类：Circle和Rectangle，它们都有一个draw()方法来绘制它们的形状。我们还有一个Graphics类，它负责绘制图形。</p><p>Graphics类直接依赖于Circle和Rectangle类，因为它在它的方法中创建了一个Circle和Rectangle对象来进行绘制。</p><p>现在，我们将应用依赖倒置原则，通过引入抽象接口来解耦Graphics类和具体形状类之间的依赖关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Darw</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Darw</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a rectangle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graphics</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Draw</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        circle.draw();</span><br><span class="line">    </span><br><span class="line">        <span class="type">Draw</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-单一职责原则"><a href="#7-单一职责原则" class="headerlink" title="7.单一职责原则"></a>7.单一职责原则</h4><p><strong>核心思想：</strong>单一职责原则是一种设计模式，它建议将一个类或者函数的职责限制在一个单一的领域或者任务上。简而言之，一个类或者函数只应该有一个改变的理由。</p><p><strong>解析：</strong>单一职责原则猛一看和接口隔离原则有些相似，下面对比下两种原则的相似与不同之处</p><p>相似之处：</p><ul><li>都是为了提高代码的可维护性、可读性和可扩展性。</li><li>都要求将职责限制在一个单一的领域或者任务上。</li></ul><p>不同之处：</p><ul><li>单一职责原则注重的是职责的单一性，即一个类或者函数只应该有一个职责，而接口隔离原则注重的是接口的独立性，即接口应该只包含客户端所需的方法。</li><li>单一职责原则针对的是<strong>类或者函数</strong>的设计，而接口隔离原则针对的是<strong>接口</strong>的设计。</li><li>单一职责原则更多地<strong>关注代码内部</strong>的组织和设计，而接口隔离原则更多地<strong>关注代码之间</strong>的交互和通信。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRadius</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCircumference</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * Math.PI * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码示例中，<code>Circle</code> 类只有一个职责，即表示一个圆形，提供圆形半径、圆形面积和周长的获取方法。该类的职责是单一的，没有包含其他不相关的逻辑或功能。</p><h4 id="设计原则小结"><a href="#设计原则小结" class="headerlink" title="设计原则小结"></a>设计原则小结</h4><p>通过上面的详解，可以发现这些设计模式原则，核心思想就是为了使得系统实现高内聚、低耦合的状态，尽量减少各模块之间耦合的同时提高系统的可维护性，可扩展性；</p><p>设计模式只是一种思想，并不是说在写代码时要完全符合设计模式原则去做才行，很多情况下我们写出来的代码并不是那么符合设计模式原则，这就是在业务实现上的一种取舍，就像mysql数据库表设计的时候经常会出现一些反范式设计的情况，具体如何去做还要看实际情况。</p><p>设计模式（原则）只是帮助我们将代码写的更加灵活规范，但是过于追求符合设计模式也会导致出现新的问题，比如适配器模式过渡使用，就会导致出现大量类，使得代码可读性变差，类关系也变得更加复杂，系统性能也有可能会被影响，因此设计模式要在实际项目中灵活使用。</p><h3 id="二、设计模式"><a href="#二、设计模式" class="headerlink" title="二、设计模式"></a>二、设计模式</h3><h4 id="1-简单工厂类（不属于23种设计模式之一）"><a href="#1-简单工厂类（不属于23种设计模式之一）" class="headerlink" title="1.简单工厂类（不属于23种设计模式之一）"></a>1.简单工厂类（不属于23种设计模式之一）</h4><p><strong>适用场景：</strong>工厂类负责创建的对象较少</p><blockquote><p>客户端只需要传入工厂类的参数对于如何创建对象的逻辑不需要关心</p></blockquote><p><strong>缺点：</strong>工厂类的职责相对过重，增加新的产品时需要修改工厂类的判断逻辑，违背开闭原则。不易于扩展过于复杂的产品结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">createCar</span><span class="params">(String carType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (carType.equalsIgnoreCase(<span class="string">&quot;Sedan&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SedanCar</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (carType.equalsIgnoreCase(<span class="string">&quot;SUV&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SUVCar</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid car type: &quot;</span> + carType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SedanCar</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Driving a sedan car...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SUVCar</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Driving an SUV car...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2.工厂方法模式"></a>2.工厂方法模式</h4><p><strong>定义：</strong>是指定义一个创建对象的接口，反让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类种进行，属于创建型设计模式。</p><blockquote><p>主要解决扩展问题</p></blockquote><p><strong>缺点：</strong>子类过多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">implements</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging message to file: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsoleLogger</span> <span class="keyword">implements</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging message to console: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    Logger <span class="title function_">createLogger</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLoggerFactory</span> <span class="keyword">implements</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileLogger</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsoleLoggerFactory</span> <span class="keyword">implements</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConsoleLogger</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心思想就是不同的类使用不同的工厂来创建，需要的工厂较多时就会导致出现大量子类</p><h4 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3.抽象工厂模式"></a>3.抽象工厂模式</h4><p><strong>定义：</strong>是指提供一个创建一系列相关或者相互依赖对象的接口，无需指定他们具体的类</p><p><strong>缺点：</strong>规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口，增加了系统的抽象性和理解难度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂接口，定义了创建产品的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    Button <span class="title function_">createButton</span><span class="params">()</span>;</span><br><span class="line">    TextField <span class="title function_">createTextField</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂实现类1，用于创建Windows风格的控件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsTextField</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂实现类2，用于创建Mac风格的控件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacTextField</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品接口，定义了产品的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">click</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品实现类1，用于创建Windows风格的按钮</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">click</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Windows Button Clicked.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品实现类2，用于创建Mac风格的按钮</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">click</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mac Button Clicked.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品接口，定义了产品的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">input</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品实现类1，用于创建Windows风格的文本框</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">input</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Windows TextField Input.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品实现类2，用于创建Mac风格的文本框</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">input</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mac TextField Input.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码，通过传入不同的工厂对象创建不同风格的控件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Windows风格的控件</span></span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowsFactory</span>();</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button1</span> <span class="operator">=</span> factory1.createButton();</span><br><span class="line">        button1.click();</span><br><span class="line">        <span class="type">TextField</span> <span class="variable">textField1</span> <span class="operator">=</span> factory1.createTextField();</span><br><span class="line">        textField1.input();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Mac风格的控件</span></span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MacFactory</span>();</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button2</span> <span class="operator">=</span> factory2.createButton();</span><br><span class="line">        button2.click();</span><br><span class="line">        <span class="type">TextField</span> <span class="variable">textField2</span> <span class="operator">=</span> factory2.createTextField();</span><br><span class="line">        textField2.input();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂和产品实现均需要接口定义，接口内定义了这些抽象接口之间的关系，因此实现这些的工厂和产品也具有接口定义的关系</p><h4 id="4-单例模式"><a href="#4-单例模式" class="headerlink" title="4.单例模式"></a>4.单例模式</h4><p>定义：是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点</p><blockquote><p>隐藏其所有的构造方法</p><p>属于创建者模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缺点:能够被反射破坏----构造器黎明抛异常解决</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyStaticInnerClassSingleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">LazyStaticInnerClassSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(LazyHolder.INSTANCE != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不允许非法访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> LazyStaticInnerClassSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">LazyStaticInnerClassSingleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LazyStaticInnerClassSingleton</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册式单例-枚举-解决反射破坏单例问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingleton</span>&#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Object data;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册式单例-容器-线程不安全型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContainerSingleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">ContainerSingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; ioc = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getInstance</span><span class="params">(String className)</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(!ioc.containsKey(className))&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        instance = Class.forName(className).newInstance();</span><br><span class="line">        ioc.put(className,instance);</span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ioc.get(className);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思考：当前容器方式下，如何解决线程不安全问题？</p></blockquote><blockquote><p>chatGPT版答案：</p><p>这段代码实现了一个容器单例模式，即将对象的创建和管理委托给一个容器来处理，通过类名获取对象的实例，如果容器中没有该实例则创建并存储在容器中，否则直接从容器中获取。不过，这段代码存在以下问题：</p><ol><li>线程不安全：在多线程环境下，存在并发访问和更新 ioc 容器的情况，可能导致数据不一致或者出现线程安全问题。</li><li>可能会导致内存泄漏：容器中存储了对象的实例，如果这些实例没有被及时清理或移除，可能会导致内存泄漏。</li><li>使用反射：在getInstance方法中使用Class.forName(className).newInstance()创建对象，这种方式会带来性能开销，且容易出现异常。建议改用其他创建对象的方式，比如工厂方法模式等。</li><li>只能通过类名获取实例：如果需要传递参数来创建对象，那么就需要修改getInstance方法的实现，这增加了代码的复杂性。</li></ol><p>针对以上问题，可以考虑使用线程安全的容器来存储对象实例，如ConcurrentHashMap；对于内存泄漏问题，可以考虑在适当的时候清理容器中的对象实例；对于反射和只能通过类名获取实例的问题，可以使用工厂方法等方式来创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****线程安全，懒加载的单例****/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContainerSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ContainerSingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ContainerSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getService</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ioc.containsKey(className)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ioc) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ioc.containsKey(className)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        instance = Class.forName(className).newInstance();</span><br><span class="line">                        ioc.put(className, instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            instance = ioc.get(className);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ContainerSingleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContainerSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于序列化和反序列化不一致问题，可以采用如下解决方案：</p><p>单例里面重写readResolve()方法，返回单例对象即可解决序列化单例不一致问题，因为在反序列化时会判断有没有写readResolve()方法，有的话就调用这个方法返回instance</p><h4 id="5-代理模式"><a href="#5-代理模式" class="headerlink" title="5.代理模式"></a>5.代理模式</h4><p><strong>应用场景：</strong>保护目标对象，增强目标对象</p><p><strong>静态代理：</strong>显示声明代理对象，只能代理指定类型对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态代理十分常见，属于硬编码，主要用一个代理对象来增强原来对象的功能</span></span><br><span class="line"><span class="comment">// 接口：定义了用户的行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标对象：实现了接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">implements</span> <span class="title class_">IUserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户保存成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象：也实现了接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">IUserDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理对象执行开始&quot;</span>);</span><br><span class="line">        userDao.save();  <span class="comment">// 调用目标对象的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代理对象执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码：使用代理对象调用目标对象的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IUserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        <span class="type">UserDaoProxy</span> <span class="variable">userDaoProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao);</span><br><span class="line">        userDaoProxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>动态代理：</strong>不论目标是啥，都能进行代理，主要分为jdk和CGLib两种动态代理方式</p><blockquote><p><strong>区别</strong>是，jdk的动态代理需要知道被代理类实现的接口，而cglib能够不需要知道</p><p>CGLib采用继承的方式，覆盖父类的方法</p><p>JDK采用的实现的方式们必须要求代理的目标对象一定要实现一个接口</p><p>思想：都是通过生成字节码，重组成一个新的类</p><p>其中，JDK Proxy对于用户而言，依赖更强，调用也更复杂</p><p>CGLib对于目标则没有任何的要求</p><p>CGLib底层没有用到反射，效率和性能更高</p><p>JDK Proxy生成逻辑较为简单，执行效率要低，每次都要用反射</p></blockquote><p><strong>注意，CGLib不能有fina修饰的方法，这一种方法会被忽略</strong></p><p>Spring种的代理选择原则</p><ul><li>当Bean<strong>有实现接口</strong>时，Spring就会用<strong>JDK</strong>的动态代理</li><li>当Bean没有实现接口时，Spring选择CGLib</li><li>Spring可以通过配置强制使用CGLib，只需要在Spring的配置文件中加入声明</li></ul><p>那么JDK和CGLib到底都是如何实现动态代理的呢？首先看下JDK动态代理实现流程</p><ol><li>定义一个接口和实现该接口的类。</li><li>创建一个 <code>InvocationHandler</code> 对象，并实现 <code>invoke</code> 方法，该方法将在代理对象上调用方法时被调用。</li><li>调用 <code>Proxy.newProxyInstance</code> 方法创建代理对象，并将实现了 <code>InvocationHandler</code> 接口的对象传递给它。</li><li>调用代理对象的方法，代理对象会调用 <code>InvocationHandler.invoke</code> 方法，并将方法名、参数和代理对象传递给它。</li></ol><p>下面是实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyExample</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I&#x27;m a dog.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AnimalInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Object target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AnimalInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.target = target;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Before method &quot;</span> + method.getName());</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">            System.out.println(<span class="string">&quot;After method &quot;</span> + method.getName());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">AnimalInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalInvocationHandler</span>(dog);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">proxy</span> <span class="operator">=</span> (Animal) Proxy.newProxyInstance(</span><br><span class="line">            dog.getClass().getClassLoader(),</span><br><span class="line">            dog.getClass().getInterfaces(),</span><br><span class="line">            handler);</span><br><span class="line">        proxy.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述示例中，我们定义了一个接口 <code>Animal</code> 和一个实现该接口的类 <code>Dog</code>。然后，我们创建了一个实现了 <code>InvocationHandler</code> 接口的类 <code>AnimalInvocationHandler</code>，它可以代理 <code>Animal</code> 接口的任何实现类。</p><p>在 <code>main</code> 方法中，我们首先创建了一个 <code>Dog</code> 实例 <code>dog</code>，然后创建了一个 <code>AnimalInvocationHandler</code> 实例 <code>handler</code>，将 <code>dog</code> 传入构造方法。最后，我们使用 <code>Proxy.newProxyInstance</code> 方法创建了一个 <code>Animal</code> 接口的代理对象 <code>proxy</code>，并将 <code>handler</code> 传入其中。</p><p>当我们调用 <code>proxy.say()</code> 时，<code>AnimalInvocationHandler.invoke</code> 方法会被调用，并在调用 <code>dog.say()</code> 方法前后输出了一些信息，以此实现了代理的效果。</p><p><strong>CGLib实现</strong></p><ol><li>引入 <code>cglib</code> 依赖。</li><li>定义一个类和继承该类的代理类。</li><li>创建一个 <code>MethodInterceptor</code> 对象，并实现 <code>intercept</code> 方法，该方法将在代理对象上调用方法时被调用。</li><li>使用 <code>Enhancer</code> 类创建代理对象，并将实现了 <code>MethodInterceptor</code> 接口的对象传递给它。</li><li>调用代理对象的方法，代理对象会调用 <code>MethodInterceptor.intercept</code> 方法，并将方法名、参数和代理对象传递给它。</li></ol><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，定义一个需要被代理的类 <code>UserDao</code> 和一个代理类 <code>UserDaoProxy</code>。这里 <code>UserDao</code> 类只有一个方法 <code>save()</code>，<code>UserDaoProxy</code> 类是一个代理类，继承自 <code>UserDao</code> 并重写了 <code>save()</code> 方法。在重写的方法中，我们可以添加一些代理逻辑，比如在调用被代理对象的方法之前或之后进行一些额外的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">extends</span> <span class="title class_">UserDao</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(UserDao.class);</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method invocation&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method invocation&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-建造者模式"><a href="#6-建造者模式" class="headerlink" title="6.建造者模式"></a>6.建造者模式</h4><p><strong>定义：</strong>是一个将复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示</p><p><strong>特征：</strong>用户只需指定需要建造的类型就可以获得对象，建造过程及细节不需要了解</p><p>把复杂对象的创建和使用分离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">withFirstName</span><span class="params">(String firstName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">withLastName</span><span class="params">(String lastName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">withAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">withAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123; firstName=&#x27;&quot;</span> + firstName + <span class="string">&quot;&#x27;, lastName=&#x27;&quot;</span> + lastName + <span class="string">&quot;&#x27;, age=&quot;</span> + age + <span class="string">&quot;, address=&#x27;&quot;</span> + address + <span class="string">&quot;&#x27; &#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">                            .withFirstName(<span class="string">&quot;John&quot;</span>)</span><br><span class="line">                            .withLastName(<span class="string">&quot;Doe&quot;</span>)</span><br><span class="line">                            .withAge(<span class="number">30</span>)</span><br><span class="line">                            .withAddress(<span class="string">&quot;123 Main Street&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-原型模式"><a href="#7-原型模式" class="headerlink" title="7.原型模式"></a>7.原型模式</h4><p><strong>定义：</strong>是指原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象</p><p>调用者不需要知道任何创建细节，不调用构造函数</p><blockquote><p>通俗讲法就是如何快速构建对象的方法总结，简单工厂将getter、setter封装到某个方法中</p><p>JDK提供的实现Cloneable接口，实现快速复制</p></blockquote><p><strong>适用场景</strong></p><p>1.类初始化消耗资源较多</p><p>2.new产生的一个对象需要非常繁琐的过程</p><p>3.构造函数比较复杂</p><p>4.循环体中产生大量对象时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypeExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">PrototypeExample</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> PrototypeExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">      <span class="keyword">return</span> (PrototypeExample) <span class="built_in">super</span>.clone();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在客户端代码中使用原型模式来创建新对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">      <span class="type">PrototypeExample</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrototypeExample</span>(<span class="string">&quot;example&quot;</span>);</span><br><span class="line">      <span class="type">PrototypeExample</span> <span class="variable">clone</span> <span class="operator">=</span> prototype.clone();</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">&quot;Original object name: &quot;</span> + prototype.getName());</span><br><span class="line">      System.out.println(<span class="string">&quot;Cloned object name: &quot;</span> + clone.getName());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型模式主要是通过类实现cloneable接口，覆写clone接口来实现拷贝，但是这里默认实现的还是浅拷贝，如果想实现深拷贝，需要手动指明非基本类型的拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数和getter/setter方法省略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">cloned</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.birthday = (Date) <span class="built_in">this</span>.birthday.clone();</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-适配器模式"><a href="#8-适配器模式" class="headerlink" title="8.适配器模式"></a>8.适配器模式</h4><p><strong>定义：</strong>又叫变压器模式，它的功能是将一个类的接口编程客户端所期待的一种接口，从而使原本因接口不匹配而导致无法在一起工作的两个类能够一起工作</p><blockquote><p>属于结构型设计模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LegacyRectangle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> length * width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleAdapter</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LegacyRectangle adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RectangleAdapter</span><span class="params">(LegacyRectangle adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> adaptee.calculateArea();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LegacyRectangle</span> <span class="variable">legacyRectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LegacyRectangle</span>();</span><br><span class="line">        <span class="type">RectangleAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RectangleAdapter</span>(legacyRectangle);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> adapter.getArea();</span><br><span class="line">        System.out.println(<span class="string">&quot;Area of rectangle: &quot;</span> + area);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，我们首先创建了一个LegacyRectangle对象，并将其传递给RectangleAdapter适配器类的构造函数。然后，我们使用适配器对象的getArea()方法来计算长方形面积，并输出结果。</p><h4 id="9-桥接模式"><a href="#9-桥接模式" class="headerlink" title="9.桥接模式"></a>9.桥接模式</h4><p><strong>定义：</strong>是一种结构型设计模式，它将抽象部分与实现部分分离开来，使它们可以独立地变化。桥接模式的核心思想是通过组合的方式，将一个类的实现细节委托给另一个类来完成。</p><p>桥接模式的主要目的是将抽象和实现解耦，使得它们可以独立地变化。抽象部分定义了系统的接口和一些高层次的操作，而实现部分负责具体的实现细节。通过将抽象和实现分离开来，桥接模式使得系统更加灵活，易于扩展和维护。</p><p>假设我们要设计一个绘图程序，它可以绘制不同类型的图形，例如圆形和矩形。我们可以使用桥接模式来将图形的类型（抽象部分）和绘制图形的具体方式（实现部分）分离开来。</p><p>首先，我们定义一个Shape抽象类，它包含一个DrawAPI成员变量，表示绘制图形的实现部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们定义一个DrawAPI接口，表示绘制图形的实现部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> radius)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们定义两个具体实现类，分别实现DrawAPI接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedCircle</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> radius)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing red circle at (&quot;</span> + x + <span class="string">&quot;,&quot;</span> + y + <span class="string">&quot;), radius &quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenRectangle</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> radius)</span> &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span></span><br></pre></td></tr></table></figure><h4 id="10-委派模式"><a href="#10-委派模式" class="headerlink" title="10.委派模式"></a>10.委派模式</h4><p><strong>定义：</strong>又叫委托模式，它的基本作用就是负责任务的调度和任务分配，将任务的分配和执行分离开来，可以看做是一种特殊情况下的静态代理的全权代理。</p><blockquote><p>不属于23种GOF设计模式之一</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskA</span> <span class="keyword">implements</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running Task A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskB</span> <span class="keyword">implements</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running Task B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskDelegator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Task&gt; taskMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TaskDelegator</span><span class="params">()</span> &#123;</span><br><span class="line">        taskMap.put(<span class="string">&quot;TaskA&quot;</span>, <span class="keyword">new</span> <span class="title class_">TaskA</span>());</span><br><span class="line">        taskMap.put(<span class="string">&quot;TaskB&quot;</span>, <span class="keyword">new</span> <span class="title class_">TaskB</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">(String taskName)</span> &#123;</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskMap.get(taskName);</span><br><span class="line">        <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Unknown task: &quot;</span> + taskName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegationPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TaskDelegator</span> <span class="variable">taskDelegator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskDelegator</span>();</span><br><span class="line">        taskDelegator.doTask(<span class="string">&quot;TaskA&quot;</span>);</span><br><span class="line">        taskDelegator.doTask(<span class="string">&quot;TaskB&quot;</span>);</span><br><span class="line">        taskDelegator.doTask(<span class="string">&quot;TaskC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-模版模式"><a href="#11-模版模式" class="headerlink" title="11.模版模式"></a>11.模版模式</h4><p><strong>定义：</strong>是一种行为型设计模式，它定义了一个算法的骨架，将一些步骤延迟到子类中实现，从而使得子类可以改变算法的某些特定步骤，而不改变算法的结构。</p><p><strong>解析：</strong>模版模式是在框架和日常开发之中使用比较多的一种设计模式，适合具有大量重复操作的步骤，将这些重复内容抽离出来放进模版之中，后续的开发只需要继承模版并实现个性化部分即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">startPlay</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">endPlay</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 初始化游戏</span></span><br><span class="line">        initialize();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 抽取出的公共部分方法</span></span><br><span class="line">      doSomething1();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 开始游戏</span></span><br><span class="line">        startPlay();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 抽取出的公共部分方法</span></span><br><span class="line">      doSomething2();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 结束游戏</span></span><br><span class="line">        endPlay();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protect <span class="keyword">void</span> <span class="title function_">doSomething1</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;模版内固定方法1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  protect <span class="keyword">void</span> <span class="title function_">doSomething2</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;模版内固定方法2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cricket</span> <span class="keyword">extends</span> <span class="title class_">Game</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">endPlay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cricket Game Finished!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cricket Game Initialized! Start playing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">startPlay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cricket Game Started. Enjoy the game!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Football</span> <span class="keyword">extends</span> <span class="title class_">Game</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">endPlay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Finished!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Initialized! Start playing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">startPlay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Started. Enjoy the game!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameTemplatePatternDemo</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">Game</span> <span class="variable">game</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cricket</span>();</span><br><span class="line">        game.play();</span><br><span class="line">        System.out.println();</span><br><span class="line"> </span><br><span class="line">        game = <span class="keyword">new</span> <span class="title class_">Football</span>();</span><br><span class="line">        game.play();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-策略模式"><a href="#12-策略模式" class="headerlink" title="12.策略模式"></a>12.策略模式</h4><p><strong>定义：</strong>又叫政策模式，它是将定义的算法家族，分别封装起来，让他们之间可以相互替换，从而让算法的变化不会影响到使用算法的用户。</p><p><strong>可以避免多重的if-else语句</strong>，使用map或者数据库配置</p><blockquote><p>属于行为型模式</p></blockquote><p>以下是一个简单的示例，演示如何使用策略模式计算两个数字的和。该示例包括一个接口<code>Strategy</code>，它定义了一个<code>doOperation</code>方法，以及三个实现类：<code>AddStrategy</code>、<code>SubtractStrategy</code>和<code>MultiplyStrategy</code>，它们分别实现了<code>doOperation</code>方法，用于执行加法、减法和乘法运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义策略接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现加法策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现减法策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubtractStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现乘法策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiplyStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类，负责选择和执行具体策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">executeStrategy</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">AddStrategy</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">SubtractStrategy</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">MultiplyStrategy</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 * 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础之集合源码分析</title>
      <link href="/2023/03/21/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2023/03/21/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="java集合源码分析"><a href="#java集合源码分析" class="headerlink" title="java集合源码分析"></a>java集合源码分析</h2><h3 id="一、java集合"><a href="#一、java集合" class="headerlink" title="一、java集合"></a>一、java集合</h3><h4 id="1-ArrayList源码"><a href="#1-ArrayList源码" class="headerlink" title="1.ArrayList源码"></a>1.ArrayList源码</h4><h5 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认数组长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 默认空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">// 集合大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定初始容量的构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                         initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认空初始化---懒加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入实现了Collection接口的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">           elementData = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="add操作"><a href="#add操作" class="headerlink" title="add操作"></a>add操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最常用方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 确定容量 动态扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 进数组</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定位置插入，不常用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定数组大小并决定是否扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">  ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算较大值 minCapacity是size+1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">      <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 确定是否需要扩容 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存不足，需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">      grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩容 每次扩容1.5倍</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">// 新数组长度 = 1.5 * 旧数组长度</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity); <span class="comment">// 复制到新数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么ArrayList每次扩容容积都要变成原来的1.5倍呢？</p><p>在ArrayList的实现中，每次扩容容量都会增加原来容量的一半。这个增量的选择是为了在避免频繁扩容和节省内存之间寻求一个平衡点。</p><p>具体来说，如果每次只增加一个固定的值，那么当需要容纳大量元素时，ArrayList可能会不断地进行扩容操作，这会导致额外的内存分配和复制元素的开销。而如果每次增加原容量的比例太小，那么ArrayList可能需要频繁进行扩容操作，这同样会导致不必要的开销。</p><p>因此，1.5倍的增量选择是一种折中方案，既可以避免过于频繁的扩容操作，又可以减少额外的内存分配和元素复制的开销。同时，这个增量值也可以根据实际情况进行调整。</p></blockquote><h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">  rangeCheck(index); <span class="comment">// 检查是否数组越界</span></span><br><span class="line">  <span class="keyword">return</span> ArrayList.<span class="built_in">this</span>.elementData(offset + index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在多线程环境下，如果一个线程修改了集合中的元素，而另一个线程正在遍历这个集合，就可能会导致遍历出错。为了避免这种情况的发生，<code>ArrayList</code>类提供了<code>checkForComodification</code>方法，用于检测集合是否在遍历过程中被修改过。</p><p><code>modCount</code>变量表示<code>ArrayList</code>被修改的次数，每次修改（增加或删除元素）时<code>modCount</code>会自增</p></blockquote><h5 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E e)</span> &#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">// 检查是否越界</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> ArrayList.<span class="built_in">this</span>.elementData(offset + index); <span class="comment">// 获取原来下标对应的值</span></span><br><span class="line">    ArrayList.<span class="built_in">this</span>.elementData[offset + index] = e;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;<span class="comment">// 要移动元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 从删除位置往后拷贝删除</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                       numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-LinkedList源码"><a href="#2-LinkedList源码" class="headerlink" title="2.LinkedList源码"></a>2.LinkedList源码</h4><h5 id="前置声明-1"><a href="#前置声明-1" class="headerlink" title="前置声明"></a>前置声明</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组大小</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装的节点类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入实现Collection接口的其他对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增单个节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾插法插入新节点</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">      first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="get方法-1"><a href="#get方法-1" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取index位置数值</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index); <span class="comment">// 检查是否越界</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历查找</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">          x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">          x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="set方法-1"><a href="#set方法-1" class="headerlink" title="set方法"></a>set方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    checkElementIndex(index); <span class="comment">// 检查越界</span></span><br><span class="line">    Node&lt;E&gt; x = node(index); <span class="comment">// 找到节点</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove方法-1"><a href="#remove方法-1" class="headerlink" title="remove方法"></a>remove方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除某一坐标节点</span></span><br><span class="line"> <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">     checkElementIndex(index);</span><br><span class="line">     <span class="keyword">return</span> unlink(node(index)); <span class="comment">// node找到index位置的节点</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 删除节点</span></span><br><span class="line"> E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">     <span class="comment">// assert x != null;</span></span><br><span class="line">     <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">         first = next;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         prev.next = next;</span><br><span class="line">         x.prev = <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">         last = prev;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         next.prev = prev;</span><br><span class="line">         x.next = <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     x.item = <span class="literal">null</span>;</span><br><span class="line">     size--;</span><br><span class="line">     modCount++;</span><br><span class="line">     <span class="keyword">return</span> element;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="3-HashMap源码"><a href="#3-HashMap源码" class="headerlink" title="3.HashMap源码"></a>3.HashMap源码</h4><h5 id="前置声明-2"><a href="#前置声明-2" class="headerlink" title="前置声明"></a>前置声明</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认容初始量 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大容量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认负载因子</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转红黑树阈值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扩容后树转链表阈值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最小树化数组阈值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装的节点---hashmap中数据都以Node结构存储在桶中</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">      <span class="keyword">final</span> K key;</span><br><span class="line">      V value;</span><br><span class="line">      Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">      Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">          <span class="built_in">this</span>.hash = hash;</span><br><span class="line">          <span class="built_in">this</span>.key = key;</span><br><span class="line">          <span class="built_in">this</span>.value = value;</span><br><span class="line">          <span class="built_in">this</span>.next = next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">          <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">          value = newValue;</span><br><span class="line">          <span class="keyword">return</span> oldValue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">              Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">              <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                  Objects.equals(value, e.getValue()))</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 散列函数 使用 扰动函数 将哈希值进一步打乱</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      <span class="type">int</span> h;</span><br><span class="line">      <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定初始化容量与负载因子---很少使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定初始化容量---用于知道hashmap大概要存储多少数据时</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 默认构造方法，使用默认负载因子</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 传进来一个map初始化</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// put方法，本质是调用putVal</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 实际上实现put方法的地方</span></span><br><span class="line">  <span class="comment">/********onlyIfAbsent – if true, don&#x27;t change existing value********/</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                 <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// tab就是哈希桶，也就是数组+链表中的数组部分 p用来指向key对应的桶位置节点</span></span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 未初始化，先resize进行初始化</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// p指向要插入的桶节点位置，判断当前位置是否为空，为空直接把value封装放进去</span></span><br><span class="line">     <span class="comment">// (n - 1) &amp; hash 这一步很妙，与double扩容配合可以使得扩容时，节点要么不移动桶位置，要么+原数组长度移动</span></span><br><span class="line">      <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>) </span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 存在哈希冲突 e是要插入的位置，如果已存在这个key，e就指向这个key对应的节点</span></span><br><span class="line">          Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 桶处的根节点和插入的key相等，直接把e指向p</span></span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              e = p;</span><br><span class="line">        <span class="comment">// 如果桶位置已经树化，调用树的putTreeVal方法</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">              e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value); <span class="comment">// 树版本的putVal</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 未树化，则遍历找到要插入位置</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                  <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                      p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 如果插入之后链表长度达到阈值，尝试树化</span></span><br><span class="line">                      <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                          treeifyBin(tab, hash);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                <span class="comment">// 找到已存在key对应节点</span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  p = e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// key已存在，替换value</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">              <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                  e.value = value;</span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++modCount;</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">      <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">          resize();</span><br><span class="line">      afterNodeInsertion(evict);  <span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试将链表树化</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">      <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 如果数组长度未达阈值（64），则先进行数组扩容</span></span><br><span class="line">      <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">          resize();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">              <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                  hd = p;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  p.prev = tl;</span><br><span class="line">                  tl.next = p;</span><br><span class="line">              &#125;</span><br><span class="line">              tl = p;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">              hd.treeify(tab);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">      <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span> oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// 新容量是原来两倍</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 扩容临界值也两倍</span></span><br><span class="line">              newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">          newCap = oldThr;</span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line">      threshold = newThr;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">      Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123; <span class="comment">// 初始时不需要复制</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                  oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 桶中元素就一个 找到元素新位置赋值</span></span><br><span class="line">                      newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 移动树</span></span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                  <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                      Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; next;</span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line">                          <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                      <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                          loTail.next = <span class="literal">null</span>;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                          hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="get方法-2"><a href="#get方法-2" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取key对应值</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际调用方式</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// first是哈希后桶位置上第一个节点</span></span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接找到</span></span><br><span class="line">          <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">              ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              <span class="keyword">return</span> first;</span><br><span class="line">          <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历树</span></span><br><span class="line">              <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">return</span> e;</span><br><span class="line">              &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="remove方法-2"><a href="#remove方法-2" class="headerlink" title="remove方法"></a>remove方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">          <span class="literal">null</span> : e.value;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 找到节点，删除即可，注意树结构删除节点之后可能会退化</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                             <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">          Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              node = p;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">do</span> &#123;</span><br><span class="line">                      <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                          ((k = e.key) == key ||</span><br><span class="line">                           (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                          node = e;</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                      p = e;</span><br><span class="line">                  &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                               (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">              <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                  tab[index] = node.next;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  p.next = node.next;</span><br><span class="line">              ++modCount;</span><br><span class="line">              --size;</span><br><span class="line">              afterNodeRemoval(node);</span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="4-modCount与FailFast机制"><a href="#4-modCount与FailFast机制" class="headerlink" title="4.modCount与FailFast机制"></a>4.modCount与FailFast机制</h4><p>上面三个类里面，都有monCount变量，那么这个变量是什么，有什么用处呢？</p><p>在 Java 集合中，modCount 是用于实现<strong>“快速失败”</strong>机制的一个计数器，用于跟踪集合对象自创建以来所发生的修改次数。当通过迭代器遍历集合时，如果在迭代过程中发现集合的 modCount 发生了变化，就会立即抛出 ConcurrentModificationException 异常，以避免并发修改导致的数据不一致问题。</p><p>快速失败机制的目的是为了保证多个线程并发操作同一个集合时的数据一致性。如果不使用快速失败机制，可能会导致数据不一致，而且这种不一致的结果可能是不可预测的。</p><p>因此，集合类在实现迭代器时，通常会在每次进行<strong>修改（新增，删除，更新）</strong>操作时，将 modCount 的计数器加 1，以便在下次迭代时检测到修改操作，抛出异常以提醒程序员代码存在问题。同时，这也是 Java 集合框架的一个核心设计原则之一，即在多线程环境中保证数据的一致性。</p><h4 id="5-Vector"><a href="#5-Vector" class="headerlink" title="5.Vector"></a>5.Vector</h4><p>和ArrayList很相似，都是以动态数组的形式来存储数据，但是它是线程安全的，Vector的线程安全来自于每一个操作方法都加上了synchronized关键字，对性能来说有较大影响，目前属于逐渐废弃的方法</p><p>而对于ArrayList这种非线程安全的数组，可以使用Collections工具来实现线程安全，比Vector更加安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">syncList</span> <span class="operator">=</span> Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure><p>本质上是工具类为原方法封装了加锁的同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.get(index);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.set(index, element);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;list.add(index, element);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.remove(index);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatisPlus之条件构造器</title>
      <link href="/2022/08/24/%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8/"/>
      <url>/2022/08/24/%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><blockquote><p>说明：</p><p>条件构造器构造条件时，一般支持两到三个入参，使用以下两个入参情况较多（R column, Object val）；第一个参数是一个 boolean 类型，默认为 true，表示加入到最后构造的 sql 当中；因此在构造条件时，可以将判断加在外面，也可以写在第一个参数处</p></blockquote><h2 id="二、Wrapper"><a href="#二、Wrapper" class="headerlink" title="二、Wrapper"></a>二、Wrapper</h2><h3 id="AbstractWrapper"><a href="#AbstractWrapper" class="headerlink" title="AbstractWrapper"></a>AbstractWrapper</h3><blockquote><p>说明:</p><p>QueryWrapper (LambdaQueryWrapper) 和 UpdateWrapper (LambdaUpdateWrapper) 的父类用于生成 sql 的 where 条件，entity 属性也用于生成 sql 的 where 条件<br>注意: entity 生成的 where 条件与 使用各个 api 生成的 where 条件<strong>没有任何关联行为</strong></p></blockquote><p>作为父类，AbstractWrapper 包含了大量构造条件所用方法</p><p>常用方法不再赘述，具体参考 MyBatis-Plus 官网：<a href="https://baomidou.com/pages/10c804/#alleq:~:text=%23-,AbstractWrapper,-%E8%AF%B4%E6%98%8E%3A">条件构造器 - AbstractWrapper</a></p><p>需要稍微注意的是以下几个方法</p><h4 id="inSql"><a href="#inSql" class="headerlink" title="inSql"></a>inSql</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inSql(R column, String inValue)</span><br></pre></td></tr></table></figure><p>其中，inValue 代表 sql 语句，即开发者可以直接将 sql 语句作为参数传递进来，作为查询条件构造</p><ul><li>字段 IN (sql 语句)</li><li>例: <code>inSql(&quot;age&quot;, &quot;1,2,3,4,5,6&quot;)</code>—&gt;<code>age in (1,2,3,4,5,6)</code></li><li>例: <code>inSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)</code>—&gt;<code>id in (select id from table where id &lt; 3)</code></li></ul><h4 id="having"><a href="#having" class="headerlink" title="having"></a>having</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">having(String sqlHaving, Object... params)</span><br><span class="line">having(<span class="type">boolean</span> condition, String sqlHaving, Object... params)</span><br></pre></td></tr></table></figure><ul><li>HAVING (sql 语句)</li><li>例: <code>having(&quot;sum(age) &gt; 10&quot;)</code>—&gt;<code>having sum(age) &gt; 10</code></li><li>例: <code>having(&quot;sum(age) &gt; &#123;0&#125;&quot;, 11)</code>—&gt;<code>having sum(age) &gt; 11</code></li></ul><h4 id="func"><a href="#func" class="headerlink" title="func"></a>func</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(Consumer&lt;Children&gt; consumer)</span><br><span class="line">func(<span class="type">boolean</span> condition, Consumer&lt;Children&gt; consumer)</span><br></pre></td></tr></table></figure><ul><li>func 方法 (主要方便在出现 if…else 下调用不同方法能不断链)</li><li>例: <code>func(i -&gt; if(true) &#123;i.eq(&quot;id&quot;, 1)&#125; else &#123;i.ne(&quot;id&quot;, 1)&#125;)</code></li></ul><h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">or()</span><br><span class="line">or(<span class="type">boolean</span> condition)</span><br></pre></td></tr></table></figure><ul><li><p>拼接 OR</p><p>注意事项:</p><p>主动调用 <code>or</code> 表示紧接着下一个<strong>方法</strong>不是用 <code>and</code> 连接！(不调用 <code>or</code> 则默认为使用 <code>and</code> 连接)</p></li><li><p>例: <code>eq(&quot;id&quot;,1).or().eq(&quot;name&quot;,&quot;老王&quot;)</code>—&gt;<code>id = 1 or name = &#39;老王&#39;</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">or(Consumer&lt;Param&gt; consumer)</span><br><span class="line">or(<span class="type">boolean</span> condition, Consumer&lt;Param&gt; consumer)</span><br></pre></td></tr></table></figure><ul><li>OR 嵌套</li><li>例: <code>or(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))</code>—&gt;<code>or (name = &#39;李白&#39; and status &lt;&gt; &#39;活着&#39;)</code></li></ul><h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and(Consumer&lt;Param&gt; consumer)</span><br><span class="line">and(<span class="type">boolean</span> condition, Consumer&lt;Param&gt; consumer)</span><br></pre></td></tr></table></figure><ul><li>AND 嵌套</li><li>例: <code>and(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))</code>—&gt;<code>and (name = &#39;李白&#39; and status &lt;&gt; &#39;活着&#39;)</code></li></ul><h3 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h3><blockquote><p>说明:</p><p>继承自 AbstractWrapper , 自身的内部属性 entity 也用于生成 where 条件<br>及 LambdaQueryWrapper, 可以通过 new QueryWrapper ().lambda () 方法获取</p></blockquote><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select(String... sqlSelect)</span><br><span class="line">select(Predicate&lt;TableFieldInfo&gt; predicate)</span><br><span class="line">select(Class&lt;T&gt; entityClass, Predicate&lt;TableFieldInfo&gt; predicate)</span><br></pre></td></tr></table></figure><ul><li><p>设置查询字段</p><blockquote><p>说明:</p><p>以上方法分为两类.<br>第二类方法为：过滤查询字段 (主键除外), 入参不包含 class 的调用前需要 <code>wrapper</code> 内的 <code>entity</code> 属性有值！这两类方法重复调用以最后一次为准</p></blockquote></li><li><p>例: <code>select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;)</code></p></li><li><p>例: <code>select(i -&gt; i.getProperty().startsWith(&quot;test&quot;))</code></p></li></ul><p>在构造 Wrapper 时，使用 select 可以减少无用字段的查询</p><h3 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a>UpdateWrapper</h3><blockquote><p>说明:</p><p>继承自 <code>AbstractWrapper</code> , 自身的内部属性 <code>entity</code> 也用于生成 where 条件<br>及 <code>LambdaUpdateWrapper</code>, 可以通过 <code>new UpdateWrapper().lambda()</code> 方法获取！</p></blockquote><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(String column, Object val)</span><br><span class="line">set(<span class="type">boolean</span> condition, String column, Object val)</span><br></pre></td></tr></table></figure><ul><li>SQL SET 字段</li><li>例: <code>set(&quot;name&quot;, &quot;老李头&quot;)</code></li><li>例: <code>set(&quot;name&quot;, &quot;&quot;)</code>—&gt; 数据库字段值变为<strong>空字符串</strong></li><li>例: <code>set(&quot;name&quot;, null)</code>—&gt; 数据库字段值变为 <code>null</code></li></ul><h4 id="setSql"><a href="#setSql" class="headerlink" title="setSql"></a>setSql</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setSql(String sql)</span><br></pre></td></tr></table></figure><ul><li>设置 SET 部分 SQL</li><li>例: <code>setSql(&quot;name = &#39;老李头&#39;&quot;)</code></li></ul><h4 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h4><ul><li>获取 <code>LambdaWrapper</code><br>在 <code>QueryWrapper</code> 中是获取 <code>LambdaQueryWrapper</code><br>在 <code>UpdateWrapper</code> 中是获取 <code>LambdaUpdateWrapper</code></li></ul><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>上面介绍的都是常规用法，MyBatis-Plus 还支持一些更为简洁的书写方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">LambdaUpdateChainWrapper</span>&lt;&gt;(testMapper)</span><br><span class="line">        .eq(TestEntity::getIsDelete,<span class="number">0</span>)</span><br><span class="line">        .eq(TestEntity::getName,<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">        .eq(TestEntity::getAge,<span class="number">18</span>)</span><br><span class="line">        .set(TestEntity::getAge,<span class="number">20</span>)</span><br><span class="line">        .set(TestEntity::getUpdateTime,<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">        .update();</span><br></pre></td></tr></table></figure><p>这种方法能够直接按照条件查询并更新数据库</p><blockquote><p>此外，需要注意 @TableField (exist &#x3D; false) 注解，加了这个注解的参数不会再往数据库写入，同样无法作为条件参数进行查询</p></blockquote><h3 id="使用-Wrapper-自定义-SQL"><a href="#使用-Wrapper-自定义-SQL" class="headerlink" title="使用 Wrapper 自定义 SQL"></a>使用 Wrapper 自定义 SQL</h3><blockquote><p>注意事项:</p><p>需要 <code>mybatis-plus</code> 版本 &gt;&#x3D; <code>3.0.7</code> param 参数名要么叫 <code>ew</code>, 要么加上注解 <code>@Param(Constants.WRAPPER)</code> 使用 <code>$&#123;ew.customSqlSegment&#125;</code> 不支持 <code>Wrapper</code> 内的 entity 生成 where 语句</p></blockquote><h4 id="用注解"><a href="#用注解" class="headerlink" title="用注解"></a>用注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from mysql_data $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">List&lt;MysqlData&gt; <span class="title function_">getAll</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper wrapper)</span>;</span><br></pre></td></tr></table></figure><h4 id="用-XML"><a href="#用-XML" class="headerlink" title="用 XML"></a>用 XML</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;MysqlData&gt; <span class="title function_">getAll</span><span class="params">(Wrapper ew)</span>;</span><br><span class="line">XML</span><br><span class="line">&lt;select id=<span class="string">&quot;getAll&quot;</span> resultType=<span class="string">&quot;MysqlData&quot;</span>&gt;</span><br><span class="line">SELECT * FROM mysql_data $&#123;ew.customSqlSegment&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>该方法可以将 sql 与使用 Wrapper 构造的查询条件进行拼接，在业务比较复杂，使用 wrapper 又无法满足需求的时候，拼接可以减少不必要的重写 sql 工作</p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis-Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础之认识NlogN的排序</title>
      <link href="/2022/05/24/%E8%AE%A4%E8%AF%86NlogN%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/05/24/%E8%AE%A4%E8%AF%86NlogN%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础-归并排序"><a href="#一、基础-归并排序" class="headerlink" title="一、基础 - 归并排序"></a>一、基础 - 归并排序</h2><p>归并排序思想十分简单，但是利用归并排序的变形，可以解决一些看似较为复杂的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> ;</span><br><span class="line">      mergeSort(array,<span class="number">0</span>,array.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right == left) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        mergeSort(array,left,mid);</span><br><span class="line">        mergeSort(array,mid + <span class="number">1</span>,right);</span><br><span class="line">        merge(array,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span>&#123;</span><br><span class="line"><span class="comment">//归并排序特点，开辟一个辅助数组</span></span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right)&#123;</span><br><span class="line">            help[i++] = array[p1] &lt; array[p2] ? array[p1++] : array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid)&#123;</span><br><span class="line">            help[i++] = array[p1++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= right)&#123;</span><br><span class="line">            help[i++] = array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//排好序数组写回原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : help) &#123;</span><br><span class="line">            array[left++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        solution.mergeSort(nums);</span><br><span class="line">        System.out.println(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、拓展"><a href="#二、拓展" class="headerlink" title="二、拓展"></a>二、拓展</h2><h3 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h3><p><strong>问题描述：</strong></p><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。</p><p><strong>例子：</strong></p><p>求数组 [1,3,4,2,5] 的小和</p><p><strong>分析：</strong></p><p>3 左边比 3 小的数，1</p><p>4 左边比 4 小的数，1、3</p><p>2 左边比 2 小的数，1</p><p>5 左边比 5 小的数，1、3、4、2</p><p>所以小和为 1+1+3+1+1+3+4+2&#x3D;16</p><p><strong>求小和算法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> mergeSort(array,<span class="number">0</span>,array.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right == left) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSum</span> <span class="operator">=</span> mergeSort(array,left,mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightSum</span> <span class="operator">=</span> mergeSort(array,mid + <span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> leftSum + rightSum + merge(array,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span>&#123;</span><br><span class="line"><span class="comment">//开辟辅助数组</span></span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//小和结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right)&#123;</span><br><span class="line">          <span class="comment">//核心步骤，重点在于两边数组都是归并排好序的数组</span></span><br><span class="line">          <span class="comment">//因此array[p2]和其右边的值都大于array[p1]</span></span><br><span class="line">            result += array[p1] &lt; array[p2] ? (right - p2 + <span class="number">1</span>) * array[p1] : <span class="number">0</span>;</span><br><span class="line">            help[i++] = array[p1] &lt; array[p2] ? array[p1++] : array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid)&#123;</span><br><span class="line">            help[i++] = array[p1++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= right)&#123;</span><br><span class="line">            help[i++] = array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : help) &#123;</span><br><span class="line">            array[left++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(solution.mergeSort(nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>小和问题是经典的归并排序变形问题，与此类似的还有逆序对问题</p><h3 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h3><p>在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对（个数）。</p><blockquote><p>仅需改动核心步骤即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依然递增排序</span></span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right)&#123;</span><br><span class="line">  <span class="comment">//核心步骤，重点在于两边数组都是归并排好序的数组</span></span><br><span class="line">  <span class="comment">//打印逆序对</span></span><br><span class="line">  <span class="keyword">if</span>(array[p1] &gt; array[p2])&#123;</span><br><span class="line">  <span class="comment">//p1右边的都比p2大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p1;i&lt;mid;i++)&#123;</span><br><span class="line">      System.out.println(array[p1]+<span class="string">&quot;,&quot;</span>+array[p2]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//逆序对个数</span></span><br><span class="line">  <span class="comment">//result += array[p1] &gt; array[p2] ? (mid - p1 + 1) : 0;</span></span><br><span class="line">  help[i++] = array[p1] &lt; array[p2] ? array[p1++] : array[p2++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆序对与小和问题本质一样，除此之外，还有荷兰国旗问题，是小和问题的轻微进阶版本</p><h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><p>给定一个数组 arr，和一个数 num，请把小于 num 的数放在数组的左边，等于 num 的数放在数组的中间，大于 num 的数放在数组的右边。要求额外空间复杂度 O (1)，时间复杂度 O (N)</p><blockquote><p>返回值含义： 一定会返回一个长度为 2 的数组，等于区域的左边界和右边界（也就是相等区域的边界范围 ）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span>[] partition(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> num) &#123;</span><br><span class="line">    <span class="comment">//less为小于num区的边界，more为大于num的边界，left当做遍历数组的指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; more)&#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[left] &lt; num)&#123;</span><br><span class="line">        swap(arr,left++,++less);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[left] &gt; num)&#123;</span><br><span class="line">        swap(arr,--more,left);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        left++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;less + <span class="number">1</span>,more - <span class="number">1</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    solution.partition(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">    System.out.println(solution.partition(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>,<span class="number">5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p>【1】<a href="https://juejin.cn/post/7137283772797419534">认识认识 O (NlogN) 的排序 | 左程云算法笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础之时间复杂度</title>
      <link href="/2022/04/24/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2022/04/24/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础-简单排序算法"><a href="#一、基础-简单排序算法" class="headerlink" title="一、基础 - 简单排序算法"></a>一、基础 - 简单排序算法</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;<span class="comment">//记录最小值位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;<span class="comment">//改变最小值位置</span></span><br><span class="line">&#125;</span><br><span class="line">swap(arr, i, minIndex);<span class="comment">//交换最小值到前面 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; e &gt; <span class="number">0</span>; e--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(arr, i, i + <span class="number">1</span>);<span class="comment">//把较大数交换到后面</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">//只有i，j两个位置不同时可以这么写</span></span><br><span class="line">    <span class="comment">//否则会将数据抹成0</span></span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">arr[j] = arr[i] ^ arr[j];</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">arr[j] = arr[i] ^ arr[j];</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分法的详解与扩展"><a href="#二分法的详解与扩展" class="headerlink" title="二分法的详解与扩展"></a>二分法的详解与扩展</h3><h4 id="1）在一个有序数组中，找某个数是否存在"><a href="#1）在一个有序数组中，找某个数是否存在" class="headerlink" title="1）在一个有序数组中，找某个数是否存在"></a>1）在一个有序数组中，找某个数是否存在</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">int</span>[] sortedArr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (sortedArr == <span class="literal">null</span> || sortedArr.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> sortedArr.length - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (sortedArr[mid] == num) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sortedArr[mid] &gt; num) &#123;</span><br><span class="line">R = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">L = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sortedArr[L] == num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）在一个有序数组中，找-gt-x3D-某个数最左侧的位置"><a href="#2）在一个有序数组中，找-gt-x3D-某个数最左侧的位置" class="headerlink" title="2）在一个有序数组中，找 &gt;&#x3D; 某个数最左侧的位置"></a>2）在一个有序数组中，找 &gt;&#x3D; 某个数最左侧的位置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在arr上，找满足&gt;=value的最左位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nearestIndex</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">index = mid;</span><br><span class="line">R = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">L = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）局部最小值问题"><a href="#3）局部最小值问题" class="headerlink" title="3）局部最小值问题"></a>3）局部最小值问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到一个局部最小值就返回，会优先找到左边的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLessIndex</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// no exist</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr.length == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[arr.length - <span class="number">1</span>] &lt; arr[arr.length - <span class="number">2</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> arr.length - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//left == right 此时的left 就是下一次的mid</span></span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、拓展-异或运算"><a href="#二、拓展-异或运算" class="headerlink" title="二、拓展 - 异或运算"></a>二、拓展 - 异或运算</h2><h3 id="异或运算的性质与扩展"><a href="#异或运算的性质与扩展" class="headerlink" title="异或运算的性质与扩展"></a>异或运算的性质与扩展</h3><blockquote><p>0^N &#x3D;&#x3D; N N^N &#x3D;&#x3D; 0<br>异或运算满足交换律和结合率<br>不用额外变量交换两个数<br><strong>一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数</strong><br><strong>一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找一个出现了奇数次的数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printOddTimesNum1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">eO</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> cur : arr) &#123;</span><br><span class="line">eO ^= cur;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(eO);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找两个出现了奇数次的数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printOddTimesNum2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">eO</span> <span class="operator">=</span> <span class="number">0</span>, eOhasOne = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> curNum : arr) &#123;</span><br><span class="line">eO ^= curNum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">rightOne</span> <span class="operator">=</span> eO &amp; (~eO + <span class="number">1</span>);<span class="comment">//提取最右边的1出来</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> cur : arr) &#123;</span><br><span class="line">            <span class="comment">//当这个数的最右边一位1 与rightOne 相同时，才将它异或进去</span></span><br><span class="line"><span class="keyword">if</span> ((cur &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">eOhasOne ^= cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(eOhasOne + <span class="string">&quot; &quot;</span> + (eO ^ eOhasOne));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="master-公式"><a href="#master-公式" class="headerlink" title="master 公式"></a>master 公式</h3><blockquote><p>Master 公式用来较为简便地评估递归算法的时间复杂度</p></blockquote><p><strong>T(N) &#x3D; a*T(N&#x2F;b) + O(N^d)</strong></p><p>log (b,a) &gt; d -&gt; 复杂度为 O (N^log (b,a))<br>log (b,a) &#x3D; d -&gt; 复杂度为 O (N^d * logN)<br>log (b,a) &lt; d -&gt; 复杂度为 O (N^d)</p><blockquote><p>其中</p><p>a：生成的子问题数（比如二叉树的递归遍历就是 a &#x3D; 2)<br>b：表示每次递归是母问题的 1&#x2F;b 的数据规模<br>N：母问题的数据规模<br>d：额外操作的次数</p></blockquote><p>参考：</p><p>【1】<a href="https://blog.csdn.net/qq_53098203/article/details/120896749">左神算法 - 基础 01 - 认识复杂度和简单排序算法</a></p><p>【2】[数据结构与算法中的 Master 公式](</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>sub_images</title>
      <link href="/sub-images/index.html"/>
      <url>/sub-images/index.html</url>
      
        <content type="html"><![CDATA[<div class="gallery">    <div class="fj-gallery  data" data-rowHeight="220" data-limit="10">    <span class="gallery-data">[]</span>    </div>    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>    </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>images</title>
      <link href="/images/index.html"/>
      <url>/images/index.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://source.fomal.cc/img/default_cover_61.webp' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">封面专区</div>  <p>本站用作文章封面的图片，不保证分辨率</p>  <a href='/box/Gallery/photo'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://source.fomal.cc/img/dm11.webp' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">背景专区</div>  <p>收藏的一些的背景与壁纸，分辨率很高</p>  <a href='/box/Gallery/wallpaper'></a>  </figcaption>  </figure>  </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Gallery</title>
      <link href="/Gallery/index.html"/>
      <url>/Gallery/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>music</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 文章页H1-H6图标样式效果 *//* 控制风车转动速度 4s那里可以自己调节快慢 */h1::before,h2::before,h3::before,h4::before,h5::before,h6::before {  -webkit-animation: ccc 4s linear infinite;  animation: ccc 4s linear infinite;}/* 控制风车转动方向 -1turn 为逆时针转动，1turn 为顺时针转动，相同数字部分记得统一修改 */@-webkit-keyframes ccc {  0% {    -webkit-transform: rotate(0deg);    transform: rotate(0deg);  }  to {    -webkit-transform: rotate(-1turn);    transform: rotate(-1turn);  }}@keyframes ccc {  0% {    -webkit-transform: rotate(0deg);    transform: rotate(0deg);  }  to {    -webkit-transform: rotate(-1turn);    transform: rotate(-1turn);  }}/* 设置风车颜色 */#content-inner.layout h1::before {  color: #ef50a8;  margin-left: -1.55rem;  font-size: 1.3rem;  margin-top: -0.23rem;}#content-inner.layout h2::before {  color: #fb7061;  margin-left: -1.35rem;  font-size: 1.1rem;  margin-top: -0.12rem;}#content-inner.layout h3::before {  color: #ffbf00;  margin-left: -1.22rem;  font-size: 0.95rem;  margin-top: -0.09rem;}#content-inner.layout h4::before {  color: #a9e000;  margin-left: -1.05rem;  font-size: 0.8rem;  margin-top: -0.09rem;}#content-inner.layout h5::before {  color: #57c850;  margin-left: -0.9rem;  font-size: 0.7rem;  margin-top: 0rem;}#content-inner.layout h6::before {  color: #5ec1e0;  margin-left: -0.9rem;  font-size: 0.66rem;  margin-top: 0rem;}/* s设置风车hover动效 6s那里可以自己调节快慢*/#content-inner.layout h1:hover,#content-inner.layout h2:hover,#content-inner.layout h3:hover,#content-inner.layout h4:hover,#content-inner.layout h5:hover,#content-inner.layout h6:hover {  color: var(--theme-color);}#content-inner.layout h1:hover::before,#content-inner.layout h2:hover::before,#content-inner.layout h3:hover::before,#content-inner.layout h4:hover::before,#content-inner.layout h5:hover::before,#content-inner.layout h6:hover::before {  color: var(--theme-color);  -webkit-animation: ccc 6s linear infinite;  animation: ccc 6s linear infinite;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>charts</title>
      <link href="/charts/index.html"/>
      <url>/charts/index.html</url>
      
        <content type="html"><![CDATA[<!-- 文章发布时间统计图 --><div id="posts-chart" data-start="2021-01" style="border-radius: 8px; height: 300px; padding: 10px;"></div><!-- 文章标签统计图 --><div id="tags-chart" data-length="10" style="border-radius: 8px; height: 300px; padding: 10px;"></div><!-- 文章分类统计图 --><div id="categories-chart" data-parent="true" style="border-radius: 8px; height: 300px; padding: 10px;"></div>]]></content>
      
    </entry>
    
    
  
</search>
