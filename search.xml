<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MyBatis解析（一）</title>
      <link href="/2023/04/20/MyBatis%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/04/20/MyBatis%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><h3 id="1-JDBC"><a href="#1-JDBC" class="headerlink" title="1.JDBC"></a>1.JDBC</h3><p>在没有ORM框架的时候，对数据库的操作都是直接通过jdbc来完成的，假如有一张t_user表，那操作流程如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">// 打开连接</span></span><br><span class="line">conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatisdb?characterEncoding=utf-8&amp;serverTimezone=UTC&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line">stmt = conn.createStatement();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id,user_name,real_name,password,age,d_id from t_user where id = 1&quot;</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);                                   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> rs.getint(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;user_name&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">realName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;real_name&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">did</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;d_id&quot;</span>);</span><br><span class="line">  user.setId(id);</span><br><span class="line">    user.setRealName(realName);</span><br><span class="line">    user.setUserName(userName);</span><br><span class="line">  user.setPassword(password);</span><br><span class="line">user.setDid(did);</span><br><span class="line"></span><br><span class="line">  System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的操作步骤是，首先在pom文件中引入MySQL驱动依赖，注意版本</p><ul><li>Class.forName注册驱动</li><li>获取一个Connection对象</li><li>创建一个Statement对象</li><li>execute()方法执行SQL语句，获取ResultSet结果集</li><li>通过ResultSet结果集给POJO的属性赋值</li><li>最后关闭相关的资源</li></ul><p>但是通过分析上面的代码可以发现，注册驱动，创建连接，关闭资源这些步骤都是重复的</p><p>而获取结果集这一步其实做的工作是很相似的，也可以使用配置完成</p><p>执行sql则也没什么不一样的地方，所以上面的整个步骤过程，其实完全可以搞一个模版来完成，只需要修改sql和结果集映射就行了，其他地方统一处理</p><h3 id="2-优化代码"><a href="#2-优化代码" class="headerlink" title="2.优化代码"></a>2.优化代码</h3><p>首先是创建连接，关闭连接这一部分代码，可以抽取出来进行封装成一个工具类，此处为类DBUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_URL ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_NAME ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_PASSWORD ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  Connection conn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> DBUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(in);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 读取配置文件</span></span><br><span class="line">        JDBC_URL = properties.getProperty(<span class="string">&quot;JDBC_URL&quot;</span>);</span><br><span class="line">        JDBC_NAME = properties.getProperty(<span class="string">&quot;JDBC_NAME&quot;</span>);</span><br><span class="line">        JDBC_PASSWORD = properties.getProperty(<span class="string">&quot;JDBC_PASSWORD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(conn == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                conn = DriverManager.getConnection(JDBC_URL,JDBC_NAME,JDBC_PASSWORD);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn )</span>&#123;</span><br><span class="line">        close(conn,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn, Statement sts )</span>&#123;</span><br><span class="line">        close(conn,sts,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn, Statement sts , ResultSet rs)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sts != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sts.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是结果集映射，此处也可以进行封装，这里从原数据和反射这两方面入手</p><blockquote><p>所谓元数据，就是对应数据库表的列数据，可以把这里的字段自动映射成驼峰，反射创建结果集数据</p></blockquote><p>最终封装结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据字段名称设置 对象的属性</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> o 存储结果集的对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> columnName o的字段名称</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValueForColumn</span><span class="params">(Object o, String columnName,Object columnValue)</span> &#123;</span><br><span class="line">      Class&lt;?&gt; clazz = o.getClass();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 根据字段获取属性</span></span><br><span class="line">          <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnName);</span><br><span class="line">          <span class="comment">// 私有属性放开权限</span></span><br><span class="line">          field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">          field.set(o,columnValue);</span><br><span class="line">          field.setAccessible(<span class="literal">false</span>);</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">          <span class="comment">// 说明不存在 那就将 _ 转换为 驼峰命名法  user_name  --&gt; userName</span></span><br><span class="line">          <span class="keyword">if</span>(columnName.contains(<span class="string">&quot;_&quot;</span>))&#123;</span><br><span class="line">              <span class="type">Pattern</span> <span class="variable">linePattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;_(\\w)&quot;</span>);</span><br><span class="line">              columnName = columnName.toLowerCase();</span><br><span class="line">              <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> linePattern.matcher(columnName);</span><br><span class="line">              <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">              <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">                  matcher.appendReplacement(sb, matcher.group(<span class="number">1</span>).toUpperCase());</span><br><span class="line">              &#125;</span><br><span class="line">              matcher.appendTail(sb);</span><br><span class="line">              <span class="comment">// 再次调用复制操作</span></span><br><span class="line">              setFieldValueForColumn(o,sb.toString(),columnValue);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此时已经完成了通用部分的处理，那么剩下的自然就是DML操作的实现了，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行数据库的DML操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">update</span><span class="params">(String sql,Object ... parameter)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    conn = getConnection();</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="keyword">if</span>(parameter != <span class="literal">null</span> &amp;&amp; parameter.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameter.length; i++) &#123;</span><br><span class="line">            ps.setObject(i+<span class="number">1</span>,parameter[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">    close(conn,ps);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询方法的简易封装</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">query</span><span class="params">(String sql, Class clazz, Object ... parameter)</span> <span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">    conn = getConnection();</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="keyword">if</span>(parameter != <span class="literal">null</span> &amp;&amp; parameter.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameter.length; i++) &#123;</span><br><span class="line">            ps.setObject(i+<span class="number">1</span>,parameter[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line">    <span class="comment">// 获取对应的表结构的元数据</span></span><br><span class="line">    <span class="type">ResultSetMetaData</span> <span class="variable">metaData</span> <span class="operator">=</span> ps.getMetaData();</span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">        <span class="comment">// 根据 字段名称获取对应的值 然后将数据要封装到对应的对象中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> metaData.getColumnCount();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; columnCount+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 根据每列的名称获取对应的值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">columnName</span> <span class="operator">=</span> metaData.getColumnName(i);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">columnValue</span> <span class="operator">=</span> rs.getObject(columnName);</span><br><span class="line">            setFieldValueForColumn(o,columnName,columnValue);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add((T) o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后写一下测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">JdbcTest</span>().queryUser();</span><br><span class="line">       <span class="comment">//new JdbcTest().addUser();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 通过JDBC查询用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id,user_name,real_name,password,age,d_id from t_user where id = ?&quot;</span>;</span><br><span class="line">            List&lt;User&gt; list = DBUtils.query(sql, User.class,<span class="number">2</span>);</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过JDBC实现添加用户信息的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO T_USER(user_name,real_name,password,age,d_id)values(?,?,?,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DBUtils.update(sql,<span class="string">&quot;wangwu&quot;</span>,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;111&quot;</span>,<span class="number">22</span>,<span class="number">1001</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，此时用户可以很方便的使用查询与更新操作，而免去了之前的冗余操作</p><p>事实上，有很多公司在这个基础上确实实现了一些数据库操作工具的封装，如Apache DBUtils、SpringJDBC（jdbcTemplate）</p><p>但是上面这些工具还是有些简陋的，实际上在开发中，用的较多的是专业的ORM持久层框架，Hibernate和MyBatis这些</p><h2 id="二、ORM框架"><a href="#二、ORM框架" class="headerlink" title="二、ORM框架"></a>二、ORM框架</h2><h3 id="1-ORM介绍"><a href="#1-ORM介绍" class="headerlink" title="1.ORM介绍"></a>1.ORM介绍</h3><p>什么叫ORM框架呢？</p><p>全称是ORM（Object Relational Mapping），即对象关系映射</p><p>所谓对象，即程序中的对象，关系就是它和数据库里面数据的关系</p><p>因此，ORM框架解决的就是程序对象和关系型数据库的相互映射问题</p><h3 id="2-Hibernate"><a href="#2-Hibernate" class="headerlink" title="2.Hibernate"></a>2.Hibernate</h3><blockquote><p>Hibernate是一个全映射的ORM框架，所谓全映射，就是它可以自动的帮我们处理对象到数据库和数据库到对象的映射关系</p><p>相对应地，半ORM框架MyBatis就要求用户自己编写数据库到结果集的映射关系</p></blockquote><p>Hibernate的出现大大简化了我们的数据库操作，同时也能够更好的应对更加复杂的业务场景</p><p>Hibernate具有如下的特点</p><ul><li>根据数据库方言自定生成SQL，移植性好</li><li>自动管理连接资源</li><li>实现了对象和关系型数据的完全映射，操作对象就像操作数据库记录一样</li><li>提供了缓存机制</li></ul><p>Hibernate在处理复杂业务的时候同样也存在一些问题</p><ul><li>比如API中的get(),update()和save()方法，操作的实际上是所有的字段，没有办法指定部分字段，不够灵活</li><li>自定生成SQL的方式，如果要基于SQL去做一些优化的话，也是非常困难的</li><li>不支持动态SQL，比如分表中的表名，条件，参数变化等，无法根据条件自动生成SQL</li></ul><p>因此，更加灵活的框架MyBatis就出现了</p><h3 id="3-MyBatis"><a href="#3-MyBatis" class="headerlink" title="3.MyBatis"></a>3.MyBatis</h3><p>MyBatis是一个半映射的ORM的持久层框架，为什么是半映射的ORM呢？</p><p>因为像Hibernate这种全映射的ORM框架，因为封装程度太高，导致sql语句不够灵活，并且还需要学习他的HQL语言，配置也更为复杂，相对而言，MyBatis的sql和代码是分离开的，对于用户来说，只要会写sql就能用mybatis，基本省却了很大的学习成本</p><blockquote><p>半映射和全映射</p><ul><li>半映射：半映射即指实体类和数据库表之间的映射是部分的，即只映射了实体类中需要持久化到数据库的属性，而忽略了其他的属性。在半映射方式下，开发人员需要手动编写SQL语句，执行数据库操作</li><li>全映射：全映射指实体类和数据库表之间的映射是完全的，即实体类中的所有属性都需要持久化到数据库中。在全映射方式下，ORM框架会自动将实体类映射为数据库表，并自动执行相应的数据库操作，开发人员不需要手动编写SQL语句</li></ul></blockquote><h2 id="三、MyBatis详解"><a href="#三、MyBatis详解" class="headerlink" title="三、MyBatis详解"></a>三、MyBatis详解</h2><p>在MyBatis当中，最核心的配置主要就两个，一个是全局配置文件，一个是映射文件</p><p>那么他们都有什么作用呢？下面分别介绍</p><h3 id="1-全局配置文件"><a href="#1-全局配置文件" class="headerlink" title="1.全局配置文件"></a>1.全局配置文件</h3><p>MyBatis的全局配置文件在全局层面规定了MyBatis的行为和属性信息，配置文件的顶层结构如下</p><ul><li>configuration（配置）</li><li>properties（属性）</li><li>settings（设置）</li><li>typeAliases（类型别名）</li><li>typeHandlers（类型处理器）</li><li>objectFactory（对象工厂）</li><li>plugins（插件）</li><li>environment（环境配置）<ul><li>environment（环境变量）<ul><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li></ul></li></ul></li><li>databaseIdProvider（数据库厂商标识）</li><li>mappers（映射器）</li></ul><h4 id="1-1-configuration"><a href="#1-1-configuration" class="headerlink" title="1.1 configuration"></a>1.1 configuration</h4><p>它是整个配置文件的根标签，实际上也对应着MyBatis里面最重要的配置类Configuration</p><h4 id="1-2-properties"><a href="#1-2-properties" class="headerlink" title="1.2 properties"></a>1.2 properties</h4><p>第一个一级标签是properities，用来配置参数信息，例如最常见的数据库连接信息</p><p>一般来说，这些参数都是放在properties文件中的，让你好使用$符号把参数引入，这样就可以统一在参数文件中修改参数</p><h4 id="1-3-settings"><a href="#1-3-settings" class="headerlink" title="1.3 settings"></a>1.3 settings</h4><p>这个参数在MyBatis当中极为重要，规定了MyBatis运行时的行为，包含大量子标签，常用如下</p><ul><li><code>cacheEnabled</code>：是否启用缓存，默认为<code>true</code>。</li><li><code>lazyLoadingEnabled</code>：是否启用延迟加载，默认为<code>false</code>。</li><li><code>multipleResultSetsEnabled</code>：是否允许返回多个结果集（游标），默认为<code>true</code>。</li><li><code>useColumnLabel</code>：是否使用列标签代替列名，如果设置为<code>true</code>，则会优先使用列标签。默认为<code>true</code>。</li><li><code>useGeneratedKeys</code>：是否使用自动生成的主键，如果设置为<code>true</code>，则会使用数据库自动生成的主键作为实体类的主键。默认为<code>false</code>。</li><li><code>defaultExecutorType</code>：默认的执行器类型，可选值为<code>SIMPLE</code>、<code>REUSE</code>、<code>BATCH</code>。默认为<code>SIMPLE</code>。</li><li><code>defaultStatementTimeout</code>：默认的SQL语句执行超时时间（秒），默认为<code>null</code>，表示没有超时时间限制。</li><li><code>logImpl</code>：指定MyBatis的日志实现类。</li><li><code>autoMappingBehavior</code>：自动映射行为，可选值为<code>PARTIAL</code>、<code>FULL</code>、<code>NONE</code>，默认为<code>PARTIAL</code>。</li><li><code>mapUnderscoreToCamelCase</code>：是否将下划线分隔的列名转换为驼峰式命名的属性名，如果设置为<code>true</code>，则会将<code>user_name</code>转换为<code>userName</code>。</li><li><code>defaultScriptingLanguage</code>：默认的动态SQL语言，可选值为<code>XML</code>、<code>RAW</code>、<code>#&#123;&#125;</code>、<code>$&#123;&#125;</code>，默认为<code>XML</code>。</li></ul><p>除了上述属性外，<code>settings</code>标签还可以包含其他的属性，具体可以参考MyBatis官方文档</p><p>下面看一个项目中实际用到的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使全局的映射器启用或禁用缓存。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 是否允许单条sql 返回多个数据集  (取决于驱动的兼容性) default:true --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;multipleResultSetsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useColumnLabel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 允许JDBC 生成主键。需要驱动器支持。如果设为了true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。  default:false  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定 MyBatis 如何自动映射 数据基表的列 NONE：不隐射　PARTIAL:部分  FULL:全部  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PARTIAL&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这是默认的执行类型  （SIMPLE: 简单； REUSE: 执行器可能重复使用prepared statements语句；BATCH: 执行器可以重复执行语句和批量更新）  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SIMPLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用驼峰命名法转换字段。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置本地缓存范围 session:就会有数据的共享  statement:语句范围 (这样就不会有数据的共享 ) defalut:session --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置但JDBC类型为空时,某些驱动程序 要指定值,default:OTHER，插入空值时不需要指定类型 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTypeForNull&quot;</span> <span class="attr">value</span>=<span class="string">&quot;NULL&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--输出日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-4-typeAliases"><a href="#1-4-typeAliases" class="headerlink" title="1.4 typeAliases"></a>1.4 typeAliases</h4><p>typeAliases是类型的别名，根linux中的alias一样，主要用来简化类名全路径的拼写</p><p>如下使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.zjyan.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>事实上，在MyBatis当中有很多系统预先定义好的类型别名，在TypeAliasRegistry中，这也是为什么可以直接用string代替java.lang.String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TypeAliasRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;string&quot;</span>, String.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;byte&quot;</span>, Byte.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;long&quot;</span>, Long.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;short&quot;</span>, Short.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;int&quot;</span>, Integer.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;integer&quot;</span>, Integer.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;double&quot;</span>, Double.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;float&quot;</span>, Float.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;boolean&quot;</span>, Boolean.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;byte[]&quot;</span>, Byte[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;long[]&quot;</span>, Long[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;short[]&quot;</span>, Short[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;int[]&quot;</span>, Integer[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;integer[]&quot;</span>, Integer[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;double[]&quot;</span>, Double[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;float[]&quot;</span>, Float[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;boolean[]&quot;</span>, Boolean[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;_byte&quot;</span>, Byte.TYPE);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;_long&quot;</span>, Long.TYPE);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;_short&quot;</span>, Short.TYPE);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;_int&quot;</span>, Integer.TYPE);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;_integer&quot;</span>, Integer.TYPE);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;_double&quot;</span>, Double.TYPE);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;_float&quot;</span>, Float.TYPE);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;_boolean&quot;</span>, Boolean.TYPE);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;_byte[]&quot;</span>, <span class="type">byte</span>[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;_long[]&quot;</span>, <span class="type">long</span>[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;_short[]&quot;</span>, <span class="type">short</span>[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;_int[]&quot;</span>, <span class="type">int</span>[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;_integer[]&quot;</span>, <span class="type">int</span>[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;_double[]&quot;</span>, <span class="type">double</span>[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;_float[]&quot;</span>, <span class="type">float</span>[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;_boolean[]&quot;</span>, <span class="type">boolean</span>[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;date&quot;</span>, Date.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;decimal&quot;</span>, BigDecimal.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;bigdecimal&quot;</span>, BigDecimal.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;biginteger&quot;</span>, BigInteger.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;object&quot;</span>, Object.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;date[]&quot;</span>, Date[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;decimal[]&quot;</span>, BigDecimal[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;bigdecimal[]&quot;</span>, BigDecimal[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;biginteger[]&quot;</span>, BigInteger[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;object[]&quot;</span>, Object[].class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;map&quot;</span>, Map.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;hashmap&quot;</span>, HashMap.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;list&quot;</span>, List.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;arraylist&quot;</span>, ArrayList.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;collection&quot;</span>, Collection.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;iterator&quot;</span>, Iterator.class);</span><br><span class="line">        <span class="built_in">this</span>.registerAlias(<span class="string">&quot;ResultSet&quot;</span>, ResultSet.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-TypeHandler"><a href="#1-5-TypeHandler" class="headerlink" title="1.5 TypeHandler"></a>1.5 TypeHandler</h4><p>这个关键字主要用于数据转换，什么是数据转换，又为什么需要数据转换呢？</p><p>比如写的接收查询结果的java类和数据库字段存在类型不一致，字段名称不一样的情况，要怎么办呢？</p><p>比如参数类型的返回是varchar，那么是如何转换成String类型的呢？</p><p>首先，常见的varchar转String这种类型转换由MyBatis内置的TypeHandler处理就够了，MyBatis会自动的将这些需要转换的类型进行处理</p><p>那么开发者什么时候用得到这些功能呢？如何使用呢？</p><p>一般来说，开发者可以自定义一个TypeHandler来处理不同的数据转换任务，比如写一个查询结果是字符且值为“zhangsan”的话，就添加666的处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的类型处理器</span></span><br><span class="line"><span class="comment"> *    处理的字段如果是 String类型的话就 且 内容是 zhangsan 拼接个信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*@MappedJdbcTypes(JdbcType.VARCHAR)</span></span><br><span class="line"><span class="comment">@MappedTypes(String.class)*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTypeHandler</span> <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据的时候回调的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ps</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jdbcType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, String parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//System.out.println(&quot;---------------setNonNullParameter1：&quot;+parameter);</span></span><br><span class="line">        ps.setString(i, parameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(columnName);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;zhangsan&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> name+<span class="string">&quot;666&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(columnIndex);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;zhangsan&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> name+<span class="string">&quot;666&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNullableResult</span><span class="params">(CallableStatement cs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cs.getString(columnIndex);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;zhangsan&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> name+<span class="string">&quot;666&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果想使上面的handler生效，还需要typeHandlers配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;com.zjyan.type.MyTypeHandler&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeHandler</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当然，typeHandler不止上面这种简单的用法，试想一下，假如查询的字段中，有好几个字段都需要按照枚举id字段取对应的name值，那使用typeHandler是不是就可以避免再单独对字段进行转换的工作了？</p></blockquote><h4 id="1-6-objectFactory"><a href="#1-6-objectFactory" class="headerlink" title="1.6 objectFactory"></a>1.6 objectFactory</h4><p>当查询到数据库的结果集，将结果集转换为实体类的时候，是不是需要创建一个新的对象接收这些结果？那当然就需要创建对象了！</p><p>但是我们不知道需要创建什么类型的对象，对象有哪些属性都不清楚，所以需要使用反射来创建</p><p>而ObjectFactory就是MyBatis提供出来，专门创建对象实例的工厂接口！</p><p>它定义了四个方法，并且在MyBatis当中有多个实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span>&#123;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span>&#123;</span><br><span class="line">      <span class="comment">// NOP</span></span><br><span class="line">    &#125; </span><br><span class="line">  &lt;T&gt; T <span class="title function_">creat</span><span class="params">(Class&lt;T&gt; type)</span>;</span><br><span class="line">  &lt;T&gt; T <span class="title function_">creat</span><span class="params">(Class&lt;T&gt; type,List&lt;Class&lt;?&gt;&gt; constructorArgTypes,List&lt;Object&gt; constructorArgs)</span>;</span><br><span class="line">  &lt;T&gt; BOOLEAN <span class="title function_">ISCOLLECTION</span><span class="params">(CLASS&lt;T&gt; TYPE)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-7-plugins"><a href="#1-7-plugins" class="headerlink" title="1.7 plugins"></a>1.7 plugins</h4><p>预留的插件接口</p><h4 id="1-8-environments"><a href="#1-8-environments" class="headerlink" title="1.8 environments"></a>1.8 environments</h4><p>在MyBatis中，<code>environments</code>标签用于配置数据源以及事务管理器。<code>environments</code>标签可以包含多个<code>environment</code>子标签，每个<code>environment</code>子标签用于定义一个数据源及其对应的事务管理器。一个<code>environment</code>标签包含三个子标签：</p><ol><li><code>transactionManager</code>：用于配置事务管理器，可以使用JDBC、MANAGED等事务管理器</li><li><code>dataSource</code>：用于配置数据源，可以使用JNDI、UNPOOLED、POOLED等数据源</li><li><code>id</code>：用于指定环境的唯一标识符</li></ol><p>使用方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-9-mappers"><a href="#1-9-mappers" class="headerlink" title="1.9 mappers"></a>1.9 mappers</h4><p><mappers>标签配置的是映射器，也就是Mapper.xml的路径</p><p>这里配置的目的是让MyBatis启动的时候去扫描这些映射器，创建映射关系</p><p>可以使用相对路径，也能绝对路径配置，其实主要就两种配置方式，分别如下：</p><p>在<code>mapper</code>标签的<code>resource</code>属性中指定Mapper XML文件的路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/example/MyMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>mapper</code>标签的<code>class</code>属性中指定Mapper接口的全限定类名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.example.MyMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-映射文件"><a href="#2-映射文件" class="headerlink" title="2.映射文件"></a>2.映射文件</h3><p>上面1.9就是用来指定要扫描的映射文件的，那么映射文件什么格式，怎么用呢？</p><p>MyBatis的映射文件主要用于定义SQL语句、参数映射以及结果映射等信息。MyBatis的映射文件是基于XML格式的，每个映射文件都是以一个顶级元素开始，下面是MyBatis映射文件的顶级元素及其用途</p><ul><li><code>mapper</code>元素：这是映射文件的根元素，用于指定Mapper接口的全限定类名或者Mapper XML文件的位置。在<code>mapper</code>元素中可以包含多个子元素，包括<code>select</code>、<code>insert</code>、<code>update</code>、<code>delete</code>、<code>resultMap</code>等</li><li><code>select</code>元素：用于定义查询SQL语句以及参数映射和结果射等信息。</li><li><code>insert</code>元素：用于定义插入SQL语句以及参数映射等信息</li><li><code>update</code>元素：用于定义更新SQL语句以及参数映射等信息</li><li><code>delete</code>元素：用于定义删除SQL语句以及参数映射等信息</li><li><code>sql</code>元素：用于定义可重用的SQL片段，这些SQL片段可以在其他SQL语句中通过<code>include</code>元素进行引用</li><li><code>parameterMap</code>元素：用于定义输入参数的映射关系，已逐渐废弃</li><li><code>resultMap</code>元素：用于定义输出结果的映射关系，最常用也是最强大的功能</li><li><code>cache</code>元素：用于配置缓存策略，是否开启二级缓存</li></ul><p>映射文件中的这些顶级元素可以按照需要进行组合，以定义不同的SQL语句、参数映射以及结果映射等信息。在使用MyBatis时，通常需要根据具体的需求选择相应的元素进行配置，从而实现数据的持久化操作。</p><h3 id="3-动态sql"><a href="#3-动态sql" class="headerlink" title="3.动态sql"></a>3.动态sql</h3><p>动态SQL是MyBatis中一个非常强大的特性，可以根据不同的条件动态生成SQL语句，可以大大提高SQL语句的重用性和可维护性。MyBatis提供了多个标签来实现动态SQL，下面介绍几个常用的标签及其用法</p><p>1）<code>if</code>标签：用于判断某个条件是否成立，如果成立，则执行if标签内的SQL语句。</p><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM user</span><br><span class="line">  WHERE 1 = 1</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">    AND name = #&#123;name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null&quot;</span>&gt;</span></span><br><span class="line">    AND age = #&#123;age&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）<code>choose</code>标签：类似于Java中的switch语句，根据某个条件选择不同的SQL语句执行。</p><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vbnetCopy code</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM user</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;orderBy == &#x27;name&#x27;&quot;</span>&gt;</span></span><br><span class="line">        ORDER BY name</span><br><span class="line">      <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;orderBy == &#x27;age&#x27;&quot;</span>&gt;</span></span><br><span class="line">        ORDER BY age</span><br><span class="line">      <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        ORDER BY id</span><br><span class="line">      <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）<code>foreach</code>标签：用于循环遍历集合或数组，生成对应的SQL语句。</p><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqlCopy code</span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUsers&quot;</span>&gt;</span></span><br><span class="line">  DELETE FROM user WHERE id IN</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">    #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4）<code>set</code>标签：用于更新操作，生成SET关键字后面的动态内容。</p><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  UPDATE user</span><br><span class="line">  <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">      name = #&#123;name&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null&quot;</span>&gt;</span></span><br><span class="line">      age = #&#123;age&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上标签是MyBatis中常用的动态SQL标签，通过这些标签的灵活组合，可以动态生成复杂的SQL语句，满足各种不同的查询、更新、删除等操作的需求</p><h3 id="4-延迟加载"><a href="#4-延迟加载" class="headerlink" title="4.延迟加载"></a>4.延迟加载</h3><p>MyBatis的延迟加载（Lazy Loading）是指在查询数据时，只有在需要使用某个属性时才去加载该属性的值，而不是在查询时将所有属性都加载出来。这样可以提高查询效率和减少内存消耗。</p><p>MyBatis提供了两种延迟加载方式：</p><p><strong>1）</strong>延迟加载属性（Lazy Property Loading）：在查询时，只查询部分属性，需要使用某个属性时，再去查询该属性的值。这种方式需要在映射文件中配置属性的延迟加载方式。</p><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">select</span>=<span class="string">&quot;findDeptById&quot;</span> <span class="attr">lazyLoadingEnabled</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2）</strong>延迟加载集合属性（Lazy Collection Loading）：在查询时，只查询主实体，需要使用某个关联实体时，再去查询该关联实体的值。这种方式需要在映射文件中配置集合属性的延迟加载方式。</p><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;deptMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Department&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;users&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">select</span>=<span class="string">&quot;findUsersByDeptId&quot;</span> <span class="attr">lazyLoadingEnabled</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，MyBatis的延迟加载需要在SQLSession中开启延迟加载功能，即在配置文件中设置<code>defaultLazyLoadingEnabled</code>属性为<code>true</code>，或者在创建SQLSession时通过参数指定。</p><p>同时，延迟加载也会带来一些问题，例如多线程环境下可能会出现问题，需要开发人员根据具体情况进行选择和配置</p><h2 id="四、源码"><a href="#四、源码" class="headerlink" title="四、源码"></a>四、源码</h2><h3 id="1-SqlSessionFactory"><a href="#1-SqlSessionFactory" class="headerlink" title="1.SqlSessionFactory"></a>1.SqlSessionFactory</h3><p><img src="https://static-2w2.pages.dev/post/mybatis-sqlsession.png" alt="image-20230423212040325"></p><p>每次操作数据库，都需要创建一个会话SqlSession，而它就由一个全局的SqlSessionFactory来创建</p><p>那SqlSessionFactory由谁来创建呢？都有哪些参数和作用呢？</p><p>SqlSessionFactory由<code>SqlSessionFactoryBuilder().builder()</code>来创建，很明显的建造者模式</p><p>在这个builder内，使用xmlConfigBuilder完成了全局配置文件的加载与解析</p><p>同时，在这个xmlConfigBuilder内创建了Configuration对象，它包含type别名，全局配置文件等配置信息</p><p>最终，返回的SqlSessionFactory主要包含两部分内容，一个是Configuration配置信息，一个是DefaultSqlSessionFactory</p><h3 id="2-XMLConfigBuilder"><a href="#2-XMLConfigBuilder" class="headerlink" title="2.XMLConfigBuilder"></a>2.XMLConfigBuilder</h3><p><code>XMLConfigBuilder</code>是MyBatis中的一个重要类，它负责解析MyBatis配置文件，生成MyBatis的全局配置对象<code>Configuration</code>。在MyBatis启动时，<code>XMLConfigBuilder</code>会读取配置文件，并将其解析为Java对象。在解析过程中，它会对配置文件中的各种元素进行验证和解析，并将解析结果封装成<code>Configuration</code>对象的属性。</p><p>以下是<code>XMLConfigBuilder</code>的主要功能和解析过程：</p><ol><li>首先，<code>XMLConfigBuilder</code>会创建<code>Configuration</code>对象，并通过<code>XPathParser</code>类读取配置文件。<code>XPathParser</code>类是一个轻量级的XML解析器，它可以方便地处理XML配置文件。</li><li>然后，<code>XMLConfigBuilder</code>会对配置文件中的各个元素进行解析。它会根据配置文件中的标签和属性，创建相应的Java对象，并将它们设置为<code>Configuration</code>对象的属性。例如，<code>XMLConfigBuilder</code>会解析<code>&lt;properties&gt;</code>元素，创建<code>Properties</code>对象，并将其设置为<code>Configuration</code>对象的属性。</li><li>在解析过程中，<code>XMLConfigBuilder</code>还会对配置文件中的各种元素进行验证和检查，以确保它们的合法性。例如，<code>XMLConfigBuilder</code>会验证<code>&lt;mapper&gt;</code>元素的<code>resource</code>或<code>url</code>属性是否存在，是否正确等。</li><li>在解析完成后，<code>XMLConfigBuilder</code>会将<code>Configuration</code>对象返回给<code>SqlSessionFactoryBuilder</code>类，并将其用于创建<code>SqlSessionFactory</code>对象。此时，<code>Configuration</code>对象<strong>已经包含了所有的<font color="red">配置信息</font>，包括数据库连接信息、类型别名、映射器配置等。</strong></li></ol><p>总之，<code>XMLConfigBuilder</code>是MyBatis中的一个重要类，它负责解析MyBatis配置文件，并生成MyBatis的全局配置对象<code>Configuration</code>。在解析过程中，它会对配置文件中的各种元素进行验证和解析，并将解析结果封装成<code>Configuration</code>对象的属性。通过<code>XMLConfigBuilder</code>，MyBatis可以方便地读取和解析配置文件，并将其转换成Java对象</p><h3 id="3-核心流程"><a href="#3-核心流程" class="headerlink" title="3.核心流程"></a>3.核心流程</h3><p>在MyBatis当中，从配置文件加载，到最后执行sql语句，整体的流程如下所示</p><ul><li>获取SqlSessionFactory（工厂）对象</li><li>获取SqlSession（会话）对象</li><li>获取接口的<strong>代理</strong>对象（MapperProxy）</li><li>SQL语句执行（代理对象的invoke方法最后执行jdbc的方法）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ比较</title>
      <link href="/2023/04/16/MQ%E5%AF%B9%E6%AF%94/"/>
      <url>/2023/04/16/MQ%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>前面已经分析过不同MQ的实现原理，本文则对他们进行一个横向的对比，以便加深记忆，更加深刻的掌握不同消息队列的特性</p><h3 id="1-起源"><a href="#1-起源" class="headerlink" title="1.起源"></a>1.起源</h3><p><strong>RabbitMQ</strong></p><p>RabbitMQ起源于<strong>AMQP</strong>（Advanced Message Queuing Protocol，高级消息队列协议）标准</p><p>AMQP最初是由金融行业的一些公司共同制定的，旨在解决在金融系统中异步通信的需求</p><p>RabbitMQ是基于AMQP标准实现的消息队列中间件，最初由LShift开发，并在2007年成为开源项目</p><p>RabbitMQ<strong>使用Erlang语言</strong>开发，其设计目标是实现高可用、高可靠、高性能的分布式消息队列系统</p><p><strong>RocketMQ</strong></p><p>淘宝原来有一 个自研的 MQ 叫 Notify，Kafka 开源以后，就参考 Kafka 用 Java 语言写了 MetaQ， 所以在涉及思想上有很多跟 Kafka 相似的地方。后来改名字叫 RocketMQ，2012 年开源</p><p><strong>Kafka</strong></p><p>Kafka 是由 LinkedIn 公司开发的一种分布式、可扩展、高吞吐量的消息系统</p><p>它的设计灵感来自于 LinkedIn 在处理大规模实时数据处理和数据流的挑战中的经验和教训</p><p>Kafka 借鉴了消息队列的概念，但与传统的消息系统不同的是，Kafka 的设计重点放在了可扩展性和高吞吐量上</p><h3 id="2-整体对比"><a href="#2-整体对比" class="headerlink" title="2.整体对比"></a>2.整体对比</h3><table><thead><tr><th></th><th>RabbitMQ</th><th>Rocket</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>2.6w&#x2F;s（消息做持久化）</td><td>11.6w&#x2F;s</td><td>17.3w&#x2F;s</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Scala&#x2F;Java</td></tr><tr><td>主要维护者</td><td>Mozilla&#x2F;Spring</td><td>Alibaba</td><td>Apache</td></tr><tr><td>订阅形式</td><td>提供了4种，direct，Topic，Headers和fanout（广播模式）</td><td>基于Topic&#x2F;MessageTag，按照消息类型、属性进行正则匹配</br>发布-订阅模式</td><td>基于Topic，按照topic进行正则匹配</br>发布-订阅模式</td></tr><tr><td>持久化</td><td>支持少量堆积</td><td>支持大量堆积</td><td>支持大量堆积</td></tr><tr><td>顺序消息</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>集群方式</td><td>支持简单集群，镜像集群，对高级集群模式支持不好</td><td>常用多对Master-Slave模式，开源版本需要手动切换Slave变成Master</td><td>天然划分Leader-Slave，无状态集群，每台服务器既能是Master也能是Slave</td></tr><tr><td>性能稳定性</td><td>好</td><td>一般</td><td>较差</td></tr></tbody></table><h2 id="二、结构对比"><a href="#二、结构对比" class="headerlink" title="二、结构对比"></a>二、结构对比</h2><h3 id="1-整体对比"><a href="#1-整体对比" class="headerlink" title="1.整体对比"></a>1.整体对比</h3><p>首先是RabbitMQ，它的Broker是由<strong>Exchange</strong>和<strong>Queue</strong>来组成的</p><p><img src="https://static-2w2.pages.dev/post/mq-rabbitmq.png" alt="image-20230412202855830"></p><p>其次是RocketMQ，它并没有使用Zookeeper作为注册中心，而是自定义了NameServer这么个结构，可以认为Broker主机由NameServer与Broker Master+Broker Slave组成的，这里所谓的Master和Slave是指Broker的主副本Master和其他副本Slave，它可以有多个Broker结构</p><p><img src="https://static-2w2.pages.dev/post/mq-rocket-all.png" alt="image-20230415151544795"></p><p>最后是Kafka，它采用Zookeeper作为注册中心，负责维护Kafka机器的存活，状态等信息</p><p>在Kafka中，每个Topic划分出来了不同的Partition，它的Partition也是分Leader和Follewer的。其中Follower就是它的Leader的备份</p><p><img src="https://static-2w2.pages.dev/post/mq-kafka-replica.png" alt="image-20230413131142867"></p><h3 id="2-生产者"><a href="#2-生产者" class="headerlink" title="2.生产者"></a>2.生产者</h3><h4 id="2-1-RabbitMQ"><a href="#2-1-RabbitMQ" class="headerlink" title="2.1 RabbitMQ"></a>2.1 RabbitMQ</h4><p>RabbitMQ基于AMQP协议，所以RabbitMQ里面也引入了 Channel 的概念，它是一个虚拟的连接，把它翻译成通道，或者消息信道。这样我们就可以在保持的 TCP 长连接里面去创建和释放 Channel，大大了减少了资源消耗</p><blockquote><p>即交换机Exchange和生产者建立长链接，使用Channel发送消息</p></blockquote><p>rabbitMQ也支持事务，就是发送成功返回一个ack，表示发送成功了</p><h4 id="2-2-RocketMQ"><a href="#2-2-RocketMQ" class="headerlink" title="2.2 RocketMQ"></a>2.2 RocketMQ</h4><p>RocketMQ的生产者会定时从NameServer拉取路由信息(不用配置 RocketMQ 的服务地址)，然后根据路由信息与指定的 <strong>Broker</strong> 建立 TCP 长连接，从而将消息发送到 Broker 中</p><p>发送逻辑一致的 Producer 可以组成一个 Group，这个Group里的Pro</p><p>RocketMQ 的生产者同样支持批量发送，不过 List 要自己传进去</p><blockquote><p>即通过NameServer定时拉取路由信息，与Broker下的Master建立长链接，支持Group发送</p></blockquote><p>此外，观察下RocketMQ的结构</p><p><img src="https://static-2w2.pages.dev/post/mq-rocket-all.png" alt="image-20230415151544795"></p><p>在RocketMQ中，生产者根据Topic建立连接，但是这里的Topic是一个逻辑概念，可能是由多个Broker（Master-Slave）组成的，所以就产生了一个问题，那就是生产者要和谁建立联系，发给谁呢？</p><p>三种策略，轮询，随机或者未实现</p><p>此外，RocketMQ还支持事务消息，具体参考<a href="https://yzj.life/2023/04/03/MQ%E4%B9%8BRocketMQ/#1-3-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF">RocketMQ事务消息</a></p><h4 id="2-3-Kafka"><a href="#2-3-Kafka" class="headerlink" title="2.3 Kafka"></a>2.3 Kafka</h4><p>Kafka为了减少io次数，开辟了一个发送缓冲区，当缓冲区中发送的消息达到一个阈值之后，会将所有缓冲区中的消息一次发送给Broker</p><p>Kafka的事务是使用2PC思想来实现的，引入了有事务协调者TC，事务日志</p><h4 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h4><p>生产者，三者和Broker建立连接的过程就都不相同</p><p>RabbitMQ是和Exchange之间建立连接，Rocket需要用NameServer上同步过来的路由信息和Topic建立长链接，而Kafka则借助Zookeeper获取路由信息，再与Topic建立连接</p><p>RabbitMQ借助Channel发送消息，RocketMQ可以分Group发送，Kafka则先缓存再批量发送</p><p>此外，他们都支持事务机制，但是实现方式逐渐复杂</p><p>最后，rabbitMQ不支持顺序性</p><h3 id="3-消费者"><a href="#3-消费者" class="headerlink" title="3.消费者"></a>3.消费者</h3><h4 id="3-1-RabbitMQ"><a href="#3-1-RabbitMQ" class="headerlink" title="3.1 RabbitMQ"></a>3.1 <strong>RabbitMQ</strong></h4><p>支持Push和Pull模式</p><ul><li>Pull模式：对应的方法是 basicGet，消费者自己获取，实时性低一点，但是能根据自己消费能力获取</li><li>Push模式：对应的方法是 basicConsume，消息队列主动推送给消费者，实时性高，但是消费不过来可能造成消息积压</li></ul><h4 id="3-2-RocketMQ"><a href="#3-2-RocketMQ" class="headerlink" title="3.2 RocketMQ"></a>3.2 <strong>RocketMQ</strong></h4><p>在RocketMQ中，消费者有两种消费方式，分别是<strong>集群消费</strong>和<strong>广播消费</strong></p><ul><li>集群消费：多个消费者消费同一个Topic的消息，每个消费一部分</li><li>广播消费：每个消费者都会消费同一个Topic下的所有消息，每个都消费全部消息</li></ul><p>按照消费模型来说，RocketMQ也有两种模式，分别是<strong>Pull</strong>和<strong>Push</strong></p><ul><li>Pull：轮询从Broker拉取消息，使用长轮询实现，所谓长轮询就是如果轮询不到相关数据，就会hold住请求，等到有数据或者等一定时间后再返回，返回后客户端立即发起下一次长轮询</li><li>push：Broker推送给Consumer，但是在RocketMQ里面，这个模式实际上是依赖Pull实现的，在Pull模式基础上封装了一层，所以它不是真正的“推模式”</li></ul><p>消费逻辑一致的 Consumer 可以组成一个 Group，这时候消息会在 Consumer 之间负载</p><h4 id="3-3-Kafka"><a href="#3-3-Kafka" class="headerlink" title="3.3 Kafka"></a>3.3 <strong>Kafka</strong></h4><p>相比上面的Rocket和RabbitMQ都支持push和pull模式，Kafka的实现只有Pull模式</p><h4 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h4><p>只有Kafka只支持Pull模式消费，即消费者自己去拉取消费</p><p>三者都支持集群和广播消费，但是实现方式各有不同</p><p>RocketMQ和Kafka都有<strong>消费者组</strong>这个概念，即分组消费</p><h3 id="4-消息分发"><a href="#4-消息分发" class="headerlink" title="4.消息分发"></a>4.消息分发</h3><h4 id="4-1-RabbitMQ"><a href="#4-1-RabbitMQ" class="headerlink" title="4.1 RabbitMQ"></a>4.1 RabbitMQ</h4><p>事实上，消息分发主要是RabbitMQ上的，它指定了不同的方式将消息从交换机分发到Queue上</p><p>生产者与交换机之间，有一个routing Key，交换机与Queue之间有一个binding key</p><p>主要就是依据这两个key之间的关系进行分发</p><ul><li>direct：直连，两个key完全匹配时才能分发</li><li>topic：使用正则符号#和*匹配</li><li>fanout：广播，全都发，Queue都能收到</li></ul><p>每个消费者可以订阅多个queue，但是<strong>每个queue只能被一个消费者消费</strong></p><h4 id="4-2-RocketMQ"><a href="#4-2-RocketMQ" class="headerlink" title="4.2 RocketMQ"></a>4.2 RocketMQ</h4><p>在RocketMQ中，生产者与消费者都是依靠Topic进行联系的，但是需要注意，在RocketMQ中，Topic是一个逻辑概念，实际上是与Broker建立的联系，默认只有Master参与读写</p><p><strong>Topic 跟生产者和消费者都是多对多的关系，一个生产者可以发送消息到多个Topic，一个消费者也可以订阅多个Topic</strong></p><h4 id="4-3-Kafka"><a href="#4-3-Kafka" class="headerlink" title="4.3 Kafka"></a>4.3 Kafka</h4><p>首先，在Kafka中，生产和消费也都是与Topic来建立的连接</p><p>Kafka采用了分区的思想，一个Topic划分成了不同的Partition，而且每个Partition还采用了分Replica备份的思路，只有作为Leader的Partition具有读写能力，Follower只做灾备</p><p>所以很明显，无论生产者，还是消费者，都是和Partition建立的联系</p><p>在Kafka中，引入了消费者组的概念，用group id来配置，消费同一个 Topic 的消费者不一定是同一个组，<strong>只有 group id 相同的消费者才是同一个消费者组</strong></p><blockquote><p>此外注意:同一个 Group 中的消费者，不能消费相同的Partition——Partition 要在消费者之间分配</p></blockquote><h4 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h4><p>RocketMQ和Kafka都是和Topic建立连接，但是区别是，在RocketMQ中，Topic是一个抽象逻辑概念，在Kafka当中则是真的存在这么一个结构</p><p>RocketMQ可以无所顾忌，多对多随便连接，而Kafka要考虑消费者组，同一个组内的消费者不能消费同一个partition两次</p><h3 id="5-持久化"><a href="#5-持久化" class="headerlink" title="5.持久化"></a>5.持久化</h3><h4 id="5-1-RabbitMQ"><a href="#5-1-RabbitMQ" class="headerlink" title="5.1 RabbitMQ"></a>5.1 RabbitMQ</h4><p>内存与磁盘都存储数据，内存到阈值了就换页到磁盘，磁盘到阈值就卡住，不让生产了</p><h4 id="5-2-RocketMQ"><a href="#5-2-RocketMQ" class="headerlink" title="5.2 RocketMQ"></a>5.2 RocketMQ</h4><p>同一个Topic内的消息都写入到一个文件中</p><p>这样缺点是每个消费者都要维护已经消费到的位置</p><p>数据存在磁盘上还那么快是因为采用了Page Cache和零拷贝技术</p><p>Page Cache就是预读缓冲区</p><p>零拷贝就是直接把Page Cache的数据在用户空间中做一个地址映射，就可以直接读取内存了</p><p>这里的零拷贝采用的是MMAP</p><p><img src="https://static-2w2.pages.dev/post/mq-rocket-zero-copy.png" alt="image-20230415201901909"></p><h4 id="5-3-Kafka"><a href="#5-3-Kafka" class="headerlink" title="5.3 Kafka"></a>5.3 Kafka</h4><p>存储了很多不同格式的文件，比如日志文件，索引文件等，整体结构如下</p><p><img src="https://static-2w2.pages.dev/post/mq-kafka-topic2.png" alt="image-20230413160645706"></p><p>消息慢了要么删（老数据），要么压缩（只留最新key）</p><p>那为什么Kafka数据存储在磁盘还那么快呢？</p><p>顺序io：追加到文件末尾</p><p>索引</p><p>批量读写和压缩</p><p>零拷贝：直接从DMA到网卡，是sendfile形式零拷贝</p><p><img src="https://static-2w2.pages.dev/post/mq-kafka-zero-copy.png" alt="image-20230413185453985"></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>从上面的对比可以看出，三种消息队列虽然实现功能类似，但是实现方式有很大不同</p><p>算是相同功能每个都有自己的实现方案吧</p><p>此时再重新看一下这三者的一些区别</p><h3 id="1-吞吐量"><a href="#1-吞吐量" class="headerlink" title="1.吞吐量"></a>1.吞吐量</h3><p>为什么他们的吞吐量相差那么多呢？</p><p>RabbitMQ最慢，尽管它也做了很多优化，但是没用到零拷贝技术，每个连接都是单线程的</p><p>而RocketMQ相对快了些，他用多线程，预读取，零拷贝等技术，提升了吞吐量</p><p>Kafka更是使用了大量优化策略，文件结构，索引（根据offset找数据），零拷贝，数据压缩等方法，使得它的吞吐量得到了极大的提升</p><h3 id="2-订阅方式"><a href="#2-订阅方式" class="headerlink" title="2.订阅方式"></a>2.订阅方式</h3><p>这里的区别，主要是由于他们各自的结构决定的</p><p>没什么好说的</p><h3 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3.常见问题"></a>3.常见问题</h3><h4 id="3-1-消息堆积怎么处理？"><a href="#3-1-消息堆积怎么处理？" class="headerlink" title="3.1 消息堆积怎么处理？"></a>3.1 消息堆积怎么处理？</h4><h4 id="3-2-他们仨有什么区别？"><a href="#3-2-他们仨有什么区别？" class="headerlink" title="3.2 他们仨有什么区别？"></a>3.2 他们仨有什么区别？</h4><h4 id="3-3-如何保证消费顺序性？"><a href="#3-3-如何保证消费顺序性？" class="headerlink" title="3.3 如何保证消费顺序性？"></a>3.3 如何保证消费顺序性？</h4><h4 id="3-4-如何保证消费幂等性？"><a href="#3-4-如何保证消费幂等性？" class="headerlink" title="3.4 如何保证消费幂等性？"></a>3.4 如何保证消费幂等性？</h4><h4 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h4>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty（一）netty基础</title>
      <link href="/2023/04/08/Netty/"/>
      <url>/2023/04/08/Netty/</url>
      
        <content type="html"><![CDATA[<h2 id="一、网络IO"><a href="#一、网络IO" class="headerlink" title="一、网络IO"></a>一、网络IO</h2><h3 id="1-同步阻塞IO（BIO）"><a href="#1-同步阻塞IO（BIO）" class="headerlink" title="1.同步阻塞IO（BIO）"></a>1.同步阻塞IO（BIO）</h3><img src="https://static-2w2.pages.dev/post/netty-bio.png" alt="image-20230415220229686" style="zoom: 50%;" /><p>如图所示，客户端向服务端发起一个数据读取请求，客户端在收到服务端返回数据之前，一直处于阻塞状态，直到服务端返回数据后完成本次会话，这个过程就叫同步阻塞IO</p><p>在BIO模型中如果想实现异步操作，就只能使用多线程模型，也就是一个请求对应一个线程，这样就能够避免服务端的链接被一 个客户端占用导致连接数无法提高</p><p>同步阻塞IO主要体现在两个阻塞点</p><ul><li>服务端接收客户端连接时的阻塞</li><li>客户端和服务端的IO通信时，数据未就绪的情况下的阻塞</li></ul><h3 id="2-非阻塞IO（NIO）"><a href="#2-非阻塞IO（NIO）" class="headerlink" title="2.非阻塞IO（NIO）"></a>2.非阻塞IO（NIO）</h3><p>非阻塞IO，就是客户端向服务端发起请求时，如果服务端的数据未就绪的情况下， 客户端请求不会被阻塞，而是直接返回</p><p>但是有可能服务端的数据还未准备好的时候，客户端收到的返回是一个空的， 那客户端怎么拿到最终的数据呢?</p><img src="https://static-2w2.pages.dev/post/netty-nio.png" alt="image-20230415220434627" style="zoom: 50%;" /><p>如图所示，客户端只能通过轮询的方式来获得请求结果</p><p>NIO相比BIO来说，少了阻塞的过程在性能和连接数上都会有明显提高，但是轮询过程中会有很多空轮询，而这个轮询会存在大量的系统调用（发起内核指令从网卡缓冲区中加载数据，用户空间到内核空间的切换），随着连接数量的增加，会导致性能问题（注意这个问题）</p><h3 id="3-多路复用机制"><a href="#3-多路复用机制" class="headerlink" title="3.多路复用机制"></a>3.多路复用机制</h3><p>I&#x2F;O多路复用的本质是通过一种机制（系统内核缓冲I&#x2F;O数据），让单个进程可以监视多个文件描述符， 一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作</p><blockquote><p>什么是fd？</p><p>在linux中，内核把所有的外部设备都当成是一个文件来操作，对一个文件的读写会调用内核提供的系统命令，返回一个fd（文件描述符）</p><p>而对于一个socket的读写也会有相应的文件描述符，成为socketfd</p></blockquote><p>见的IO多路复用方式有select、poll、epoll，都是Linux API提供的IO复用方式，那么接下来重 点讲一下select、和epoll这两个模型</p><ul><li><strong>select</strong>：进程可以通过把一个或者多个fd传递给select系统调用，进程会阻塞在select操作上，这样select可以帮我们检测多个fd是否处于就绪状态，这个模式有两个缺点<ul><li>由于他能够同时监听多个文件描述符，假如说有1000个，这个时候如果其中一个fd处于就绪 状态了，那么当前进程需要线性轮询所有的fd，也就是监听的fd越多，性能开销越大</li><li>同时，select在单个进程中能打开的fd是有限制的，默认是1024，对于那些需要支持单机上万的TCP连接来说确实有点少</li></ul></li><li><strong>epoll</strong>：linux还提供了epoll的系统调用，epoll是基于事件驱动方式来代替顺序扫描，因此性能相对来说更高，主要原理是，当被监听的fd中，有fd就绪时，会告知当前进程具体哪一个fd就绪，那么当前进程只需要去从指定的fd上读取数据即可，另外，epoll所能支持的fd上限是操作系统的最大文件句柄，这个数字要远远大于1024</li></ul><blockquote><p>由于epoll能够通过事件告知应用进程哪个fd是可读的，所以我们也称这种IO为异步非阻塞IO， 当然它是伪异步的，因为它还需要去把数据从内核同步复制到用户空间中，真正的异步非阻塞， 应该是数据已经完全准备好了，我只需要从用户空间读就行</p></blockquote><p>I&#x2F;O多路复用的好处是可以通过<strong>把多个I&#x2F;O的阻塞复用到同一个select的阻塞上</strong>，从而使得系统在单线程的情况下可以同时处理多个客户端请求</p><p>它的最大优势是系统开销小，并且不需要创建新的进程或者线程，降低了系统的资源开销，它的整体实现思想如图所示</p><img src="https://static-2w2.pages.dev/post/netty-io-paths.png" alt="image-20230415221125023" style="zoom:50%;" /><h3 id="4-异步IO"><a href="#4-异步IO" class="headerlink" title="4.异步IO"></a>4.异步IO</h3><p>异步IO和多路复用机制，最大的区别在于：</p><p>当数据就绪后，客户端不需要发送内核指令从内核空间读取数据，而是系统会异步把这个数据直接拷贝到用户空间，应用程序只需要直接使用该数据即可</p><img src="https://static-2w2.pages.dev/post/netty-aio.png" alt="image-20230415221441350" style="zoom:50%;" /><p><strong>在Java中，我们可以使用NIO的api来完成多路复用机制，实现伪异步IO</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelelectorExample</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    Selector selector;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//NIO</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.select();<span class="comment">//阻塞方法</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                SocketChannel socketChannel=(SocketChannel) selectionKeys.iterator().next().channel();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerSocketExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_PORT</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(DEFAULT_PORT);</span><br><span class="line">        System.out.println(<span class="string">&quot;启动服务，监听端口：&quot;</span> + DEFAULT_PORT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept(); <span class="comment">//阻塞式通信</span></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端：&quot;</span> + socket.getPort() + <span class="string">&quot;已连接&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                Socket socket;</span><br><span class="line">                <span class="keyword">public</span> Runnable <span class="title function_">setSocket</span><span class="params">(Socket s)</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.socket=s;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">                        <span class="type">String</span> <span class="variable">clientStr</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//读取一行信息</span></span><br><span class="line">                        <span class="comment">//如果客户端没有写数据过来，此时服务端处于阻塞状态</span></span><br><span class="line">                        clientStr = bufferedReader.readLine(); <span class="comment">//poll()</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端发了一段消息：&quot;</span> + clientStr);</span><br><span class="line">                        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">                        bufferedWriter.write(<span class="string">&quot;我已经收到你的消息了&quot;</span>);</span><br><span class="line">                        bufferedWriter.flush(); <span class="comment">//清空缓冲区触发消息发送</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.setSocket(socket)).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是很明显，在使用Java的NIO来实现IO多路复用时，代码不仅仅繁琐，而且使用起来很麻烦，所以Netty出现了</p><p><strong>Netty的I&#x2F;O模型是基于非阻塞IO实现的，底层依赖的是JDK NIO框架的多路复用器Selector来实现</strong></p><p>一个多路复用器Selector可以同时轮询多个Channel，采用epoll模式后，只需要一个线程负责Selector的轮询，就可以接入成千上万个客户端连接</p><h3 id="5-Reactor模型"><a href="#5-Reactor模型" class="headerlink" title="5.Reactor模型"></a>5.Reactor模型</h3><p>了解了NIO多路复用后，就可以引入Reactor多路复用高性能I&#x2F;O设计模式</p><p><strong>Reactor本质上就是基于NIO多路复用机制提出的一个高性能IO设计模式</strong>，它的核心思想是把响应IO事件和业务处理进行分离，通过一个或者多个线程来处理IO事件，然后将就绪得到事件分发到业务处理handlers线程去异步非阻塞处理，如图所示</p><img src="https://static-2w2.pages.dev/post/netty-reactor.png" alt="image-20230415221804023" style="zoom:50%;" /><blockquote><p>Reactor模型有三个重要的组件</p><ul><li>Reactor :将I&#x2F;O事件发派给对应的Handler </li><li>Acceptor :处理客户端连接请求 </li><li>Handlers :执行非阻塞读&#x2F;写</li></ul></blockquote><p>这是最基本的单Reactor单线程模型（整体的I&#x2F;O操作是由同一个线程完成的）</p><p>其中Reactor线程，负责多路分离套接字，有新连接到来触发connect 事件之后，交由Acceptor进行处理，有IO读写事件之后交给hanlder 处理</p><p>Acceptor主要任务就是构建handler ，在获取到和client相关的SocketChannel之后 ，绑定到相应的hanlder上，对应的SocketChannel有读写事件之后，基于racotor 分发，hanlder就可以处理了（所有的IO事件都绑定到selector上，由Reactor分发）</p><blockquote><p>Reactor 模式本质上指的是使用</p><p><strong>I&#x2F;O多路复用（I&#x2F;O mulyiplexing）+非阻塞I&#x2F;O（nonblocking I&#x2F;O）的模式</strong></p></blockquote><h3 id="6-多线程单Reactor模型"><a href="#6-多线程单Reactor模型" class="headerlink" title="6.多线程单Reactor模型"></a>6.多线程单Reactor模型</h3><p>单线程Reactor这种实现方式有存在着缺点，即handler的执行是串行的，如果其中一个handler处理线程阻塞将<strong>导致其他的业务处理阻塞</strong></p><p>由于handler和reactor在同一个线程中的执行，这也将导致新的无法接收新的请求</p><p>为了解决这种问题，有人提出使用多线程的方式来处理业务，也就是在业务处理的地方加入线程池异步处理，将reactor和handler在不同的线程来执行，如图所示</p><img src="https://static-2w2.pages.dev/post/netty-reactor-m.png" alt="image-20230415223217063" style="zoom:50%;" /><h3 id="7-多线程多Reactor模型"><a href="#7-多线程多Reactor模型" class="headerlink" title="7.多线程多Reactor模型"></a>7.多线程多Reactor模型</h3><p>在多线程单Reactor模型中，可以发现所有的I&#x2F;O操作是由一个Reactor来完成，而Reactor运行在单个线程中，它需要处理包括Accept()&#x2F;read()&#x2F;write&#x2F;connect操作，对于小容量的场景，影响不大；但是对于高负载、大并发或大数据量的应用场景时，容易成为瓶颈，主要原因如下:</p><ul><li>一个NIO线程同时处理成百上千的链路，性能上无法支撑，即便NIO线程的CPU负荷达到100%， 也无法满足海量消息的读取和发送</li><li>当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了NIO线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈</li></ul><p>所以，还可以更进一步优化，引入多Reactor多线程模式，如图所示，Main Reactor负责接收客户端的连接请求，然后把接收到的请求传递给SubReactor(其中subReactor可以有多个)，具体的业务IO处理由SubReactor完成</p><img src="https://static-2w2.pages.dev/post/netty-reactor-mm.png" alt="image-20230415223409441" style="zoom:50%;" /><blockquote><p>Multiple Reactors 模式通常也可以等同于 Master-Workers 模式，比如 Nginx 和Memcached 等就是采用这种多线程模型，虽然不同的项目实现细节略有区别，但总体来说模式是一致的</p></blockquote><ul><li>Acceptor，请求接收者，在实践时其职责类似服务器，并不真正负责连接请求的建立，而只将其请求委托 Main Reactor 线程池来实现，起到一个转发的作用</li><li>Main Reactor，主Reactor线程组，主要负责连接事件，并将IO读写请求转发到SubReactor线程池</li><li>Sub Reactor，Main Reactor通常监听客户端连接后会将通道的读写转发到 Sub Reactor 线程池中一个线程(负载均衡)，负责数据的读写。在 NIO中通常注册通道的读(OP_READ)、写事件</li></ul><h2 id="二、Netty"><a href="#二、Netty" class="headerlink" title="二、Netty"></a>二、Netty</h2><h3 id="1-为什么选择Netty？"><a href="#1-为什么选择Netty？" class="headerlink" title="1.为什么选择Netty？"></a>1.为什么选择Netty？</h3><p>上面介绍了几种网络IO与Reactor模型，那么它们和netty有什么关联呢？为什么要用netty？</p><p>netty其实就是一个<strong>高性能NIO框架</strong>，所以它是基于NIO基础上的封装，本质上是提供高性能网络IO通信的功能</p><p>Netty提供了上述三种Reactor模型的支持，我们可以通过Netty封装好的API来快速完成不同Reactor模型的开发，这也是为什么大家都选择Netty的原因之一，除此之外，Netty相比于NIO原生API，它有以下特点：</p><ul><li>提供了高效的I&#x2F;O模型、线程模型和时间处理机制 </li><li>提供非常简单易用的API，相比NIO来说，针对基础的Channel、Selector、Sockets、Buffers等api提供了更高层次的封装，屏蔽了NIO的复杂性</li><li>对数据协议和序列化提供了很好的支持</li><li>稳定性，Netty修复了JDK NIO较多的问题，比如select空转导致的cpu消耗100%、TCP断线重连、 keep-alive检测等问题</li><li>可扩展性在同类型的框架中都是做的非常好的，比如一个是可定制化的线程模型，用户可以在启动 参数中选择Reactor模型、 可扩展的事件驱动模型，将业务和框架的关注点分离</li><li>性能层面的优化，作为网络通信框架，需要处理大量的网络请求，必然就面临网络对象需要创建和 销毁的问题，这种对JVM的GC来说不是很友好，为了降低JVM垃圾回收的压力，引入了两种优化机制<ul><li>对象池复用</li><li>零拷贝技术</li></ul></li></ul><h3 id="2-Netty的生态介绍"><a href="#2-Netty的生态介绍" class="headerlink" title="2.Netty的生态介绍"></a>2.Netty的生态介绍</h3><p>首先，需要去了解Netty到底提供了哪些功能，如图所示，表示Netty生态中提供的功能说明</p><p>后续内容中会逐步的分析这些功能</p><img src="https://static-2w2.pages.dev/post/netty-life.png" alt="image-20230415224246805" style="zoom:50%;" /><h3 id="3-Netty使用"><a href="#3-Netty使用" class="headerlink" title="3.Netty使用"></a>3.Netty使用</h3><blockquote><p>需要说明一下，我们讲解的Netty版本是4.x版本，之前有一段时间netty发布了一个5.x版本，但是被官方舍弃了，原因是：使用ForkJoinPool增加了复杂性，并且没有显示出明显的性能优势。同时保持所有的分支同步是相当多的工作，没有必要</p></blockquote><h4 id="3-1-代码演示"><a href="#3-1-代码演示" class="headerlink" title="3.1 代码演示"></a>3.1 代码演示</h4><p>首先添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后是创建Netty Server服务</p><p>首先说明，大部分场景中，我们使用的主从多线程Reactor模型，Boss线程是主Reactor，Worker是从Reactor，他们分别使用不同的NioEventLoopGroup</p><p>主Reactor负责处理Accept，然后把Channel注册到从Reactor，从Reactor主要负责Channel生命周期内的所有I&#x2F;O事件</p><blockquote><p>参考上面一节的【7.多线程多Reactor模型】</p><p>Boss线程就是Main Reactor</p><p>Worker线程就是Sub Reactor</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyBasicServerExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="comment">// 我们要创建两个EventLoopGroup，</span></span><br><span class="line">        <span class="comment">// 一个是boss专门用来接收连接，可以理解为处理accept事件，</span></span><br><span class="line">        <span class="comment">// 另一个是worker，可以关注除了accept之外的其它事件，处理子任务。 </span></span><br><span class="line">      <span class="comment">//上面注意，boss线程一般设置一个线程，设置多个也只会用到一个，而且多个目前没有应用场景</span></span><br><span class="line">        <span class="comment">// worker线程通常要根据服务器调优，如果不写默认就是cpu的两倍。</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 服务端要启动，需要创建ServerBootStrap，</span></span><br><span class="line">            <span class="comment">// 在这里面netty把nio的模板式的代码都给封装好了</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            bootstrap.group(bossGroup, workerGroup) <span class="comment">//配置boss和worker线程</span></span><br><span class="line">                    <span class="comment">// 配置Server的通道，相当于NIO中的ServerSocketChannel</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// childHandler表示给worker那些线程配置了一个处理器，</span></span><br><span class="line">                    <span class="comment">// 配置初始化channel，也就是给worker线程配置对应的handler，当收到客户端的请求时，分配给指定的handler处理</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 添加handler，也就是具体的IO事件处理器</span></span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NormalMessageHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 由于默认情况下是NIO异步非阻塞，所以绑定端口后，通过sync()方法阻塞直到连接建立</span></span><br><span class="line">            <span class="comment">// 绑定端口并同步等待客户端连接(sync方法会阻塞，直到整个启动过程完成)</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.bind(port).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;Netty Server Started,Listening on :&quot;</span> + port); <span class="comment">//等待服务端监听端口关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">//释放线程资源</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NettyBasicServerExample</span>().bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码说明如下:</p><ul><li>EventLoopGroup，定义线程组，相当于之前在写NIO代码时定义的线程<ul><li>这里定义了两个线程组分别是boss线程和worker线程，boss线程负责接收连接，worker线程负责处理IO事件</li><li>boss线程一般设置一个线程，设置多个也只会用到一个，而且多个目前没有应用场景</li><li>而worker 线程通常要根据服务器调优，如果不写默认就是cpu的两倍。</li></ul></li><li>ServerBootstrap，服务端要启动，需要创建ServerBootStrap，在这里面netty把nio的模板式的代码都给封装好了</li><li>ChannelOption.SO_BACKLOG</li></ul><h4 id="3-2-设置Channel类型"><a href="#3-2-设置Channel类型" class="headerlink" title="3.2 设置Channel类型"></a>3.2 设置Channel类型</h4><p>NIO模型是Netty中最成熟也是被广泛引用的模型，因此在使用Netty的时候，我们会采用</p><p>NioServerSocketChannel作为Channel类型 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.channel(NioServerSocketChannel.class);</span><br></pre></td></tr></table></figure><p>除了NioServerSocketChannel以外，还提供了</p><ul><li>EpollServerSocketChannel，epoll模型,只有在linux kernel 2.6以上才能支持，在windows和mac 都是不支持的，如果设置Epoll在window环境下运行会报错</li><li>OioServerSocketChannel，用于服务端阻塞地接收TCP连接 </li><li>KQueueServerSocketChannel，kqueue模型，是Unix中比较高效的IO复用技术，常见的IO复用 技术有select, poll, epoll以及kqueue等等。其中epoll为Linux独占，而kqueue则在许多UNIX系统上存在</li></ul><h4 id="3-3-注册ChannelHandler"><a href="#3-3-注册ChannelHandler" class="headerlink" title="3.3 注册ChannelHandler"></a>3.3 注册ChannelHandler</h4><p>在Netty中可以通过ChannelPipeline注册多个ChannelHandler，该handler就是给到worker线程执行的处理器，当IO事件就绪时，会根据这里配置的Handler进行调用</p><p>这里可以注册多个ChannelHandler，每个ChannelHandler各司其职，比如做编码和解码的handler， 心跳机制的handler，消息处理的handler等。这样可以实现代码的最大化复用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 添加handler，也就是具体的IO事件处理器</span></span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NormalMessageHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure><p>ServerBootstrap中的childHandler方法需要注册一个ChannelHandler，这里配置了一个 ChannelInitializer的实现类，通过实例化ChannelInitializer来配置初始化Channel</p><p>当收到IO事件后，这个数据会在这多个handler中进行传播，上述代码中配置了一个 NormalMessageHandler，用来接收客户端消息并输出</p><h4 id="3-4-绑定端口"><a href="#3-4-绑定端口" class="headerlink" title="3.4 绑定端口"></a>3.4 绑定端口</h4><p>完成Netty的基本配置后，通过bind()方法真正触发启动，而sync()方法会阻塞，直到整个启动过程完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture channelFuture=bootstrap.bind(port).sync();</span><br></pre></td></tr></table></figure><h4 id="3-5-NormalMessageHandler"><a href="#3-5-NormalMessageHandler" class="headerlink" title="3.5 NormalMessageHandler"></a>3.5 NormalMessageHandler</h4><p>ServerHandler继承了ChannelInboundHandlerAdapter，这是netty中的一个事件处理器，netty中的处理器分为Inbound(进站)和Outbound(出站)处理器，后面会详细介绍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// channelReadComplete方法表示消息读完了的处理，writeAndFlush方法表示写入并发送消息 </span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 这里的逻辑就是所有的消息读取完毕了，在统一写回到客户端。Unpooled.EMPTY_BUFFER表 示空消息，addListener(ChannelFutureListener.CLOSE)表示写完后，就关闭连接</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exceptionCaught方法就是发生异常的处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channelRead方法表示读到消息以后如何处理，这里我们把消息打印出来</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">in</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        <span class="type">byte</span>[] req = <span class="keyword">new</span> <span class="title class_">byte</span>[in.readableBytes()];</span><br><span class="line">        in.readBytes(req); <span class="comment">//把数据读到byte数组中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(req, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器端收到消息:&quot;</span> + body); <span class="comment">//写回数据</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">resp</span> <span class="operator">=</span> Unpooled.copiedBuffer((<span class="string">&quot;receive message:&quot;</span> + body + <span class="string">&quot;&quot;</span>).getBytes());</span><br><span class="line">        ctx.write(resp);</span><br><span class="line">        <span class="comment">//ctx.write表示把消息再发送回客户端，但是仅仅是写到缓冲区，没有发送，flush才会真正写到网络上去</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码可以发现，相比之前，使用netty只需要通过极少的代码就完成了NIO服务端的开发，相比传统的NIO原生类库的服务端，代码量大大减少，开发难度也大幅度降低</p><h4 id="3-6-Netty和NIO的api对应"><a href="#3-6-Netty和NIO的api对应" class="headerlink" title="3.6 Netty和NIO的api对应"></a>3.6 Netty和NIO的api对应</h4><p>TransportChannel ——对应NIO中的channel<br>EventLoop——对应于NIO中的while循环<br>EventLoopGroup: 多个EventLoop，就是事件循环<br>ChannelHandler和ChannelPipeline——对应于NIO中的客户逻辑实现 handleRead&#x2F;handleWrite(interceptor pattern)<br>ByteBuf——对应于NIO 中的ByteBuffer<br>Bootstrap 和 ServerBootstrap——对应NIO中的Selector、ServerSocketChannel等的创建、配置、启动等</p><h3 id="4-Netty的整体工作机制"><a href="#4-Netty的整体工作机制" class="headerlink" title="4.Netty的整体工作机制"></a>4.Netty的整体工作机制</h3><p>Netty的整体工作机制如下，整体设计就是前面讲过的多线程Reactor模型，分离请求监听和请求处理，通过多线程分别执行具体的handler</p><img src="https://static-2w2.pages.dev/post/netty-all.png" alt="image-20230416102454524" style="zoom:50%;" /><h4 id="4-1-网络通信层"><a href="#4-1-网络通信层" class="headerlink" title="4.1 网络通信层"></a>4.1 网络通信层</h4><p>网络通信层主要的职责是执行网络的IO操作，它支持多种网络通信协议和I&#x2F;O模型的链接操作。当网络数据读取到内核缓冲区后，会触发读写事件，这些事件在分发给时间调度器来进行处理</p><p>在Netty中，网络通信的核心组件以下三个组件</p><ul><li>Bootstrap， 客户端启动api，用来链接远程netty server，只绑定一个EventLoopGroup </li><li>ServerBootStrap，服务端监听api，用来监听指定端口，会绑定两个EventLoopGroup， bootstrap组件可以非常方便快捷的启动Netty应用程序 </li><li>Channel，Channel是网络通信的载体，Netty自己实现的Channel是以JDK NIO channel为基础， 提供了更高层次的抽象，同时也屏蔽了底层Socket的复杂性，为Channel提供了更加强大的功能</li></ul><p>如下图所示，表示的是Channel的常用实现实现类关系图，AbstractChannel是整个Channel实现的基 类，派生出了AbstractNioChannel(非阻塞io)、AbstractOioChannel(阻塞io)，每个子类代表了不同 的I&#x2F;O模型和协议类型</p><img src="https://static-2w2.pages.dev/post/netty-img.png" alt="image-20230416102843795" style="zoom:50%;" /><p>随着连接和数据的变化，Channel也会存在多种状态，比如连接建立、连接注册、连接读写、连接销毁</p><p>随着状态的变化，Channel也会处于不同的生命周期，每种状态会绑定一个相应的事件回调。以下是常见的时间回调方法</p><ul><li>channelRegistered， channel创建后被注册到EventLoop上</li><li>channelUnregistered，channel创建后未注册或者从EventLoop取消注册 </li><li>channelActive，channel处于就绪状态，可以被读写 </li><li>channelInactive，Channel处于非就绪状态 </li><li>channelRead，Channel可以从源端读取数据 </li><li>channelReadComplete，Channel读取数据完成</li></ul><p>简单总结一下，Bootstrap和ServerBootStrap分别负责客户端和服务端的启动，Channel是网络通信的载体，它提供了与底层Socket交互的能力</p><p>而当Channel生命周期中的事件变化，就需要触发进一步处理，这个处理是由Netty的事件调度器来完成</p><h4 id="4-2-事件调度器"><a href="#4-2-事件调度器" class="headerlink" title="4.2 事件调度器"></a>4.2 事件调度器</h4><p>事件调度器是通过Reactor线程模型对各类事件进行聚合处理，通过Selector主循环线程集成多种事件 (I&#x2F;O时间、信号时间)，当这些事件被触发后，具体针对该事件的处理需要给到服务编排层中相关的 Handler来处理</p><p>事件调度器核心组件: </p><ul><li>EventLoopGroup：相当于线程池</li><li>EventLoop：相当于线程池中的线程</li></ul><p>EventLoopGroup本质上是一个线程池，主要负责接收I&#x2F;O请求，并分配线程执行处理请求</p><p>为了更好的理解EventLoopGroup、EventLoop、Channel之间的关系，可以参照下图所示的流程</p><img src="https://static-2w2.pages.dev/post/netty-things.png" alt="image-20230416103336440" style="zoom:50%;" /><p>从图中可知</p><ul><li>一个EventLoopGroup可以包含多个EventLoop，EventLoop用来处理Channel生命周期内所有的 I&#x2F;O事件，比如accept、connect、read、write等 </li><li>EventLoop同一时间会与一个线程绑定，每个EventLoop负责处理多个Channel </li><li>每新建一个Channel，EventLoopGroup会选择一个EventLoop进行绑定，该Channel在生命周期 内可以对EventLoop进行多次绑定和解绑</li></ul><p>而下图表示的是EventLoopGroup的类关系图，可以看出Netty提供了EventLoopGroup的多种实现，如 NioEventLoop、EpollEventLoop、NioEventLoopGroup等</p><p>从图中可以看到，EventLoop是EventLoopGroup的子接口，我们可以把EventLoop等价于 EventLoopGroup，前提是EventLoopGroup中只包含一个EventLoop</p><img src="https://static-2w2.pages.dev/post/netty-eventgroup.png" alt="image-20230416103705095" style="zoom:50%;" /><p>EventLoopGroup是Netty的核心处理引擎，它和前面讲解的Reactor线程模型有什么关系呢?</p><p>其实，可以简单的把EventLoopGroup当成是Netty中Reactor线程模型的具体实现，通过配置不同的EventLoopGroup可以使得Netty支持多种不同的Reactor模型</p><ul><li>单线程模型，EventLoopGroup只包含一个EventLoop，Boss和Worker使用同一个 EventLoopGroup</li><li>多线程模型:EventLoopGroup包含多个EventLoop，Boss和Worker使用同一个 EventLoopGroup</li><li>主从多线程模型:EventLoopGroup包含多个EventLoop，Boss是主Reactor，Worker是从 Reactor模型。他们分别使用不同的EventLoopGroup，主Reactor负责新的网络连接Channel的创 建(也就是连接的事件)，主Reactor收到客户端的连接后，交给从Reactor来处理</li></ul><h4 id="4-3-服务编排层"><a href="#4-3-服务编排层" class="headerlink" title="4.3 服务编排层"></a>4.3 服务编排层</h4><p>服务编排层的职责是负责组装各类的服务，简单来说，就是I&#x2F;O事件触发后，需要有一个Handler来处理，所以服务编排层可以通过一个Handler处理链来实现网络事件的动态编排和有序的传播</p><p>它包含三个组件</p><p><strong>1）ChannelPipeline</strong></p><p>它采用了双向链表将多个Channelhandler链接在一起，当I&#x2F;O事件触发时， ChannelPipeline会依次调用组装好的多个ChannelHandler，实现对Channel的数据处理</p><p>ChannelPipeline是线程安全的，因为每个新的Channel都会绑定一个新的ChannelPipeline</p><p>一个 ChannelPipeline关联一个EventLoop，而一个EventLoop只会绑定一个线程，如下图所示，表示 ChannelPIpeline结构图</p><img src="https://static-2w2.pages.dev/post/netty-channelpipeline.png" alt="image-20230416104129939" style="zoom: 33%;" /><p>从图中可以看出，ChannelPipeline中包含入站ChannelInBoundHandler和出站 ChannelOutboundHandler，前者是接收数据，后者是写出数据，其实就是InputStream和 OutputStream，为了更好的理解，可以再看下图</p><img src="https://static-2w2.pages.dev/post/netty-in-out.png" alt="image-20230416104244291" style="zoom: 50%;" /><p><strong>2）ChannelHandler</strong></p><p>针对IO数据的处理器，数据接收后，通过指定的Handler进行处理</p><p><strong>3）ChannelHandlerContext</strong></p><p>ChannelHandlerContext用来保存ChannelHandler的上下文信息，也就是说，当事件被触发后，多个handler之间的数据，是通过ChannelHandlerContext来进行传递的</p><p>ChannelHandler和ChannelHandlerContext之间的关系，如下图所示</p><img src="https://static-2w2.pages.dev/post/netty-channelcontext.png" alt="image-20230416104456189" style="zoom:50%;" /><p>每个ChannelHandler都对应一个自己的ChannelHandlerContext，它保留了ChannelHandler所需要的上下文信息，多个ChannelHandler之间的数据传递，是通过ChannelHandlerContext来实现的</p><p>以上就是Netty中核心的组件的特性和工作机制的介绍，可以看出，Netty的架构分层设计是非常合理的，它屏蔽了底层NIO以及框架层的实现细节，对于业务开发者来说，只需要关心业务逻辑的编排和实现即可</p><h3 id="5-组件关系及原理总结"><a href="#5-组件关系及原理总结" class="headerlink" title="5.组件关系及原理总结"></a>5.组件关系及原理总结</h3><img src="https://static-2w2.pages.dev/post/netty-work-orgin.png" alt="image-20230416105015402" style="zoom:50%;" /><p>如上图所示，表示Netty中关键的组件协调原理，具体的工作机制描述如下</p><ul><li>服务单启动初始化Boss和Worker线程组，Boss线程组负责监听网络连接事件，当有新的连接建立时，Boss线程会把该连接Channel注册绑定到Worker线程 </li><li>Worker线程组会分配一个EventLoop负责处理该Channel的读写事件，每个EventLoop相当于一个线程，通过Selector进行事件循环监听</li><li>当客户端发起I&#x2F;O事件时，服务端的EventLoop将就绪的Channel分发给Pipeline，进行数据的处理 </li><li>数据传输到ChannelPipeline后，从第一个ChannelInBoundHandler进行处理，按照pipeline链逐 个进行传递 </li><li>服务端处理完成后要把数据写回到客户端，这个写回的数据会在ChannelOutboundHandler组成的链中传播，最后到达客户端</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件之Kafka</title>
      <link href="/2023/04/04/MQ%E4%B9%8BKafka/"/>
      <url>/2023/04/04/MQ%E4%B9%8BKafka/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><h3 id="1-起源"><a href="#1-起源" class="headerlink" title="1.起源"></a>1.起源</h3><p>Kafka是如何诞生的呢？</p><p>Kafka 是由 LinkedIn 公司开发的一种分布式、可扩展、高吞吐量的消息系统。它的设计灵感来自于 LinkedIn 在处理大规模实时数据处理和数据流的挑战中的经验和教训</p><p>在过去，LinkedIn 使用了一些传统的消息系统来处理数据流和实时数据处理，但是这些系统的性能和可扩展性无法满足 LinkedIn 处理大规模实时数据流的需求。为了解决这个问题，LinkedIn 在 2008 年开始设计和开发 Kafka</p><p>Kafka 的设计目标是支持高吞吐量、低延迟的数据流处理，同时能够处理海量的数据。Kafka 借鉴了消息队列的概念，但与传统的消息系统不同的是，Kafka 的设计重点放在了可扩展性和高吞吐量上。它使用了一些优秀的设计和算法来实现高效的消息传输和存储，比如消息分区和批量传输等</p><p>在 Kafka 的发展历程中，LinkedIn 逐步将它开源，并加入了更多的特性和功能，使得 Kafka 成为了一种非常受欢迎的分布式消息系统。现在 Kafka 已经成为了 Apache 基金会的顶级项目，被广泛应用于实时数据处理、流处理、日志处理等场景</p><h3 id="2-应用"><a href="#2-应用" class="headerlink" title="2.应用"></a>2.应用</h3><p>Kafka发展到如今，已经应用于诸多系统与领域中，那么大体上分类，它有哪些应用场景呢？</p><p>主要可以分为3类</p><ul><li>数据集成</li><li>大数据领域</li><li>流计算生成</li></ul><p>但是最基本的，是它可以作为消息队列使用</p><h4 id="2-1-消息传递-Messaging"><a href="#2-1-消息传递-Messaging" class="headerlink" title="2.1 消息传递 Messaging"></a>2.1 消息传递 Messaging</h4><p>消息传递就是发送数据，作为 TCP HTTP 或者 RPC 的替代方案，可以实现异步、 解耦、削峰</p><blockquote><p>RabbitMQ 和 RocketMQ 能做的事情，它也能做</p></blockquote><p>因为 Kafka 的吞吐量更高，在大规模消息系统中更有优势</p><p>第二个是大数据领域的使用，比如网站行为分析</p><h4 id="2-2-网站行为分析"><a href="#2-2-网站行为分析" class="headerlink" title="2.2 网站行为分析"></a>2.2 网站行为分析</h4><h5 id="2-2-1-Website-Activity-Tracking-网站活动跟踪"><a href="#2-2-1-Website-Activity-Tracking-网站活动跟踪" class="headerlink" title="2.2.1 Website Activity Tracking 网站活动跟踪"></a>2.2.1 Website Activity Tracking 网站活动跟踪</h5><p>把用户活动发布到数据管道中，可以用来做监控、实时处理、报表等等，比如社交网站的行为跟踪，购物网站的行为跟踪，这样可以实现更加精准的内容推荐</p><p>例:外卖、物流、电力系统的实时信息</p><h5 id="2-2-2-Log-Aggregation-日志聚合"><a href="#2-2-2-Log-Aggregation-日志聚合" class="headerlink" title="2.2.2 Log Aggregation 日志聚合"></a>2.2.2 Log Aggregation 日志聚合</h5><p>又比如用 Kafka 来实现日志聚合。这样就不用把日志记录到本地磁盘或者数据库，实现分布式的日志聚合</p><h5 id="2-2-3-Metrics-应用指标监控"><a href="#2-2-3-Metrics-应用指标监控" class="headerlink" title="2.2.3 Metrics 应用指标监控"></a>2.2.3 Metrics 应用指标监控</h5><p>还可以用来记录运营监控数据</p><p>例，对于贷款公司，需要监控贷款的业务数据：今天放出去多少笔贷款，放出去的总金额，用户的年龄分布、地区分布、性别分布等等</p><p>或者对于运维数据的监控，CPU、内存、磁盘、网络连接的使用情况，可以实现告警</p><h4 id="2-3-数据集成-流计算"><a href="#2-3-数据集成-流计算" class="headerlink" title="2.3 数据集成+流计算"></a>2.3 数据集成+流计算</h4><p>首先是数据集成，指的是把 Kafka 的数据导入 Hadoop、HBase 等离线数据仓库，实现数据分析</p><p>其次是<strong>流计算</strong>，什么是流（Stream）?</p><p>它不是静态的数据，而是没有边界的、 源源不断的产生的数据，就像水流一样。流计算指的就是 Stream 对做实时的计算。 Kafka 在 0.10 版本后，内置了流处理框架 API——Kafka Streams<br>所以，它跟 RabbitMQ 的定位差别还是比较大的，不仅仅是一个简单的消息中间件，而且是一个流处理平台</p><p>在 Kafka 里面，消息被称为日志，日志就是消息的数据文件</p><h3 id="3-Kafka和ZK的关系"><a href="#3-Kafka和ZK的关系" class="headerlink" title="3.Kafka和ZK的关系"></a>3.Kafka和ZK的关系</h3><p>在安装 Kafka 的时候，必须要依赖 ZK 的服务，在生产环境通常是 ZK 的集群，而且 Kafka 还自带了一个 ZK 服务，那么ZK 做了什么事情呢?</p><p>总结概括就是，利用 ZK 的有序节点、临时节点和监听机制，ZK 帮 Kafka 做了以下这些事情</p><p>配置中心(管理 Broker、Topic、Partition、Consumer 的信息，包括元数据的 变动)、负载均衡、命名服务、分布式通知、集群管理和选举、分布式锁</p><p>关于ZK，可以参考之前的文章<a href="https://yzj.life/2023/03/31/Zookeeper/">Zookeeper</a></p><h2 id="二、基础架构"><a href="#二、基础架构" class="headerlink" title="二、基础架构"></a>二、基础架构</h2><p>首先来一张架构图，看懂这张图就看懂了Kafka的架构</p><img src="https://static-2w2.pages.dev/post/mq-kafka01.png" alt="在这里插入图片描述" style="zoom:38%;" /><h3 id="1-Broker"><a href="#1-Broker" class="headerlink" title="1.Broker"></a>1.Broker</h3><img src="https://static-2w2.pages.dev/post/mq-kafka-broker.png" alt="image-20230413125501013" style="zoom:50%;" /><p>Broker:Kafka 作为一个中间件，是帮我们存储和转发消息的，它做的事情就像 中介，所以 Kafka 的服务也叫做 Broker，默认是 9092 的端口。生产者和消费者都需 要跟这个 Broker 建立一个连接，才可以实现消息的收发</p><h3 id="2-消息"><a href="#2-消息" class="headerlink" title="2.消息"></a>2.消息</h3><p>客户端之间传输的数据叫做消息，或者叫做记录(Record 名词 [ˈrekɔːd ])</p><p>在客户端的代码中，Record 可以是一个 KV 键值对。 生产者对应的封装类是 ProducerRecord，消费者对应的封装类是 ConsumerRecord</p><p>消息在传输的过程中需要序列化，所以代码里面要指定序列化工具</p><blockquote><p>RabbitMQ是将消息序列化成二机制</p></blockquote><p>消息在服务端的存储格式<a href="http://kafka.apache.org/documentation/#messageformat">(RecordBatch 和 Record)</a></p><h3 id="3-生产者"><a href="#3-生产者" class="headerlink" title="3.生产者"></a>3.生产者</h3><p>发送消息的一方叫做生产者，接收消息的一方叫做消费者</p><p>为了提升消息发送速率，生产者不是逐条发送消息给 Broker，而是批量发送的</p><p>多少条发送一次由一个参数决定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pros.put(<span class="string">&quot;batch.size&quot;</span>,<span class="number">16384</span>);</span><br></pre></td></tr></table></figure><h3 id="4-消费者"><a href="#4-消费者" class="headerlink" title="4.消费者"></a>4.消费者</h3><p>一般来说消费者获取消息有两种模式，一种是 Pull 模式，一种是 Push 模式。</p><p>Pull 模式就是消费放在 Broker，消费者自己决定什么时候去获取。Push 模式是 消息放在 Consumer，只要有消息到达 Broker，都直接推给消费者。</p><p>RabbitMQ Consumer 及支持 Push 又支持 Pull，一般用的是 Push</p><p><strong>Kafka 只有 Pull 模式</strong></p><p>在 Push 模式下，如果消息产生速度远远大于消费者消费消息的速率，那消费者就会不堪重负(你已经吃不下了，但是还要不断地往你嘴里塞)，直到挂掉</p><p> 而且消费者可以自己控制一次到底获取多少条消息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认 500 在 poll 方法里面可以指定</span></span><br><span class="line"><span class="attr">max.poll.records</span></span><br></pre></td></tr></table></figure><h3 id="5-Topic"><a href="#5-Topic" class="headerlink" title="5.Topic"></a>5.Topic</h3><p>生产者跟消费者是怎么关联起来的呢？或者说，生产者发送的消息，怎么才能到达某个特定的消费者？</p><p>他们要通过队列关联起来，也就是说</p><p><strong>生产者发送消息，要指定发给哪个队列</strong></p><p><strong>消费者接收消息，要指定从哪个队列接收</strong></p><p> 在 Kafka 里面，这个队列叫做 Topic，是一个逻辑的概念，可以理解为一组消息的集合（不同业务用途的消息）</p><p>生产者和 Topic 以及 Topic 和消费者的关系都是多对多，一个生产者可以发送消息到多个 Topic，一个消费者也可以从多个 Topic 获取消息(但是不建议这么做）</p><img src="https://static-2w2.pages.dev/post/mq-kafka-topic.png" alt="image-20230413130155422" style="zoom:35%;" /><p>注意，生产者发送消息时，如果 Topic 不存在，会自动创建</p><p>由一个参数<code>auto.create.topics.enable</code>控制</p><p>默认为true，但是如果要彻底删掉一个 Topic，这个参数必须改成 false，否则只要有代码使用这个 Topic，它就会自动创建</p><h3 id="6-Partition-与-Cluster"><a href="#6-Partition-与-Cluster" class="headerlink" title="6.Partition 与 Cluster"></a>6.Partition 与 Cluster</h3><p>如果说一个 Topic 中的消息太多，会带来两个问题：</p><p>第一个是不方便横向扩展，比如我想要在集群中把数据分布在不同的机器上实现扩展，而不是通过升级硬件做到，如果一个 Topic 的消息无法在物理上拆分到多台机器的时候，这个是做不到的。 </p><p>第二个是并发或者负载的问题，所有的客户端操作的都是同一个 Topic，在高并发 的场景下性能会大大下降。</p><p>那么，怎么解决这个问题呢？我们想到的就是把一个 Topic 进行拆分—经典分片思想</p><p>Kafka 引入了一个分区(Partition)的概念，一个Topic可以划分成多个分区</p><p>分区在创建 Topic 的时候指定，每个 Topic 至少有一个分区</p><blockquote><p>Partition 思想上有点类似于分库分表，实现的也是<strong>横向扩展</strong>和<strong>负载</strong>的目的</p></blockquote><p>举个例子，Topic 有 3 个分区，生产者依次发送 9 条消息，对消息进行编号</p><p>第一个分区存 1 4 7，第二个分区存 2 5 8 ，第三个分区存 3 6 9，这个就实现了负载</p><p>每个 partition 都有一个物理目录</p><p>在配置的数据目录下(日志就是数据):：&#x2F;tmp&#x2F;kafka-logs&#x2F;</p><p>跟 RabbitMQ 不一样的地方是，Partition 里面的消息被<strong>读取</strong>之后<strong>不会被删除</strong>，所以同一批消息在一个 Partition 里面顺序、追加写入的，这个也是 Kafka 吞吐量大的一 个很重要的原因</p><h3 id="7-Partition-副本-Replica-机制"><a href="#7-Partition-副本-Replica-机制" class="headerlink" title="7.Partition 副本 Replica 机制"></a>7.Partition 副本 Replica 机制</h3><p>如果 Partition 的数据只存储一份，在发生网络或者硬件故障的时候，该分区的数据就无法访问或者无法恢复了</p><p>因此，Kafka 在 0.8 的版本之后增加了副本机制</p><p>每个 Partition 可以有若干个副本(Replica)，副本必须在<strong>不同的 Broker</strong> 上面。，一般我们说的副本包括其中的主节点</p><p>举例：部署了 3 个 Broker，该 Topic 有 3 个分区，每个分区一共 3 个副本</p><img src="https://static-2w2.pages.dev/post/mq-kafka-replica.png" alt="image-20230413131142867" style="zoom:25%;" /><p>红色就是Leader，是生产者发送消息和消费者读取消息的对象</p><p>Follower的数据都是从leader同步的</p><blockquote><p>需要注意的是，只有Leader具有写入和消费能力，Follower不具有单独写入和消费能力</p></blockquote><h3 id="8-Segment"><a href="#8-Segment" class="headerlink" title="8.Segment"></a>8.Segment</h3><p>Kafka 的数据是放在后缀.log 的文件里面的，如果一个 Partition 只有一个 log 文件，消息不断地追加，这个 log 文件也会变得越来越大，这个时候要检索数据效率就很低了</p><p> 所以干脆把 Partition 再做一个切分，切分出来的单位就叫做段(Segment)</p><p>实际上Kafka 的存储文件是划分成段来存储的， 默认存储路径:&#x2F;tmp&#x2F;kafka-logs&#x2F;</p><p>每个 Segment 都有至少有 1 个数据文件和 2 个索引文件，这 3 个文件是成套出现的</p><p>默认一个Segment大小是1G</p><h3 id="9-Consumer-Group-消费者组"><a href="#9-Consumer-Group-消费者组" class="headerlink" title="9.Consumer Group 消费者组"></a>9.Consumer Group 消费者组</h3><p>如果生产者生产消息的速率过快，会造成消息在 Broker 的堆积，影响 Broker 的性能</p><p>怎么提升消息的消费速率呢？增加消费者的数量</p><p>但是这么多消费者，怎么知道大家是不是消费的同一个 Topic 呢？</p><p>所以引入了一个 Consumer Group 消费组的概念，在代码中通过 group id 来 配置</p><p>消费同一个 Topic 的消费者不一定是同一个组，只有 group id 相同的消费者才是同一个消费者组</p><img src="https://static-2w2.pages.dev/post/mq-kafka-consumerGroup.png" alt="image-20230413131624977" style="zoom:35%;" /><p>注意:同一个 Group 中的消费者，不能消费相同的Partition——Partition 要在消费者之间分配</p><p>此时就会出现一个问题，即消费者比Partition多怎么办？比它少又怎么办？</p><ul><li>消费者比 Partition 少，一个消费者可能消费多个 Partition</li><li>消费者比 Partition 多，肯定有消费者没有 Partition 可以消费，不会出现一个 Group 里面的消费者消费同一个 Partition 的情况</li></ul><p>因此，如果想要同时消费同一个 Partition 的消息，那么需要其他的组来消费</p><h3 id="10-Consumer-Offset"><a href="#10-Consumer-Offset" class="headerlink" title="10.Consumer Offset"></a>10.Consumer Offset</h3><p>上面提到了，Partition里面的消息都是顺序写入，且读取之后不会被删除，那么消费者如何确定自己每次消费时的位置呢？</p><p>在Kafka当中，由于消息是有序存储，因此可以对消息进行<strong>编号</strong>，用来标识一条唯一的消息</p><img src="https://static-2w2.pages.dev/post/mq-kafka-sortNum.png" alt="image-20230413132604003" style="zoom:40%;" /><p>而这个编号，就可以确定每个Partition当中消息的位置，称为偏移量（Offset）</p><p>Offset 记录着下一条将要发送给 Consumer 的消息的序号</p><p>这个消费者跟 Partition 之间的偏移量没有保存在 ZK，而是直接保存在服务端</p><blockquote><p>后面会详细介绍offset更新策略，此处点到为止</p></blockquote><p>此处，再回顾一下架构图就很清晰了</p><img src="https://static-2w2.pages.dev/post/mq-kafka01.png" alt="在这里插入图片描述" style="zoom:38%;" /><p>首先，这里有 3 台 Broker<br>有两个 Topic：Topic0 和 Topic1<br>Topic0 有 2 个分区：Partition0 和 Partition1，每个分区一共 3 个副本</p><p>Topic1 只有 1 个分区：Partition0，每个分区一共 3 个副本</p><p>图中红色字体的副本代表是 Leader，黑色字体的副本代表是 Follower</p><p>绿色的线代表是数据同步</p><p>蓝色的线是写消息，橙色的线是读消息，都是针对 Leader 节点</p><p>有两个消费者组，第一个消费者组，消费了 Topic0 的两个分区</p><p>第二个消费者组</p><ul><li>Consumer0：既消费消费 Topic0的 Partition0，还消费 Topic1 的 Partition0</li><li>Consumer1：消费 Partition0 的 Partition1</li><li>Consumer2：没有 Partition 可以消费</li></ul><p>为什么Consumer2没有Partition可以消费呢？</p><p>因为总共就三个Partition，已经被前两个相同group id的消费者消费掉了，它就只能闲着了</p><h2 id="三、对比"><a href="#三、对比" class="headerlink" title="三、对比"></a>三、对比</h2><h3 id="1-Kafka特性"><a href="#1-Kafka特性" class="headerlink" title="1.Kafka特性"></a>1.Kafka特性</h3><p>因为 kafka 是用来解决数据流的传输的问题的，所以它有这些特性: </p><ul><li><strong>高吞吐、低延迟：</strong>Kakfa 最大的特点就是收发消息非常快，Kafka 每秒可以处 理几十万条消息，它的最低延迟只有几毫秒</li><li><strong>高伸缩性：</strong>如果可以通过增加分区 Partition 来实现扩容。不同的分区可以在不同的 Broker 中。通过 ZK 来管理 Broker 实现扩展，ZK 管理 Consumer 可以实现负载</li><li><strong>持久性、可靠性：</strong>Kafka 能够允许数据的持久化存储，消息被持久化到磁盘， 并支持数据备份防止数据丢失</li><li><strong>容错性：</strong>允许集群中的节点失败，某个节点宕机，Kafka 集群能够正常工作</li><li><strong>高并发：</strong>支持数千个客户端同时读写</li></ul><h3 id="2-Kafka与RabbitMQ对比"><a href="#2-Kafka与RabbitMQ对比" class="headerlink" title="2.Kafka与RabbitMQ对比"></a>2.Kafka与RabbitMQ对比</h3><p>Kafka 和 RabbitMQ 的主要区别</p><ul><li>产品侧重：Kafka:流式消息处理、消息引擎;RabbitMQ:消息代理</li><li>性能：Kafka 有更高的吞吐量。RabbitMQ 主要是 Push，Kafka 只有 Pull</li><li>消息顺序：分区里面的消息是有序的，同一个 Consumer Group 里面的一个消费者只能消费一个 Partition，能保证消息的顺序性</li><li>消息的路由和分发：RabbitMQ 更加灵活</li><li>延迟消息、死信队列：RabbitMQ 支持</li><li>消息的留存：Kafka 消费完之后消息会留存，RabbitMQ 消费完就会删除。 Kafka可以设置 retention，清理消息</li></ul><p>优先选择 RabbitMQ 的情况:</p><p>高级灵活的路由规则;</p><ul><li>消息时序控制(控制消息过期或者消息延迟);</li><li>高级的容错处理能力，在消费者更有可能处理消息不成功的情景中(瞬时或者持久)</li><li>更简单的消费者实现</li></ul><p>优先选择 Kafka 的情况</p><ul><li>严格的消息顺序</li><li>延长消息留存时间，包括过去消息重放的可能</li><li>传统解决方案无法满足的高伸缩能力</li></ul><h2 id="四、生产者详解"><a href="#四、生产者详解" class="headerlink" title="四、生产者详解"></a>四、生产者详解</h2><h3 id="1-幂等性"><a href="#1-幂等性" class="headerlink" title="1.幂等性"></a>1.幂等性</h3><p>在RabbitMQ当中，消息的幂等性是依赖全局唯一ID来实现的，需要在消费端实现</p><p>在Kafka当中，把这个任务交给了Broker，不再交给消费者解决</p><p>但是无论交给谁解决，肯定都会有一个全局唯一ID来标识消息，在Kafka中，这个ID可以通过以下配置产生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(<span class="string">&quot;enable.idempotence&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><code>enable.idempotence</code> 设置成 true 后，Producer 自动升级成幂等性 Producer，Kafka 会自动去重，如何实现的？</p><p>主要依赖两个重要机制：</p><ul><li><p>PID(Producer ID)：幂等性的生产者每个客户端都有一个唯一的编号</p></li><li><p>sequence number：幂等性的生产者发送的每条消息都会带相应的 sequence</p><p>number</p></li></ul><blockquote><p>Server端就是根据这个sequence number值来判断数据是否重复。如果说发现 sequence number 比服务端已经记录的值要小，那肯定是出现消息重复了</p></blockquote><p>但是，这个 sequence number 并不是全局有序的，它不能保证所有时间上的幂等</p><p>所以，它的作用范围是有限的</p><ul><li>只能保证单分区上的幂等性，即一个幂等性 Producer 能够保证<strong>某个主题的一 个分区</strong>上不出现重复消息</li><li>只能实现单会话上的幂等性，这里的会话指的是 Producer 进程的一次运行，当重启了 Producer 进程之后，幂等性不保证</li></ul><blockquote><p>这个也很容易理解，也就说不允许生产者在一次会话中向同一个 patition 发送相同的消息</p></blockquote><h3 id="2-生产者事务"><a href="#2-生产者事务" class="headerlink" title="2.生产者事务"></a>2.生产者事务</h3><p>生产者事务是 Kafka 2017 年 0.11.0.0 引入的新特性，通过事务，Kafka 可以保证跨生产者会话的消息<strong>幂等</strong>发送</p><p>为什么需要引入事务的特性呢？什么时候才需要开启事务？</p><p>有几种情况:</p><ul><li>假设只有 1 个 Broker，1 个 Topic 的分区只有 1 个副本，如果要发送多条消息，想要让这些消息全部成功或者全部失败，怎么办? </li><li>更加复杂的情况，如果生产者发送消息到多个 Topic 或者多个 Partition， 它们有可能分布在不同的服务器上，需要它们全部发送成功或者全部发送失败，应该怎么办?</li><li>还有一种情况，就是消费者和生产者在同一块代码中（consume-process-produce），从上游接收消息，经过处理后发给下游，这个时候 要保证接收消息和发送消息同时成功</li></ul><p>在SpringBoot当中，可以使用事务注解@Transaction开启（声明式事务）</p><p>那么它的分布式事务如何实现呢？下面是实现核心思想</p><ul><li>因为生产者的消息可能会跨分区，所以这里的事务是属于<strong>分布式事务</strong>。分布式事务的实现方式有很多，Kafka 选择了最常见的两阶段提交(2PC)：<strong>如果大家都可以 commit，那么就 commit，否则 abort</strong></li><li>既然是 2PC，必须要有一个协调者的角色，叫做 <strong>Transaction Coordinator</strong></li><li>事务管理必须要有事务日志，来记录事务的状态，以便 Coordinator 在意外挂掉之后继续处理原来的事务。跟消费者 Offset 的存储一样，Kafka 使用一个特殊的topic__transaction_state 来记录事务状态</li><li>如果生产者挂了，事务要在重启后可以继续处理，接着之前未处理完的事务， 或者在其他机器上处理，必须要有一个唯一的 ID，这个就是 <strong>transaction.id</strong>，这里可以使用 UUID。配置了 transaction.id，则此时 enable.idempotence 会被设置为 true (事务实现的前提是幂等性)。事务 ID 相同的生产者，可以接着处理原来的事务</li></ul><p>看下图事务代码实现流程</p><img src="https://static-2w2.pages.dev/post/mq-kafka-transaction.png" alt="image-20230413141041133" style="zoom:25%;" /><p>步骤描述:</p><ul><li>A:生产者通过 initTransactions API 向 Coordinator 注册事务 ID</li><li>B:Coordinator 记录事务日志</li><li>C:生产者把消息写入目标分区</li><li>D:分区和 Coordinator 的交互，当事务完成以后，消息的状态应该是已提交，这样消费者才可以消费到</li></ul><h3 id="3-生产者原理"><a href="#3-生产者原理" class="headerlink" title="3.生产者原理"></a>3.生产者原理</h3><h4 id="3-1-生产者消费发送流程"><a href="#3-1-生产者消费发送流程" class="headerlink" title="3.1 生产者消费发送流程"></a>3.1 生产者消费发送流程</h4><p>消息发送的整体流程，生产端主要由两个线程协调运行</p><p>这两条线程分别为 main 线程和 Sender 线程(发送线程)</p><img src="https://static-2w2.pages.dev/post/mq-kafka-producer.png" alt="image-20230413140934823" style="zoom:30%;" /><p>KafkaProducer就是代码中实现的生产者，它创建了一个Sender对象，启动了一个IO线程用于发送</p><h4 id="3-2-拦截器"><a href="#3-2-拦截器" class="headerlink" title="3.2 拦截器"></a>3.2 拦截器</h4><p>拦截器是执行在KafkaProducer之后的代码，它又有什么作用呢？</p><p>拦截器的作用是实现消息的定制化</p><blockquote><p>类似于:Spring Interceptor 、MyBatis 的 插件、Quartz 的监听器</p></blockquote><p>可以在生产者的属性中指定多个拦截器，形成拦截器链</p><p>举个例子，假设发送消息的时候要扣钱，发一条消息 1 分钱(我把这个功能叫做 按量付费)，就可以用拦截器实现</p><h4 id="3-3-序列化"><a href="#3-3-序列化" class="headerlink" title="3.3 序列化"></a>3.3 序列化</h4><p>消息发送都是需要序列化的，因此在调用 send 方法以后，第二步是利用指定的工具对 key 和 value 进行序列化</p><p>Kafka自带许多常见数据类型的序列化工具，此外也可以使用如 Avro、JSON、Thrift、Protobuf 等， 或者使用自定义类型的序列化器来实现，实现 Serializer 接口即可</p><h4 id="3-4-路由指定"><a href="#3-4-路由指定" class="headerlink" title="3.4 路由指定"></a>3.4 路由指定</h4><p>即一个消息要发送到哪个partition呢？在代码中是这样实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> partition(record, serializedKey, serializedValue, cluster);</span><br></pre></td></tr></table></figure><p>它返回的是一个分区编号，从0开始</p><p>首先我们分一下，有四种情况: </p><ul><li>指定了 partition</li><li>没有指定 partition，自定义了分区器</li><li>没有指定 partition，没有自定义分区器，但是 key 不为空</li><li>没有指定 partition，没有自定义分区器，但是 key 是空的</li></ul><p>下面分别讨论这四种情况</p><p><strong>1）指定了 partition</strong></p><p>指定 partition 的情况下，直接将指定的值直接作为partiton值</p><p><strong>2）没有指定 partition，自定义了分区器</strong></p><p>自定义分区器，将使用自定义的分区器算法选择分区，比如 SimplePartitioner， 用 ProducerAutoPartition 指定，发送消息</p><p><strong>3）没有指定 partition，没有自定义分区器，但是 key 不为空</strong></p><blockquote><p>根据key，使用默认分区器</p></blockquote><p>没有指定 partition 值但有 key 的情况下，使用默认分区器 DefaultPartitioner，将 key 的 hash 值与 topic 的 partition 数进行取余得到 partition 值</p><p><strong>4）没有指定 partition，没有自定义分区器，但是 key 是空的</strong></p><blockquote><p>差不多就是随机了</p></blockquote><p>既没有 partition 值又没有 key 值的情况下，第一次调用时随机生成一个整数(后面每次调用在这个整数上自增)，将这个值与 topic 可用的 partition 总数取余得到 partition 值，也就是常说的 round-robin 算法</p><h4 id="3-5-消息累加器"><a href="#3-5-消息累加器" class="headerlink" title="3.5 消息累加器"></a>3.5 消息累加器</h4><p>事实上，在选择分区之后并没有直接发送消息，而是将消息放入了消息累加器</p><p>本质上是一个ConcurrentMap</p><p>一个partition一个batch，batch满了之后就会唤醒Sender线程发送消息，减少IO</p><h3 id="4-可靠性保证"><a href="#4-可靠性保证" class="headerlink" title="4.可靠性保证"></a>4.可靠性保证</h3><h4 id="4-1-服务器响应策略"><a href="#4-1-服务器响应策略" class="headerlink" title="4.1 服务器响应策略"></a>4.1 服务器响应策略</h4><p>在RabbitMQ当中，生产者发送完消息，需要依靠交换机回传的ack来确定消息投递成功，那么在kafka当中，是如何保证消息发送成功的呢？</p><p>首先要确定，服务端什么时候才算接收成功呢？</p><p>因为消息是存储在不同的Partition里面的，所以是<strong>写入到Partition之后响应生产者</strong></p><p>但是kafka的Partition是有副本存在的，所以是要写入一定量副本才可以响应</p><p>那么写入多少呢？这里主要有两种策略</p><p>第一种是需要<strong>有半数以上的 Follower 节点完成同步</strong>，这样的话客户端等待的时间就短一些，延迟低（为什么通常来说我们部署节点都是奇数？）</p><p>第二种需要<strong>所有的 Follower 全部完成同步</strong>，才发送 ACK 给客户端，延迟相对来说高一些，但是节点挂掉的影响相对来说小一些，因为所有的节点数据都是完整的</p><p>那么kafka选择的是哪一种呢？</p><p>kafka选择的是第二种，因为安全，而且网络延迟对kafka影响不大</p><h4 id="4-2-ISR"><a href="#4-2-ISR" class="headerlink" title="4.2 ISR"></a>4.2 ISR</h4><p>如果直接采用第二种思路，不考虑网络延迟，有没有别的问题呢？</p><p>假设 Leader 收到数据，所有 Follower 都开始同步数据，但是有一个 Follower 出了问题，没有办法从 Leader 同步数据。按照这个规则，Leader 就要一直等待，无法发送 ACK，可以说成为了害群之马</p><p>所以我们的规则就不能那么粗暴了，把规则改一下，不是所有的 follower 都有权利让我等待，而是只有那些正常工作的 follower 同步数据的时候我才会等待</p><p>我们应该把那些正常和 leader 保持同步的 replica 维护起来，放到一个动态 set 里面，这个就叫做 in-sync replica set(ISR)。现在只要 ISR 里面的 follower 同步完数据之后，我就给客户端发送 ACK</p><p>如果一个 Follower 长时间不同步数据，就要从 ISR 剔除，默认30s</p><p>而如果Leader长时间没有同步，那么就表示挂掉了，需要从ISR里重新选举Leader</p><h4 id="4-3-ACK应答机制"><a href="#4-3-ACK应答机制" class="headerlink" title="4.3 ACK应答机制"></a>4.3 ACK应答机制</h4><p>上面的方案很安全，但是有时候，我不想要很安全的数据传输，我就要快，那怎么实现呢？</p><p>Kafka 为客户端提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡，选择相应的配置，配置方式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pros.put(<span class="string">&quot;acks&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure><p>下面介绍三个参数含义，假设topic 的 partition0 有三个副本</p><p>acks&#x3D;0：producer 不等待 broker 的 ack，这一操作提供了一个最低的延迟，broker 一接收到还没有写入磁盘就已经返回，当 broker 故障时有可能丢失数据</p><p>acks&#x3D;1(默认)：producer 等待 broker 的 ack，partition 的<strong>leader落盘成功</strong>后返回 ack，如果在 follower 同步成功之前 leader 故障，那么将会丢失数据</p><p>acks&#x3D;-1(all)：producer 等待 broker 的 ack，partition 的 leader 和 follower <strong>全部落盘成功</strong>后才返回 ack</p><blockquote><p>acks&#x3D;-1(all) 这种方案是完美的吗?有没有可能出问题？</p><p>如果在 follower 同步完成后，broker 发送 ack 之前，leader 发生故障，没有给</p><p>生产者发送 ACK，那么会造成数据重复<br>在这种情况下， 把 reties 设置成 0(不重发)，才不会重复</p></blockquote><p>三种机制，性能依次递减 (producer 吞吐量降低)，数据健壮性则依次递增。我们可以根据业务场景使用不同的参数</p><h2 id="五、Broker详解"><a href="#五、Broker详解" class="headerlink" title="五、Broker详解"></a>五、Broker详解</h2><h3 id="1-存储原理"><a href="#1-存储原理" class="headerlink" title="1.存储原理"></a>1.存储原理</h3><h4 id="1-1-文件的存储结构"><a href="#1-1-文件的存储结构" class="headerlink" title="1.1 文件的存储结构"></a>1.1 文件的存储结构</h4><p>配置文件:config&#x2F;server.properties</p><p>logs.dir 配置</p><p>默认&#x2F;tmp&#x2F;kafka-logs</p><h4 id="1-2-Partition-分区"><a href="#1-2-Partition-分区" class="headerlink" title="1.2 Partition 分区"></a>1.2 Partition 分区</h4><p>为了实现横向扩展，把不同的数据存放在不同的 Broker 上，同时降低单台服务器的访问压力，我们把一个 Topic 中的数据分隔成多个 Partition<br> 一个 Partition 中的消息是有序的，顺序写入，但是全局不一定有序</p><blockquote><p>在服务器上，每个 Partition 都有一个物理目录，Topic 名字后面的数字标号即代表分区</p></blockquote><h4 id="1-3-Replica-副本"><a href="#1-3-Replica-副本" class="headerlink" title="1.3 Replica 副本"></a>1.3 Replica 副本</h4><p>为了提高分区的可靠性，Kafka 又设计了副本机制<br>创建 Topic 的时候，通过指定 replication-factor 确定 Topic 的副本数</p><blockquote><p>注意:副本数必须小于等于节点数，而不能大于 Broker 的数量，否则会报错</p><p>为什么可以等于节点数？因为Leader也称为副本</p></blockquote><p>这样就可以保证，绝对不会有一个分区的两个副本分布在同一个节点上，不然副本机制也失去了备份的意义了</p><p>这些所有的副本分为两种角色</p><ul><li>Leader：对外提供读写服务</li><li>Follower：唯一的任务就是从 Leader 异步拉取数据</li></ul><p>思考:为什么不能像 MySQL 一样实现读写分离，写操作都在 Leader 上，读操作<br>都在 Follower 上？</p><p>这个是设计思想的不同。读写都发生在 Leader 节点，就不存在读写分离带来的一<br>致性问题了，这个就叫做单调读一致性</p><h4 id="1-4-Leader"><a href="#1-4-Leader" class="headerlink" title="1.4 Leader"></a>1.4 Leader</h4><p>如果有多个副本，如何确定Leader呢？</p><p>在 Kafka 中，每个分区的初始 Leader 会在创建分区时进行选举。具体来说，当创建新的分区时，Kafka 会根据主题的分区副本分配策略，为该分区的每个副本节点分配一个角色，其中一个节点被选举为 Leader，其余节点则成为 Follower</p><p>在分配角色时，Kafka 会优先将 Leader 副本分配给与之前的 Leader 所在节点相同的节点，如果该节点不可用，则按照指定的分配策略从可用节点中选择一个节点作为 Leader</p><p>可知，Leader的选举与副本有很深的联系，因此这里先继续看副本</p><h4 id="1-5-副本在Broker的分布"><a href="#1-5-副本在Broker的分布" class="headerlink" title="1.5 副本在Broker的分布"></a>1.5 副本在Broker的分布</h4><p>副本在 Broker 的分布有什么规则吗？</p><p>事实上，副本的分布是由AdminUtils.scala 的 assignReplicasToBrokers 函数决定的</p><p>该函数规则如下：</p><ul><li>firt of all，副本因子不能大于 Broker 的个数</li><li><strong>第一个分区</strong>(编号为 0 的分区)的<strong>第一个副本</strong>放置位置是随机从 brokerList 选择的</li><li>其他分区的<strong>第一个副本</strong>放置位置相对于第 0 个分区依次往后移<ul><li>也就是说：如果我们有 5 个 Broker，5 个分区</li><li>假设第 1 个分区的第 1 个副本放在第四个 Broker 上</li><li>那么第 2 个分区的第 1 个副本将会放在第五个 Broker 上</li><li>第三个分区的第 1 个副本将会放在第一个 Broker 上</li><li>第四个分区的第 1 个副本将会放 在第二个 Broker 上，依次类推(蛇形走位)</li></ul></li><li>每个分区剩余的副本相对于第 1 个副本放置位置其实是由 nextReplicaShift决定的，而这个数也是随机产生的。</li></ul><p>用箭头解释如下图</p><img src="https://static-2w2.pages.dev/post/mq-kafka-replica-fir.png" alt="image-20230413153907038" style="zoom:30%;" /><blockquote><p>但是要注意的是，这里说的都是每个分区第一个副本的放置位置</p><p>而这里就对应了上一个小结里说过的，leader怎么选出来的？</p><p>初始化时，leader就是第一个分区副本</p><p>假如leader挂了，那就由zk进行选举</p></blockquote><p>这样设计可以提高容灾能力，怎么讲?</p><p>在每个分区的第一个副本错开之后，一般第一个分区的第一个副本(按 Broker 编 号排序)都是 Leader，Leader 是错开的，不至于一挂影响太大</p><p>bin 目录下的 kafka-reassign-partitions.sh 可以根据 Broker 数量变化情况重新分配分区</p><p>这里再提另一个问题，一个分区是不是只有一个 文件呢？也就是说，消息日志文件是不是会无限地变大？</p><h4 id="1-6-Segment"><a href="#1-6-Segment" class="headerlink" title="1.6 Segment"></a>1.6 Segment</h4><p>为了防止 Log 不断追加导致文件过大，导致检索消息效率变低，一个 Partition 又被划分成多个 Segment 来组织数据(MySQL 也有 Segment 的逻辑概念，叶子节点就是数据段，非叶子节点就是索引段)</p><p>在磁盘上，每个 Segment 由一个 log 文件和 2 个 index 文件组成，且这三个文件成套出现</p><ul><li>log文件，是命名规则为00000000000000000000.log的文件</li><li>index文件两个<ul><li>00000000000000000000.index</li><li>00000000000000000000.timeindex</li></ul></li></ul><p><strong>1）日志文件</strong></p><p>在一个 Segment 文件里面，日志是追加写入的。如果满足一定条件，就会切分日志文件，产生一个新的 Segment</p><p>什么时候会触发 Segment 的切分呢？ </p><p>第一种是根据日志文件大小。当一个 Segment 写满以后，会创建一个新的 Segment，用最新的 Offset 作为名称</p><p>Segment 的默认大小是 1073741824 bytes(1G)，由参数<code>log.segment.bytes</code>控制</p><p>第二种是根据消息的最大时间戳，和当前系统时间戳的差值</p><p>有一个默认的参数，168 个小时(一周):</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log.roll.hours</span>=<span class="string">168</span></span><br></pre></td></tr></table></figure><p>意味着:如果服务器上次写入消息是一周之前，旧的 Segment 就不写了，现在要创建一个新的 Segment</p><blockquote><p>还可以从更加精细的时间单位进行控制，如果配置了毫秒级别的日志切分间隔， 会优先使用这个单位，否则就用小时的</p></blockquote><p>第三种是根据索引文件&#x2F;timeindex文件大小，默认是10M</p><p>这种方法的含义就是说，如果索引写满了，那数据文件也要跟着一起拆分，不然会对不上</p><p><strong>2）索引文件</strong></p><p>由于一个 Segment 的文件里面可能存放很多消息，如果要根据 Offset 获取消息， 必须要有一种快速检索消息的机制——这个就是索引</p><p>在 Kafka 中设计了两种索引</p><ul><li>偏移量索引文件记录的是 Offset 和消息物理地址(在 Log 文件中的位置)的映射关系</li><li>时间戳索引文件记录的是时间戳和 Offset 的关系</li></ul><p>当然，内容是二进制的文件，不能以纯文本形式查看</p><p><strong>offset索引</strong></p><p>bin 目录下有 dumplog 工 具，通过查看最后 10 条 Offset 索引(160 服务器)如下</p><img src="https://static-2w2.pages.dev/post/mq-index.png" alt="image-20230413155501413" style="zoom:50%;" /><p>为什么索引里面记录的 Offset 不是连续的呢?不应该是一条消息一条索引记录吗？</p><p>注意 Kafka 的索引并不是每一条消息都会建立索引</p><p>而是一种稀疏索引 Sparse Index(DB2 和 MongDB 中都有稀疏索引)</p><p>抽象图如下：</p><img src="/Users/zjyan/Library/Application Support/typora-user-images/image-20230413155621134.png" alt="image-20230413155621134" style="zoom:25%;" /><p>所以问题就来了，这个稀疏索引到底有多稀疏？也就是说，隔几条消息才产生一 个索引记录？或者隔多久？或者隔多少大小的消息？</p><p> 实际上是用消息的大小来控制的，默认是 4KB:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log.index.interval.bytes</span>=<span class="string">4096</span></span><br></pre></td></tr></table></figure><p> 只要写入的消息超过了 4KB，偏移量索引文件.index 和时间戳索引文 件.timeindex 就会增加一条索引记录(索引项)。</p><p>这个值设置越小，索引越密集，值设置越大，索引越稀疏</p><p>相对来说，越稠密的索引检索数据更快，但是会消耗更多的存储空间</p><p>越稀疏的索引占用存储空间越小，插入和删除时所需的维护开销也小，但是检索慢</p><p> Kafka 索引的时间复杂度为 O(log2n)+O(m)</p><p>n 是索引文件里索引的个数，m 为稀疏程度</p><p><strong>时间戳索引</strong></p><p>为什么会有时间戳索引文件呢？光有 Offset 索引还不够吗？会根据时间戳来查找消息？</p><p>首先，消息是必须要记录时间戳的</p><p>客户端封装的 ProducerRecord 和ConsumerRecord 都有一个 long timestamp 属性</p><p>为什么要记录时间戳呢? </p><ul><li>如果要基于时间切分日志文件，必须要记录时间戳</li><li>如果要基于时间清理消息，必须要记录时间戳</li></ul><p>好吧，既然都已经记录时间戳了，干脆设计一个时间戳索引，可以根据时间戳查询</p><p>注意时间戳有两种</p><p>一种是消息创建的时间戳</p><p>一种是消费在 Broker 追加写入的时间</p><p>到底用哪个时间呢？由一个参数来控制</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CreateTime / LogAppendTime</span></span><br><span class="line"><span class="attr">log.message.timestamp.type</span>=<span class="string">CreateTime </span></span><br></pre></td></tr></table></figure><p><strong>3）索引查询</strong></p><p>既然已经有索引了，那么如何利用索引来进行消息的检索呢？</p><p>比如要检索偏移量是 10000666 的消息</p><ul><li>消费的时候是能够确定分区的，所以第一步是找到在哪个 Segment 中。 Segment 文件是用 Base Offset 命名的，所以可以用二分法很快确定(找到名字不小 于 10000666 的 Segment)</li><li>这个 Segment 有对应的索引文件，它们是成套出现的。所以现在要在索引文 件中根据 Offset 找 Position</li><li>得到 Position 之后，到对应的 Log 文件开始查找 Offset，和消息的 Offset 进行比较，直到找到消息</li></ul><blockquote><p>思考一个比较刁钻的面试问题：为什么 Kafka 不用 B+Tree?</p><p>Kafka 是写多，查少，如果 Kafka 用 B+Tree，首先会出现大量的 B+Tree，大量插入数据带来的 B+Tree 的调整会非常消耗性能</p></blockquote><h4 id="1-7-总结"><a href="#1-7-总结" class="headerlink" title="1.7 总结"></a>1.7 总结</h4><p>总体topic结构如下：</p><img src="https://static-2w2.pages.dev/post/mq-kafka-topic2.png" alt="image-20230413160645706" style="zoom:25%;" /><p>到此为止topic结构已经完全梳理清楚了，但是有个问题还是要提一下，那就是kafka消息消费之后并不会删除，但是也不可能把几年前的日志还保留着，那么会用什么策略保留消息呢？</p><blockquote><p>思考MySQL、redis的内存淘汰机制</p></blockquote><h3 id="2-消息保留和清理机制"><a href="#2-消息保留和清理机制" class="headerlink" title="2.消息保留和清理机制"></a>2.消息保留和清理机制</h3><blockquote><p>这里回忆一下MySQL和Redis的内存淘汰机制</p><p><a href="https://yzj.life/2023/01/07/MySql%EF%BC%88%E4%B8%80%EF%BC%89/#7%EF%BC%89LRU">MySQL</a>：使用LRU List，划分young区和old区，冷热分离</p><p><a href="https://yzj.life/2023/02/24/redis%E8%AF%A6%E8%A7%A3/#2-%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">Redis</a>：多达七种淘汰策略</p></blockquote><p>Kafka里面提供了两种方式：一种是直接删除 Delete，一种是对日志进行压缩Compact</p><p>默认是直接删除</p><h4 id="2-1-删除策略"><a href="#2-1-删除策略" class="headerlink" title="2.1 删除策略"></a>2.1 删除策略</h4><p>删除是如何删除的呢？</p><p>第一种策略：日志数据较均匀时</p><p>默认是5min执行一次删除，删除范围是168小时之前的老数据，也就是定时删老数据</p><p>定时时间和删多久之前的数据，都可以配置</p><p>第二种策略：日志数据分布不均时（可能某一周特别大，另一周特别小）</p><p>根据日志大小删除，先删旧的消息，删到不超过这个大小为止</p><h4 id="2-2-压缩策略"><a href="#2-2-压缩策略" class="headerlink" title="2.2 压缩策略"></a>2.2 压缩策略</h4><p>问题：如果同一个 Key 重复写入多次，会存储多次还是会更新？</p><p>比如用来存储位移的这个特殊的 topic:__consumer_offsets</p><p>存储的是消费者 id 和 Partition 的 Offset 关系，消费者不断地消费消息 commit 的时候，是直接更新原来的 Offset，还是不断地写入新的 Offset？</p><p>肯定是存储多次，不然怎么能实现顺序写</p><p>当有了这些 Key 相同的 Value 不同的消息的时候，存储空间就被浪费了</p><p>压缩就是把相同的 Key 合并为最后一个 Value——前面的都被覆盖，这也和更新offset差不多</p><img src="https://static-2w2.pages.dev/post/mq-kafka-compress.png" alt="image-20230413162951198" style="zoom:50%;" /><h3 id="3-高可用及选举策略"><a href="#3-高可用及选举策略" class="headerlink" title="3.高可用及选举策略"></a>3.高可用及选举策略</h3><h4 id="3-1-Controller-选举"><a href="#3-1-Controller-选举" class="headerlink" title="3.1 Controller 选举"></a>3.1 Controller 选举</h4><p>当Leader宕机后，怎么选出来新的Leader呢？</p><p>早期的kafka是使用zk来进行投票选举，但是这样存在一个弊端，如果分区和副本数量过多，所有的副本都直接进行选举的话，一旦某个出现节点的增减，就会造成大量的 Watch 事件被触发，ZK 的就会负载过重，不堪重负</p><p>后来kafka更改了策略，不是所有的 Repalica 都参与 Leader 选举，而是由其中的一个 Broker 统一来指挥， 这个 Broker 的角色就叫做 Controller(控制器)</p><p>就像 Redis Sentinel 的架构，执行故障转移的时候，必须要先从所有哨兵中选一个负责做故障转移的节点一样，Kafka 也要先从所有 Broker 中选出唯一的一个 Controller</p><p>所有的 Broker 会尝试在 Zookeeper 中创建临时节点&#x2F;controller，只有一个能创建成功（先到先得）</p><p>如果 Controller 挂掉了或者网络出现了问题，ZK 上的临时节点会消失，其他的 Broker 通过 Watch 监听到 Controller 下线的消息后，开始竞选新的 Controller，方法跟之前还是一样的，谁先在 ZK 里面写入一个&#x2F;controller 节点，谁就成为新的Controller，这个 Controller 就相当于选举委员会的主席</p><p>那么这时候，这个节点就肩负了更多的责任，具体如下</p><ul><li>监听 Broker 变化</li><li>监听 Topic 变化</li><li>监听 Partition 变化</li><li>获取和管理 Broker、Topic、Partition 的信息</li><li>管理 Partiontion 的主从信息</li></ul><h4 id="3-2-分区副本Leader选举"><a href="#3-2-分区副本Leader选举" class="headerlink" title="3.2 分区副本Leader选举"></a>3.2 分区副本Leader选举</h4><p>Controller 确定以后，就可以开始做分区选主的事情了(我们叫它选举委员会主席)</p><p>下面就是找候选人了。显然，每个 Replica 都想推荐自己，但是所有的 replica 都有竞选资格吗？并不是</p><p>这里要介绍几个概念</p><p>一个分区所有的副本，叫做 Assigned-Replicas(AR)——所有的皇太子 </p><p>这些所有的副本中，跟 Leader 数据保持一定程度同步的，叫做 In-Sync Replicas (ISR)——天天过来参加早会的，有希望继位的皇太子</p><p>跟 Leader 同步滞后过多的副本，叫做 Out-Sync-Replicas(OSR)——天天睡懒觉，不参加早会，没被皇帝放在眼里的皇太子</p><p>AR&#x3D;ISR+OSR</p><p>正常情况下 OSR 是空的，大家都正常同步，AR&#x3D;ISR</p><p>谁能够参加选举呢？肯定不是 AR，也不是 OSR，而是 ISR，而且这个 ISR 不是固定不变的，还是一个动态的列表</p><p>前面说过，如果同步延迟超过 30 秒，就踢出 ISR，进入 OSR；如果赶上来了，就加入ISR</p><p>默认情况下，当 Leader 副本发生故障时，只有在 ISR 集合中的副本才有资格被选举为新的 Leader</p><p>如果 ISR 为空呢？——皇帝突然驾崩，太子们都还小，但是群龙不能无首</p><p>在这种情 况下，可以让 ISR 之外的副本参与选举。允许 ISR 之外的副本参与选举，叫做 Unclean Leader Election。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">unclean.leader.election.enable</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><p>把这个参数改成 true(一般情况不建议开启，会造成数据丢失)</p><p>那么这时候，候选人有了，举荐人也有了，选择谁呢？根据什么规则呢？</p><blockquote><p>分布式系统中常见的选举协议有哪些？</p><p>ZAB(ZK)、Raft(Redis Sentinel)(他们都是 Paxos 算法的变种)，它们的 思想归纳起来都是:先到先得、少数服从多数</p></blockquote><p>是 Kafka 没有用这些方法，而是用了一种自己实现的算法</p><p>为什么呢?比如 ZAB 这种协议，可能会出现脑裂（节点不能互通的时候，出现多个Leader）、惊群效应（大量 Watch 事件被触发）</p><p>那么kafka使用的是什么算法呢？</p><p>在这篇文章中: <a href="https://kafka.apache.org/documentation/#design_replicatedlog">https://kafka.apache.org/documentation/#design_replicatedlog</a><br>提到 Kafka 的选举实现，最相近的是微软的 PacificA 算法</p><p>在这种算法中，默认是让 ISR 中第一个 Replica 变成 Leader</p><p>比如 ISR 是 1、5、9，优先让1成为 Leader——这个跟中国古代皇帝传位是一样的，优先传给皇长子</p><h3 id="4-数据同步原理及故障处理"><a href="#4-数据同步原理及故障处理" class="headerlink" title="4.数据同步原理及故障处理"></a>4.数据同步原理及故障处理</h3><h4 id="4-1-主从同步"><a href="#4-1-主从同步" class="headerlink" title="4.1 主从同步"></a>4.1 主从同步</h4><p>在拥有一个确定的Leader之后，客户端的读写只能操作Leader节点，Follower需要向Leader同步数据</p><p>那么，由于不同的 Raplica 的 Offset 是不一样的，同步到底怎么同步呢？</p><p>先说下几个概念：</p><img src="https://static-2w2.pages.dev/post/mq-kafka-lfo.png" alt="image-20230413164637945" style="zoom:45%;" /><p><strong>LEO</strong>（Log End Offset）：下一条等待写入的消息的 Offset(最新的 Offset + 1)</p><p>图中分别是 9、8、6</p><p><strong>HW</strong>（High Watermark）：ISR 中最小的 LEO，Leader会管理所有 ISR 中最小的LEO作为HW，目前是 6</p><p>实际上，<strong>Consumer 最多只能消费到 HW 之前的位置(消费到 Offset 5 的消息)</strong></p><p>也就是说，其他的副本没有同步过去的消息，是不能被消费的</p><p>为什么要这样设计呢？</p><p>如果在同步成功之前就被消费了，Consumer Group 的 Offset 会偏大，如果 Leader 崩溃，中间会缺失消息</p><p>所以这是怎么消费的，那么到底怎么同步呢？先看一下过程</p><p>Follower1 同步了 1 条消息，Follower2 同步了 2 条消息，此时 HW 推进了 2， 变成 8</p><img src="https://static-2w2.pages.dev/post/mq-kafka-leo2.png" alt="image-20230413165300926" style="zoom:45%;" /><p>Follower1 同步了 0 条消息，Follower2 同步了 1 条消息。此时 HW 推进了 1， 变成 9</p><img src="https://static-2w2.pages.dev/post/mq-kafka-leo3.png" alt="image-20230413165409577" style="zoom:45%;" /><p>LEO 和 HW 重叠，所有的消息都可以消费了</p><p>这里，我们关注一下，从节点怎么跟主节点保持同步？</p><ul><li>Follower 节点会向 Leader 发送一个 fetch 请求，Leader 向 Follower 发送数据后，既需要更新 Follower 的 LEO</li><li>Follower 接收到数据响应后，依次写入消息并且更新 LEO</li><li>Leader 更新 HW(ISR 最小的 LEO)</li></ul><p>Kafka 设计了独特的 ISR 复制，可以在保障数据一致性情况下又可提供高吞吐量</p><h4 id="4-2-Replica-故障处理"><a href="#4-2-Replica-故障处理" class="headerlink" title="4.2 Replica 故障处理"></a>4.2 Replica 故障处理</h4><p><strong>Follower故障</strong></p><p>首先 Follower 发生故障，会被<strong>先踢出 ISR</strong>——无法同步了</p><p>Follower 恢复之后，从哪里开始同步数据呢？</p><p>假设第 1 个 Replica 宕机（中间这个）</p><img src="https://static-2w2.pages.dev/post/mq-kafka-lfo.png" alt="image-20230413164637945" style="zoom:45%;" /><p>恢复以后，首先根据之前记录的 HW(6)，把高于 HW 的消息截掉(6、7)</p><p>然后向 Leader 同步消息，追上 leader 之后(30 秒)，重新加入 ISR</p><p><strong>Leader故障</strong></p><p>假设图中 Leader 发生故障。<br>首先选一个 Leader，因为 Replica 1（中间这个）优先，它成为 Leader</p><p>为了保证数据一致，其他的 Follower 需要把高于 HW 的消息截取掉（这里没有消息需要截取）</p><p>然后 Replica2 同步数据</p><p>注意：这种机制只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复</p><h2 id="六、Consumer详解"><a href="#六、Consumer详解" class="headerlink" title="六、Consumer详解"></a>六、Consumer详解</h2><h3 id="1-消费者Offet维护原理"><a href="#1-消费者Offet维护原理" class="headerlink" title="1.消费者Offet维护原理"></a>1.消费者Offet维护原理</h3><h4 id="1-1-继续消费的Offet"><a href="#1-1-继续消费的Offet" class="headerlink" title="1.1 继续消费的Offet"></a>1.1 继续消费的Offet</h4><p>已知，在 Partition 中，消息是不会删除的，所以才可以追加写入，写入的消息连续有序的</p><p>这种特性决定了 Kafka 可以消费历史消息，而且按照消息的顺序消费指定消息， 而不是只能消费队头的消息</p><p>正常情况下，我们希望消费没有被消费过的数据，而且是从最先发送（序号小的）的开始消费（这样才是有序和公平的）</p><blockquote><p>首先要明确，一个partition的消费是按照<strong>消费者组</strong>为单位来消费的，一个消费者组里面的消费者不能重复消费同一个partition</p></blockquote><p>对于一个 Partition，消费者组怎么才能做到接着上次消费的位置（Offset）继续消费呢？肯定要把这个对应关系<strong>保存</strong>起来，下次消费的时候查找一下</p><p>那么它应该存在哪里呢？必然不可能存在消费者本地，因为所有消费者都可以使用这个 Consumer Group id，放到本地做不到同一维护的，因此要放在服务端</p><p>早期的kafka，是把消费者组和 Partition 的 Offset 直接维护在 ZK 中，但是因为读写的性能消耗太大了</p><p>后来就放在一个特殊的 Topic 中，名字叫__consumer_offsets， 默认有 50 个分区(offsets.topic.num.partitions 默认是 50)，每个分区默认一个 Replication</p><p>那么这个特殊的Topoc是怎么存储消费者组和分区之间的偏移量（offset）的呢？</p><p>在这个特殊的Topic里面，主要存储两种对象</p><ul><li>GroupMetadata：保存了消费者组中各个消费者的信息(每个消费者有编号)</li><li>OffsetAndMetadata：保存了消费者组和各个 partition 的 offset 位移信息元数据</li></ul><p>即一个保存消费者组和组里消费者的信息，一个保存消费者组和分片之间位移</p><p>这样当有新的消费时，可以直接根据这个特殊的Topic找到Offset，从而继续消费</p><h4 id="1-2-初始消费的Offet"><a href="#1-2-初始消费的Offet" class="headerlink" title="1.2 初始消费的Offet"></a>1.2 初始消费的Offet</h4><p>那么如果有一个新消费组的，那此时这个特殊的Topic里面没有保存Offset，如何开始消费呢？</p><p>消费者的代码中有一个参数，用来控制如果找不到偏移量的时候从哪里开始消费</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto.offset.reset</span></span><br></pre></td></tr></table></figure><ul><li>默认值是 latest，也就是从最新的消息(最后发送的)开始消费的，此时<strong>历史消费是不能消费的</strong></li><li>earliest 代表从最早的(最先发送的)消息开始消费，可以消费到历史消息</li><li>none，如果 Consumer Group 在服务端找不到 offset 会报错</li></ul><h4 id="1-3-更新offset"><a href="#1-3-更新offset" class="headerlink" title="1.3 更新offset"></a>1.3 更新offset</h4><p>何时更新offset呢？</p><p>offset的更新是由消费者发出一个commit动作之后，才会在broker里面更新</p><p>那么这个commit动作什么时候发生呢？</p><p>同样，这个动作可以手动提交，也可以自动提交，默认是自动提交true</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交方式</span></span><br><span class="line"><span class="attr">enable.auto.commit</span></span><br><span class="line"><span class="comment"># 自动提交频率</span></span><br><span class="line"><span class="attr">auto.commit.interval.ms</span></span><br></pre></td></tr></table></figure><p>如果想在消息消费完毕之后再更新，就要改为手动提交，两种提交方式</p><ul><li>consumer.commitSync()的手动同步提交</li><li>consumer.commitAsync()手动异步提交</li></ul><blockquote><p>如果不提交或者提交失败，Broker 的 Offset 不会更新，消费者组下次消费的时候会消费到重复的消息</p></blockquote><h3 id="2-消费者与分区的关系"><a href="#2-消费者与分区的关系" class="headerlink" title="2.消费者与分区的关系"></a>2.消费者与分区的关系</h3><p>所谓消费者与分区之间的关系，就是消费者消费哪个分区的问题</p><p>这里主要有三种情况</p><ul><li>消费者组里面的消费者数量等于Topic里面的分区partition数量</li><li>消费者组里面的消费者数量大于Topic里面的分区partition数量</li><li>消费者组里面的消费者数量小于Topic里面的分区partition数量</li></ul><p>但是要注意的是，消费者组和分区也可存在多对多的关系，唯一的限制就是同一个消费者组里面的消费者不能消费同一个Topic里面的分区两次</p><h4 id="2-1-消费策略"><a href="#2-1-消费策略" class="headerlink" title="2.1 消费策略"></a>2.1 消费策略</h4><p>这种情况下，必然有一些消费者是消费不到的，那么这些消费者是如何瓜分partition的呢？</p><p>默认策略是：RangeAssignor 范围分配</p><p>如下图</p><img src="https://static-2w2.pages.dev/post/mq-kafka-rangeAssignor.png" alt="image-20230413174714402" style="zoom:40%;" /><p>在这种模式中，会将分区按照范围划分，最后一个消费者可能分到的分区会少一点</p><p>还有另外两种策略，分别是RoundRobinAssignor（轮询）和StickyAssignor（粘滞）</p><p>RoundRobinAssignor（轮询）：即消费者轮流获取分区，按照上图的结构</p><p>C1对应分区：P0、P2、P4</p><p>C2对应分区：P1、P3</p><p>StickyAssignor（粘滞）：这种策略复杂一点，但是相对来说均匀一点，每次结果可能不一样</p><p>原则</p><ul><li>分区的分配尽可能的均匀</li><li>分区的分配尽可能和上次分配保持相同</li></ul><p>具体来说，StickyAssignor 会先将每个 Partition 分配给一个消费者，然后将剩余的 Partition 逐个分配给消费者组中还未分配到该 Partition 的消费者，以确保每个消费者都能消费到一定数量的 Partition</p><h4 id="2-2-ReBalance-分区再均衡"><a href="#2-2-ReBalance-分区再均衡" class="headerlink" title="2.2 ReBalance 分区再均衡"></a>2.2 ReBalance 分区再均衡</h4><p>进入话题之前，先提一个问题，什么叫ReBalance？</p><p>ReBalance本质上是一种协议，规定了一个消费者组下的所有消费者如何达成一致来分配订阅Topic的每个分区</p><p>比如某Group有20个消费者，订阅了有100个分区的Topic，那这时候Kafka就会为每个消费者分配5个分区，这个过程就是ReBalance</p><p><strong>那么什么时候ReBalance呢？</strong></p><p>两种情况</p><ul><li>消费者组的消费者数量发生变化，比如新增了消费者，消费者关闭连接 —— 学生数量变多了</li><li>Topic 的分区数发生变更，新增或者减少 —— 座位数量发生了变化</li></ul><p>为了让分区分配尽量地均衡，这个时候会触发 ReBalance 机制</p><p><strong>那么谁来执行 ReBalance 和 Consumer Group 管理呢？</strong></p><p>Kafka 提供了一个角色：Coordinator来执行对于Consumer Group的管理</p><blockquote><p>Kafka早期版本中的 Coordinator 是依赖 Zookeeper 来实现的</p></blockquote><p>最新的版本中，Kafka 对Coordinator进行了改进，每个Consumer Group都会被分配一个 Coordinator 用于组管理和 Offser 管理</p><p>责任：这个Group内的Coordinator比原来承担了更多的责任，比如组成员管理、Offset 提交保护机制等</p><p>选取：Consumer Group中的第一个Consumer启动的时候，它会去和 Kafka 服务确定谁是它们组的 Coordinator</p><p>协调：然后Group内的所有成员都会和这个Coordinator进行协调通信</p><p>很显然，有了Coordinator这个设计，就不再需要Zookeeper了，性能上可以得到很大的提升</p><p>那么 Consumer Group 又是如何确定自己的 Coordinator 是谁的呢?？</p><p>其实非常简单，就是找到分区的Leader所在的Broker，就会被选定为Coordinator</p><h2 id="七、Kafka为什么那么快？"><a href="#七、Kafka为什么那么快？" class="headerlink" title="七、Kafka为什么那么快？"></a>七、Kafka为什么那么快？</h2><p>MQ 的消息存储有几种选择，一种是内存，比如 ZeroMQ，速度很快但是不可靠</p><p>一种是第三方的数据库，会产生额外的网络消耗，而且数据库出问题会影响存储</p><p>所以最常见的是把数据放在磁盘上存储</p><p>但是我们也都知道，磁盘的 I&#x2F;O 是比较慢的，选择磁盘作为存储怎么实现高吞吐、低延迟、高性能呢？</p><p>总结起来，主要是 4 点:磁盘顺序 I&#x2F;O、索引机制、批量操作和压紧、零拷贝</p><h3 id="1-顺序索引"><a href="#1-顺序索引" class="headerlink" title="1.顺序索引"></a>1.顺序索引</h3><p>随机 I&#x2F;O 就是:读写的多条数据在磁盘上是分散的，寻址会很耗时<br>顺序 I&#x2F;O 读写的数据在磁盘上是集中的，不需要重复寻址的过程</p><p>Kafka 的 Message 是不断追加到本地磁盘文件末尾的，而不是随机的写入，这使 得 Kafka 写入吞吐量得到了显著提升</p><p>内存 I&#x2F;O 是不是一定比磁盘 I&#x2F;O 快呢? <a href="https://queue.acm.org/detail.cfm?id=1563874">https://queue.acm.org/detail.cfm?id=1563874</a></p><h3 id="2-索引"><a href="#2-索引" class="headerlink" title="2.索引"></a>2.索引</h3><p>参照上面第五节的1.6里面索引介绍</p><h3 id="3-批量读写和文件压缩"><a href="#3-批量读写和文件压缩" class="headerlink" title="3.批量读写和文件压缩"></a>3.批量读写和文件压缩</h3><p>批量读写和文件压缩 它把所有的消息都变成一个批量的文件，并且进行合理的批量压缩，减少网络 IO 损耗<br> <a href="http://kafka.apache.org/documentation/#recordbatch">http://kafka.apache.org/documentation/#recordbatch</a></p><h3 id="4-零拷贝"><a href="#4-零拷贝" class="headerlink" title="4.零拷贝"></a>4.零拷贝</h3><p>首先介绍两个名词</p><p><strong>第一个是操作系统虚拟内存的内核空间和用户空间</strong></p><p> 操作系统的虚拟内存分成了两块，一部分是内核空间，一部分是用户空间</p><p>这样就可以避免用户进程直接操作内核，保证内核安全</p><p>进程在内核空间可以执行任意命令，调用系统的一切资源;在用户空间必须要通过一些系统接口才能向内核发出指令</p><p>因此，如果用户要从磁盘读取数据(比如 Kafka 消费消息)，必须先把数据从磁盘拷贝到内核缓冲区，然后在从内核缓冲区到用户缓冲区，最后才能返回给用户</p><p><strong>第二个是 DMA 拷贝</strong></p><p>没有 DMA 技术的时候，拷贝数据的事情需要 CPU 亲自去做，这个时候它没法干其他的事情，如果传输的数据量大那就有问题了</p><p>DMA 技术叫做直接内存访问(Direct Memory Access)，其实可以理解为 CPU给自己找了一个小弟帮它做数据搬运的事情</p><p>在进行 I&#x2F;O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，解放了 CPU 的双手(反正就是找了个 小弟)</p><p>理解了这两个东西之后，我们来看下传统的 I&#x2F;O 模型</p><img src="https://static-2w2.pages.dev/post/mw-kafka-amd.png" alt="image-20230413185050276" style="zoom:45%;" /><p>比如 Kafka 要消费消息，比如要先把数据从磁盘拷贝到内核缓冲区，然后拷贝到用户缓冲区，再拷贝到 Socket 缓冲区，再拷贝到网卡设备</p><p>这里面发生了 4 次用户态 和内核态的切换和 4 次数据拷贝，2 次系统函数的调用(read、write)，这个过程是非常耗费时间的。怎么优化呢?</p><p>在 Linux 操作系统里面提供了一个 sendfile 函数，可以实现“零拷贝”。这个时候就不需要经过用户缓冲区了，直接把数据拷贝到网卡(这里画的是支持 SG-DMA 拷 贝的情况)</p><p>因为这个只有 DMA 拷贝，没有 CPU 拷贝，所以叫做“零拷贝”</p><p>零拷贝至少可以提高一倍的性能</p><img src="https://static-2w2.pages.dev/post/mq-kafka-zero-copy.png" alt="image-20230413185453985" style="zoom:45%;" /><h2 id="八、总结—Kafka消息不丢失的配置"><a href="#八、总结—Kafka消息不丢失的配置" class="headerlink" title="八、总结—Kafka消息不丢失的配置"></a>八、总结—Kafka消息不丢失的配置</h2><p>1、Producer 端使用 producer.send(msg, callback)带有回调的 send 方法，而不是 producer.send(msg)方法。根据回调，一旦出现消息提交失败的情况，就可以有针对性地进行处理</p><p>2、设置 acks &#x3D; all。acks 是 Producer 的一个参数，代表“已提交”消息的定义。 如果设置成 all，则表明所有 Broker 都要接收到消息，该消息才算是“已提交”</p><p>3、设置 retries 为一个较大的值。同样是 Producer 的参数。当出现网络抖动时， 消息发送可能会失败，此时配置了 retries 的 Producer 能够自动重试发送消息，尽量 避免消息丢失</p><p>4、设置 unclean.leader.election.enable &#x3D; false。这是 Broker 端的参数，在 Kafka 版本迭代中社区也多次反复修改过他的默认值，之前比较具有争议。它控制哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，将会导致消息丢失。故一般都要将该参数设置成 false</p><p>5、设置 replication.factor &gt;&#x3D; 3。需要三个以上的副本</p><p>6、设置 min.insync.replicas &gt; 1。Broker 端参数，控制消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在生产环境中不要使用默认值 1。确保 replication.factor &gt; min.insync.replicas。如果两者相等，那么 只要有一个副本离线，整个分区就无法正常工作了。推荐设置成 replication.factor &#x3D; min.insync.replicas + 1</p><p>7、确保消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最 好设置成 false，并自己来处理 Offset 的提交更新</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> Kafka </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件之RocketMQ</title>
      <link href="/2023/04/03/MQ%E4%B9%8BRocketMQ/"/>
      <url>/2023/04/03/MQ%E4%B9%8BRocketMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="一、架构"><a href="#一、架构" class="headerlink" title="一、架构"></a>一、架构</h2><p>最开始叫 MetaQ(Meta-morphosis [ˌmetəˈmɔːfəsɪs]变形)</p><p>淘宝原来有一 个自研的 MQ 叫 Notify，Kafka 开源以后，就参考 Kafka 用 Java 语言写了 MetaQ， 所以在涉及思想上有很多跟 Kafka 相似的地方。后来改名字叫 RocketMQ，2012 年开源</p><h3 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1.整体架构"></a>1.整体架构</h3><img src="https://static-2w2.pages.dev/post/mq-rocket-all.png" alt="image-20230415151544795" style="zoom:45%;" /><p>首先分析一下RocketMQ的整体架构图，它的构成也和其他MQ类似，生产者，Broker和消费者</p><p>与Kafka不同的是，RocketMQ不需要ZK的配合使用，它自身便有NameServer来负责类似ZK的功能</p><h3 id="2-Broker"><a href="#2-Broker" class="headerlink" title="2.Broker"></a>2.Broker</h3><p>RocketMQ 的服务，或者说一个进程，叫做 Broker，Broker 的作用是存储和转发消息RocketMQ 单机大约能承受 10 万 QPS 的请求</p><img src="https://static-2w2.pages.dev/post/mq-rocket-broker.png" alt="image-20230415151907234" style="zoom:50%;" /><p>为了提升 Broker 的可用性(防止单点故障)，以及提升服务器的性能(实现负载)， 通常会做集群的部署<br>跟 Kafka 或者 Redis Cluster 一样，RocketMQ 集群的每个 Broker 节点保存总数据的一部分，因此可以实现横向扩展</p><p>而为了提升数据的可靠性，每个Broker还会有自己的副本slave</p><img src="https://static-2w2.pages.dev/post/mq-rocket-replaice.png" alt="image-20230415152108748" style="zoom:50%;" /><p>默认情况下，读写都发生在 Master 上</p><p>在 slaveReadEnable&#x3D;true 的情况下， Slave 也可以参与读负载</p><p>但是默认只有 brokerId&#x3D;1 的 Slave 才会参与读负载，而且是在 Master 消费慢的情况下，由whichBrokerWhenConsumeSlowly这个参数决定</p><blockquote><p>注意，在RocketMQ里面，Master指的是副本的主，Slave则指的是副本</p></blockquote><h3 id="3-Topic"><a href="#3-Topic" class="headerlink" title="3.Topic"></a>3.Topic</h3><p>Topic 用于将消息按主题做划分，比如订单消息、物流消息</p><blockquote><p>注意，跟 Kafka 不 同的是，在 RocketMQ 中，Topic 是一个逻辑概念，消息不是按 Topic 划分存储的</p></blockquote><img src="https://static-2w2.pages.dev/post/mq-rocket-topic.png" alt="image-20230415152314114" style="zoom:50%;" /><p>producer 将消息发往指定的 Topic，Consumer 订阅这个 Topic 就可以收到相应的消息<br> 跟 Kafka 一样，如果 Topic 不存在，会自动创建，BrokerConfig:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">private</span> <span class="string">boolean autoCreateTopicEnable = true;</span></span><br></pre></td></tr></table></figure><p>Topic 跟生产者和消费者都是多对多的关系，一个生产者可以发送消息到多个Topic，一个消费者也可以订阅多个Topic</p><h3 id="4-NameServer"><a href="#4-NameServer" class="headerlink" title="4.NameServer"></a>4.NameServer</h3><p>NameServer可以看作是RocketMQ的一个分布式注册中心，它为整个RocketMQ集群提供了元数据信息的注册和查找服务</p><p>所有的Broker节点和Client节点都需要与NameServer交互来获取元数据信息和路由信息，从而实现消息的发送和消费，如Topic信息、Producer信息、Consumer信息等，以及消息队列在Broker上的映射关系</p><h4 id="4-1-基础结构"><a href="#4-1-基础结构" class="headerlink" title="4.1 基础结构"></a>4.1 基础结构</h4><p>当不同的消息存储在不同的 Broker 上，生产者和消费者对于 Broker 的选取，或者说路由选择是一个非常关键的问题</p><ul><li>路由：生产者发一条消息，应该发到哪个 Broker？消费者接收消息，从哪个 Broker 获取消息?</li><li>服务端增减：如果 Broker 增加或者减少了，客户端怎么知道?？</li><li>客户端增加：一个新的生产者或者消费者加入，怎么知道有哪些 Broker</li></ul><p>所以，跟分布式的服务调用的场景需要一个注册中心一样，在 RocketMQ 中需要有一个角色来管理 Broker 的信息</p><blockquote><p>在Kafka中，使用ZK管理的路由选择功能</p></blockquote><p>在Rocket中，并没有使用ZK做一些路由发现，存活状态监听等工作，而是把这份工作交给了自己创建的组件NameServer来实现</p><p>可以把 NameServer 理解为是 RocketMQ 的路由中心，每一个 NameServer 节点都保存着全量的路由信息，为了保证高可用，NameServer 自身也可以做集群的部署</p><p>它的作用有点像 Eureka 或者 Redis Sentinel</p><p>也就是说，Broker 会在 NameServer 上注册自己，Porducer 和 Consumer 用 NameServer 来发现 Broker</p><img src="/Users/zjyan/Library/Application Support/typora-user-images/image-20230415153919043.png" alt="image-20230415153919043" style="zoom:50%;" /><p>那么，NameServer的工作机制到底是怎样的呢？</p><p>每个 Broker 节点在启动时，都会根据配置遍历 NameServer 列表，如下配置</p><p>文件：rocketmq&#x2F;conf&#x2F;broker.conf</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">localhost:9876</span></span><br></pre></td></tr></table></figure><p><strong>存活检测</strong></p><p>与每个 NameServer 建立 TCP 长连接，注册自己的信息，之后每隔 30s 发送心跳信息（服务主动注册）</p><p>那么如果 Broker 挂掉了，不发送心跳了，NameServer 怎么发现呢？</p><p>因此NameServer也会主动的去探测Broker是否存活</p><p><strong>定时探活</strong></p><p>每个 NameServer 每隔 10s 检查一下各个Broker 的最近一次心跳时间，如果发现某个 Broker 超过 120s 都没发送心跳，就认为 这个 Broker 已经挂掉了，会将其从路由信息里移除</p><img src="https://static-2w2.pages.dev/post/mq-rocket-nameserve2.png" alt="image-20230415154300081" style="zoom:50%;" /><h4 id="4-2-为什么不用ZK？"><a href="#4-2-为什么不用ZK？" class="headerlink" title="4.2 为什么不用ZK？"></a>4.2 为什么不用ZK？</h4><p>实际上不是不用，在 RocketMQ 的早期版本，即 MetaQ 1.x 和 2.x 阶段，服务管理也是用 Zookeeper 实现的，跟 Kafka 一样，但MetaQ 3.x(即 RocketMQ)却去 掉了 ZooKeeper 依赖，转而采用自己的 NameServer</p><p>RocketMQ 的架构设计决定了只需要一个轻量级的元数据服务器就足够了，只需要保持最终一致，而<strong>不需要 Zookeeper 这样的强一致性解决方案</strong>，不需要再依赖另一个中间件，从而减少整体维护成本</p><p>根据著名的 CAP 理论：一致性(Consistency)、可用性(Availability)、分区容错性 (Partiton Tolerance)。Zookeeper 实现了 CP，NameServer 选择了 AP，放弃了实时一致性</p><h4 id="4-3-一致性问题"><a href="#4-3-一致性问题" class="headerlink" title="4.3 一致性问题"></a>4.3 一致性问题</h4><p><strong>首先声明一个很重要的点，那就是NameServer之间是不互相通信的</strong></p><p>上面也提到了NameServer放弃了实时一致性，那它是在何种措施下保证，即使它们之间互相不通信也能保持一致性的呢？</p><p>主要依赖三点，服务注册、服务剔除与路由发现</p><ul><li>服务注册：这一步是由Broker发起的，如果新增了Broker，那么它就会每隔30s就向所有NameServer发送心跳信息</li><li>服务剔除：分两种情况，分别是正常关闭和异常关闭<ul><li>正常关闭：连接断开，NameServer能够监测到，从而正常剔除Broker信息</li><li>异常关闭：NameServer每10s扫描Broker列表，如果某个Broker超过120s未同步心跳，就会剔除掉</li></ul></li><li>路由发现：客户端怎么获取最新的Broker列表呢？<ul><li>生产者：第一次发送消息时，根据Topic从NameServer获取路由信息</li><li>消费者：订阅固定的Topic，启动时获取Broker信息</li><li>Broker信息如果更新，NameServer可以同步到，那生产者和消费者如何更新呢？这里采用的是定时更新策略，默认<strong>30s</strong>获取一次</li></ul></li></ul><p>更新这里可以发现一个问题，那就是如果Broker刚挂，客户端 <strong>30s</strong>以后才更新路由信息，那是不是会出现最多 30 秒钟的数据延迟?比如说一个 Broker 刚挂了，客户端缓存的还是旧的路由信息，发消息和接收消息都会失败</p><p>这个问题有几个解决思路: </p><p>1）重试：拉取的时间间隔由 DefaultMQPushConsumer 的 pollNameServerInterval 参数 决定，默认是 30 秒</p><p>2）把无法连接的 Broker 隔离掉，不再连接</p><p>3）或者优先选择延迟小的节点，就能避免连接到容易挂的 Broker</p><h3 id="5-Producer-生产者"><a href="#5-Producer-生产者" class="headerlink" title="5.Producer 生产者"></a>5.Producer 生产者</h3><p>生产者，用于生产消息，会定时从NameServer拉取路由信息(不用配置 RocketMQ 的服务地址)，然后根据路由信息与指定的 Broker 建立 TCP 长连接，从 而将消息发送到 Broker 中</p><p>发送逻辑一致的 Producer 可以组成一个 Group，这个Group里的Pro</p><p>RocketMQ 的生产者同样支持批量发送，不过 List 要自己传进去</p><h3 id="6-Consumer-消费者"><a href="#6-Consumer-消费者" class="headerlink" title="6.Consumer 消费者"></a>6.Consumer 消费者</h3><p>消息的消费者，通过 NameServer 集群获得 Topic 的路由信息，连接到对应的 Broker 上消费消息</p><p>消费逻辑一致的 Consumer 可以组成一个 Group，这时候消息会在 Consumer 之间负载</p><p>建立连接：由于Master和Slave 都可以读取消息，因此 Consumer 会与 Master 和 Slave 都建立连接</p><blockquote><p>注意：同一个 Consumer Group 内的消费者应该订阅同一个 Topic；或者反过来，消费不同 Topic 的消费者不应该采用相同的 Consumer Group 名字。如果不一样，后面的消费者的订阅，会覆盖前面的订阅</p></blockquote><p>在RocketMQ中，消费者有两种消费方式，分别是<strong>集群消费</strong>和<strong>广播消费</strong></p><ul><li>集群消费：多个消费者消费同一个Topic的消息，每个消费一部分</li><li>广播消费：每个消费者都会消费同一个Topic下的所有消息，每个都消费全部消息</li></ul><blockquote><p>消费者的消费模式在创建消费者时进行指定，并且创建之后无法更改</p></blockquote><p>按照消费模型来说，RocketMQ也有两种模式，分别是<strong>Pull</strong>和<strong>Push</strong></p><ul><li>Pull：轮询从Broker拉取消息，使用长轮询实现，所谓长轮询就是如果轮询不到相关数据，就会hold住请求，等到有数据或者等一定时间后再返回，返回后客户端立即发起下一次长轮询</li><li>push：Broker推送给Consumer，但是在RocketMQ里面，这个模式实际上是依赖Pull实现的，在Pull模式基础上封装了一层，所以它不是真正的“推模式”</li></ul><blockquote><p>push的本质是用监听器，监听到获取了消息后，唤醒Consumer进行pull消费</p></blockquote><h3 id="7-Message-Queue-消息队列"><a href="#7-Message-Queue-消息队列" class="headerlink" title="7.Message Queue 消息队列"></a>7.Message Queue 消息队列</h3><p>RocketMQ 支持多 Master 的架构</p><p>思考一个这样的问题：当有多个 Master 的时候，发往一个 Topic 的多条消息会在多个 Master 的 Broker 上存储，那么，发往某一个 Topic 的多条消息，是不是在所有的 Broker 上存储完全相同的内容？</p><p>这样不符合分片的思想，因此这些消息也肯定是分片存储在不同的Broker上的</p><blockquote><p>在 Kafka 里面设计了一个 Partition，一个 Topic 可以拆分成多个 Partition，这些Partition 可以分布在不同的 Broker 上，这样就实现了数据的分片，也决定了 Kafka 可以实现横向扩展</p></blockquote><p>那么Rocket如何分片呢？</p><p>在一个 Broker 上，RocketMQ 只有一个存储文件，并没有像 Kafka 一样按照不 同的 Topic 分开存储</p><p>数据目录：&#x2F;usr&#x2F;local&#x2F;rocketmq&#x2F;store&#x2F;broker-a&#x2F;commitlog<br>也就说，如果有 3 个 Broker，也就是只有 3 个用来存储不同数据的 commitlog</p><p>那问题就来了，如果不按照分区去分布，数据应该根据什么分布呢?</p><p>RocketMQ 里面设计了一个叫做 Message Queue 的逻辑概念，作用跟 Partition 类似</p><p>首先，创建 Topic 的时候会指定队列的数量，一个叫 writeQueueNums(写队列数量)，一个 readQueueNums(读队列数量)</p><p><strong>写队列的数量决定了有几个 Message Queue，读队列的数量决定了有几个线程来消费这些 Message Queue（只是用来负载的）</strong></p><p>那可以不指定MQ吗？可以</p><p>如果不指定的话，应该创建几个默认队列呢？参数指定</p><p><strong>下面看看它的正式定义和相关概念</strong></p><p>在 RocketMQ 中，Message Queue 是指一个 Topic 下的一个子主题，也可以理解为一个逻辑的消息队列；消息发送到一个 Topic 中，但是实际上这些消息是存储在不同的 Message Queue 中，每个 Message Queue 存储了一部分消息；在 RocketMQ 中，Message Queue 被设计为可以动态添加和删除，以实现消息的负载均衡和容错能力</p><p>一个 Message Queue 被描述为一个四元组：Topic、Broker Name、队列 ID、Broker 地址</p><ul><li>Topic：表示该 Message Queue 所属的 Topic</li><li>Broker Name：表示该 Message Queue 所在的 Broker 名称</li><li>队列 ID：表示该 Message Queue 的 ID</li><li>Broker地址：表示该 Message Queue 所在的 Broker 的网络地址</li></ul><h2 id="二、原理解析"><a href="#二、原理解析" class="headerlink" title="二、原理解析"></a>二、原理解析</h2><h3 id="1-生产者"><a href="#1-生产者" class="headerlink" title="1.生产者"></a>1.生产者</h3><p>上面提到了，Message Queue提供了横向扩展的能力，生产者可以利用Message Queue实现消息的负载和平均分布，但是这里产生了一个问题，那就是什么时候消息会发送到哪个队列呢？</p><h4 id="1-1-消息发送规则"><a href="#1-1-消息发送规则" class="headerlink" title="1.1 消息发送规则"></a>1.1 消息发送规则</h4><p>追踪源码，可以知道消息发送有三个实现策略对应的实现类</p><ul><li>SelectMessageQueueByHash：它是一种不断自增、轮询的方式</li><li>SelectMessageQueueByRandom：随机选择一个队列</li><li>SelectMessageQueueByMachineRoom：返回空，没有实现</li></ul><p>此外，还可以自定义策略</p><h4 id="1-2-顺序消息"><a href="#1-2-顺序消息" class="headerlink" title="1.2 顺序消息"></a>1.2 顺序消息</h4><p>在MQ中，消息的顺序性向来是一项绕不过去的问题，那么在RocketMQ里面如何保证的消息顺序呢？</p><p>在介绍消费顺序之前，需要先区分一个概念，那就是全局有序和局部有序</p><ul><li>全局有序：就是不管有几个生产 者，在服务端怎么写入，有几个消费者，消费的顺序跟生产的顺序都是一致的</li><li>局部有序：只需要保证同一个订单相关的消息，消费的时候有序即可，如下图所示</li></ul><img src="https://static-2w2.pages.dev/post/mq-rocket-mqsort.png" alt="image-20230415193817802" style="zoom:50%;" /><p>而要保证消息有序，需要拆分成以下几个环节来进行</p><ul><li>生产者发送消息的时候，到达 Broker 应该是有序的<ul><li>所以对于生产者，不能使用多线程异步发送，而是顺序发送</li></ul></li><li>写入 Broker 的时候，应该是顺序写入的<ul><li>也就是相同主题的消息应该集中写入，选择同一个 Queue，而不是分散写入</li></ul></li><li>消费者消费的时候只能有一个线程<ul><li>否则由于消费的速率不同，有可能出现 记录到数据库的时候无序</li></ul></li></ul><h4 id="1-3-事务消息"><a href="#1-3-事务消息" class="headerlink" title="1.3 事务消息"></a>1.3 事务消息</h4><p>即要确保发送出去的消息能够成功被Broker接收&#x2F;或者都不接收</p><p>举个例子，比如先发送MQ消息，再操作本地数据库，如何保证数据一致性呢？</p><p>MQ发送失败或者发送成功之外，还有一种情况要考虑，那就是第一步成功，第二步失败</p><p>这时候消息已经交给Broker了，而Mysql存储失败，怎么办？</p><p>因此不能先发给MQ再发给Mysql</p><p>那如果顺序调换呢？先发送给Mysql再发给MQ？</p><p>同样有第一步成功，第二步失败的问题</p><p>所以在Rocket里面，参考了2PC的设计思想，把发送消息分成了两步，然后把操作本地数据库的步骤放进了这个流程里面，具体实现步骤如下</p><ul><li>在最开始，生产者先发送给Broker一条消息试探一下，收到这条消息的Broker把这条消息标记未“未确认”</li><li>Broker通知生产者接收消息成功，然后可以去执行本地事务</li><li>生产者执行本地事务</li><li>本地事务执行成功，那么就再给Broker发送消息，把消息标记为”已确认“</li><li>本地事务执行失败，那么就再给Broker发送消息，把消息标记为”丢弃“</li><li>如果Broker迟迟收不到生产者发送的确认消息，那么就去本地检查是否成功，再改状态</li></ul><p>在这个过程中，出现了两个新的概念</p><ul><li>半消息 half message：即暂时不能投递给消费者的消息，等待生产者二次确认</li><li>消息回查 Message Status Check：即上面的最后一步，Broker主动去查询消息状态</li></ul><img src="https://static-2w2.pages.dev/post/mq-rocket-2pc.png" alt="image-20230415195343967" style="zoom:50%;" /><p>具体流程描述：</p><p>1.生产者向 MQ 服务端发送消息</p><p>2.MQ 服务端将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功， 此时消息为半消息</p><p>3.发送方开始执行本地数据库事务逻辑</p><p>4.发送方根据本地数据库事务执行结果向 MQ Server 提交二次确认(Commit 或是 Rollback)，MQ Server 收到 Commit 状态则将半消息标记为可投递，订阅方最终将收到该消息;MQ Server 收到 Rollback 状态则删除半消息，订阅方将不会接受该消息</p><p>5.在断网或者是应用重启的特殊情况下，上述步骤 4 提交的二次确认最终未到达MQ Server，经过固定时间后 MQ Server 将对该消息发起消息回查</p><p>6.发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果</p><p>7.发送方根据检查得到的本地事务的最终状态再次提交二次确认，MQ Server 仍 按照步骤 4 对半消息进行操作(Commit&#x2F;Rollback)。</p><h4 id="1-4-延迟消息"><a href="#1-4-延迟消息" class="headerlink" title="1.4 延迟消息"></a>1.4 延迟消息</h4><p>在 RabbitMQ 里面需要通过死信队列或者插件来实现</p><p>RocketMQ 可以直接支持 延迟消息，但是开源版本功能被阉割了，只能支持特定等级的消息，商业版本可以任意指定时间</p><h3 id="2-Broker-1"><a href="#2-Broker-1" class="headerlink" title="2.Broker"></a>2.Broker</h3><p>具体参考github上RocketMQ<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md">设计文档</a></p><p><img src="https://static-2w2.pages.dev/post/mq-rocket-save.png" alt="img"></p><h4 id="2-1-消息存储"><a href="#2-1-消息存储" class="headerlink" title="2.1 消息存储"></a>2.1 消息存储</h4><p>RocketMQ 的消息存储与 Kafka 有所不同，既没有分区的概念，也没有按分区存储消息</p><p>先看看RocketMQ对Kafka的存储设计看法：</p><ul><li>每个分区存储整个消息数据。尽管每个分区都是有序写入磁盘的，但随着并发 写入分区的数量增加，从操作系统的角度来看，写入变成了随机的</li><li>由于数据文件分散，很难使用 Linux IO Group Commit 机制（指的是一次把多个数据文件刷入磁盘。例如:批量发送 3 条数据，分散在 3 个文件里面，做不到一 次刷盘）</li></ul><p>因此，RocketMQ设计了一种新的文件存储方式，就是把同一个Topic的所有消息全部写到同一个文件中（这种存储方式叫集中型存储或者混合型存储），从而保证顺序写</p><p>优势：</p><p>1）队列轻量化，单个队列数据量非常少</p><p>2）对磁盘的访问串行化，完全顺序写，避免磁盘竞争，不会因为队列增加导致 IOWAIT 增高</p><p>缺点就是消费复杂了</p><blockquote><p>在 Kafka中是一个Topic下面的Partition有独立的文件，只要在一个Topic里面找消息就OK了，Kafka把这个Consumer Group跟Topic的Offset的关系保存在一个特殊的Topic中</p></blockquote><p>现在变成了：要到一个统一的巨大的 commitLog 种去找消息，需要遍历全部的消息，效率太低了，那怎么办呢?</p><p>如果想要每个 Consumer Group 只查找自己的 Topic 的 Offset 信息，可以为每 一个Consumer Group 把他们消费的 Topic 的最后消费到的 Offset 单独存储在一个地方，这个存储消息的偏移量的对象就叫做Consumer Queue</p><img src="https://static-2w2.pages.dev/post/mq-rocket-cosumer-offset.png" alt="image-20230415200723674" style="zoom:50%;" /><p>简单点说就是，Broker为每个消费者组都保存了一个在commitLog中的偏移量</p><p>也就是说，消息在 Broker 存储的时候，不仅写入 commitlog，同时也把在commit log中的最新的 Offset（异步）写入对应的 Consume Queue</p><p>消费者在消费消息的时候，先从 Consume Queue 读取持久化消息的起始物理位置偏移量Offset、大小 size 和消息 Tag 的 HashCode 值，随后再从 commit log 中 进行读取待拉取消费消息的真正实体内容部分</p><p>Consume Queue 可以理解为消息的索引，它里面没有存消息</p><p>总结：</p><ul><li>写是顺序写，但是读却变成了完全的随机读(对于 commit log)</li><li>读一条消息，会先读 Consume Queue，再读 commit log，增加了开销</li></ul><blockquote><p>更底层的存储文件不再介绍</p></blockquote><h4 id="2-2-存储关键技术（持久化-x2F-刷盘）"><a href="#2-2-存储关键技术（持久化-x2F-刷盘）" class="headerlink" title="2.2 存储关键技术（持久化&#x2F;刷盘）"></a>2.2 存储关键技术（持久化&#x2F;刷盘）</h4><p>RocketMQ消息存储在磁盘上，按理说不会很快，那么它又是如何做到这么低的延迟和这么高的吞吐呢？</p><p>CPU如果要读取或者操作磁盘上的数据，必须要把磁盘的数据加载到内存，这个是由硬件结构和访问速度的差异决定的</p><p>这个加载的大小有一个固定的单位，叫做 Page。x86 的 Linux 中一个标准页面大小是 4KB。如果要提升磁盘访问速度，或者说尽量减少磁盘 I&#x2F;O，可以把访问过的 Page 在内存中缓存起来。这个内存的区域就叫做 Page Cache</p><p>下次处理 I&#x2F;O 请求的时候，先到 Page Cache 查找，找到了就直接操作，没找到就到磁盘查找</p><p>Page Cache 本身也会对数据文件进行预读取，对于每个文件的第一个读请求操作， 系统在读入所请求页面的同时会读入紧随其后的少数几个页面</p><blockquote><p>十分类似MySql的Buffer Pool，<a href="https://yzj.life/2023/01/07/MySql%EF%BC%88%E4%B8%80%EF%BC%89/#2%EF%BC%89%E6%95%B0%E6%8D%AE%E9%A1%B5">传送门</a></p></blockquote><p>但这里还是有一个问题，虚拟内存分为内核空间和用户空间，而Page Cache 属于内核空间，用户空间访问不了，因此读取数据还需要从内核空间拷贝到用户空间缓冲区</p><img src="https://static-2w2.pages.dev/post/mq-rocket-bufferpage.png" alt="image-20230415201643338" style="zoom:50%;" /><p>可以看到数据需要从 Page Cache 再经过一次拷贝程序才能访问得到，这个 Copy 的过程会降低数据访问的速度。有什么办法可以避免从内核空间到用户空间的 Copy 呢？</p><p>没错，就是零拷贝！这个技术在kafka当中也有使用，但是两者原理不同，<a href="https://yzj.life/2023/04/04/MQ%E4%B9%8BKafka/#4-%E9%9B%B6%E6%8B%B7%E8%B4%9D">传送门</a></p><img src="https://static-2w2.pages.dev/post/mq-rocket-zero-copy.png" alt="image-20230415201901909" style="zoom:50%;" /><p>在这里是干脆把 Page Cache 的数据在用户空间中做一个地址映射，这样用户进程就可以通过指针操作直接读写 Page Cache，不再需要系统调用(例如 read())和内存拷贝</p><blockquote><p>RocketMQ 中具体的实现是使用 MMAP(Memory Map，内存映射)，不论是 CommitLog 还是 CosumerQueue 都采用了 <strong>MMAP</strong></p><p>Kafka 用的是 <strong>sendfile</strong></p></blockquote><h4 id="2-3-文件清理策略"><a href="#2-3-文件清理策略" class="headerlink" title="2.3 文件清理策略"></a>2.3 文件清理策略</h4><p>跟 Kafka 一样，RocketMQ 中被消费过的消息是不会删除的，所以保证了文件的顺序写入</p><p>如果不清理文件的话，文件数量不断地增加，最终会导致磁盘可用空间越来越少</p><p>清除哪些数据呢？主要清除 CommitLog、ConsumeQueue 的过期文件</p><p>什么情况下这些文件变成过期文件？默认是超过 72 个小时的文件</p><p>过期的文件什么时候删除呢？</p><ul><li>通过定时任务，每天凌晨 4 点，删除这些过期的文件</li><li>磁盘使用空间超过了 75%，开始删除过期文件；如果问题更严重，磁盘空间使用率超过 85%，会开始批量清理文件，不管有没有过期，直到空间充足；如果磁盘空间使用率超过 90%，会拒绝消息写入</li></ul><h3 id="3-消费者"><a href="#3-消费者" class="headerlink" title="3.消费者"></a>3.消费者</h3><p>在集群消费模式下（广播模式忽略），如果要提高消费者的负载能力， 必然要增加消费者的数量</p><p>消费者的数量增加了，怎么做到尽量平均的消费消息呢? 队列怎么分配给相应的消费者?</p><p>首先，队列的数量是固定的。比如有 4 个队列，假设有 3 个消费者，或者 5 个消费者，这个时候队列应该怎么分配？</p><p>如果消费者挂了？消费者增加了？队列又怎么分配？</p><h4 id="3-1-消费端的负载均衡与Rebalance"><a href="#3-1-消费端的负载均衡与Rebalance" class="headerlink" title="3.1 消费端的负载均衡与Rebalance"></a>3.1 消费端的负载均衡与Rebalance</h4><p>消费者启动的时候，或者有消费者挂掉的时候，默认最多 20 秒，就会做一次 ReBalance，让所有的消费者可以尽量均匀地消费队列的消息</p><p>那么有哪些ReBalance策略呢？</p><ul><li>AllocateMessageQueueAveragely：连续分配（默认）</li><li>AllocateMessageQueueAveragelyByCircle：每人轮流一个 </li><li>AllocateMessageQueueByConfig：通过配置 </li><li>AllocateMessageQueueConsistentHash：一致性哈希</li><li>AllocateMessageQueueByMachineRoom：指定一个 broker 的 topic 中的 queue 消费</li><li>AllocateMachineRoomNearby:按 Broker 的机房就近分配</li></ul><p>队列的数量尽量要大于消费者的数量</p><h4 id="3-2-消费端重试与死信队列"><a href="#3-2-消费端重试与死信队列" class="headerlink" title="3.2 消费端重试与死信队列"></a>3.2 消费端重试与死信队列</h4><p>什么叫消费端重试？</p><p>就是如果消费者消费成功，是不是要返回给Broker一个ack，改一下Offset的位置？</p><p>那如果消费失败了呢？返回东西呢？返回啥？</p><p>消费失败时，比如数据库不可用，网络问题啥的，消费者就会返回给Broker一个RECONSUME_LATER，意思是稍候重试</p><p>然后过一阵儿，Broker会把这个重试消息再发给消费者让他消费，如果还是异常，就再次重试，这个过程中等待时间是不断衰减增加的，从最初的10s会直到2h，最多经历16次重试</p><p>那16次之后呢？那就是真消费不了，直接扔进死信队列</p><p>Broker 会创建一个死信队列，死信队列的名字是%DLQ% + ConsumerGroupName</p><h3 id="4-特性"><a href="#4-特性" class="headerlink" title="4.特性"></a>4.特性</h3><p>现在市面上有这么多流行的消息中间件，RocketMQ 又有什么不同之处？</p><p>一般我们会从使用、功能、性能、可用性和可靠性四个方面来衡量</p><p>其中有一些是基础特性，这里重点说一下 RocketMQ 比较突出的：</p><p>1.单机可以<strong>支撑上万个队列</strong>的管理——可以满足众多项目创建大量队列的需求</p><p>2.上亿级消息<strong>堆积能力</strong>——在存储海量消息的情况下，不影响收发性能;</p><p>3.具有<strong>多副本容错</strong>机制——消息可靠性高，数据安全</p><p>4.可以<strong>快速扩容</strong>缩容，有状态管理服务器——那就意味着具备了横向扩展的能力</p><p>5.可严格保证消息的<strong>有序性</strong>——满足特定业务场景需求</p><p>6.Consumer 支持 Push 和 Pull 两种消费模式——更灵活(主要是 Pull)</p><p>7.支持<strong>集群消费</strong>和<strong>广播消息</strong>——适合不同业务场景</p><p>8.低<strong>延迟</strong>：客户端消息延迟控制在毫秒级别(从双十一的复盘情况来看延迟在 1ms 以内的消息比例 99.6%;延迟在 10ms 以内的消息占据 99.996%)——效率高</p><h2 id="三、高可用"><a href="#三、高可用" class="headerlink" title="三、高可用"></a>三、高可用</h2><p>在 RocketMQ 的高可用架构中，本文主要关注两块：主从同步和故障转移</p><img src="https://static-2w2.pages.dev/post/mq-rocket-use.png" alt="image-20230415203901051" style="zoom:40%;" /><h3 id="1-主从同步的意义"><a href="#1-主从同步的意义" class="headerlink" title="1.主从同步的意义"></a>1.主从同步的意义</h3><ul><li>数据备份：保证了两&#x2F;多台机器上的数据冗余，特别是在主从同步复制的情况下，一定程度上保证了Master出现不可恢复的故障以后，数据不丢失</li><li>高可用性：即使 Master 掉线， Consumer 会自动重连到对应的 Slave 机器，不会出现消费停滞的情况</li><li>提高性能：主要表现为可分担 Master读的压力，当从 Master 拉取消息，拉取消息的最大物理偏移与本地存储的最大物理偏移的差值超过一定值，会转向 Slave(默认brokerId&#x3D;1)进行读取，减轻了 Master 压力</li><li>消费实时：Master 节点挂掉之后，依然可以从 Slave 节点读取消息，而且会选择一个副本作为新的 Master，保证正常消费</li></ul><h3 id="2-数据同步"><a href="#2-数据同步" class="headerlink" title="2.数据同步"></a>2.数据同步</h3><h4 id="2-1-主从联系"><a href="#2-1-主从联系" class="headerlink" title="2.1 主从联系"></a>2.1 主从联系</h4><p>主从服务器怎么联系在一起？</p><p>比如 A 机器上的 broker-a-master 和 B 机器上的 broker-a-slave</p><p>依靠一下几点</p><ul><li>集群的名字相同，brokerClusterName&#x3D;tom-cluster</li><li>连接到相同的 NameServer</li><li>在配置文件中:brokerId &#x3D; 0 代表是 Master，brokerId &#x3D; 1 代表是 Slave</li></ul><h4 id="2-2-主从同步和刷盘类型"><a href="#2-2-主从同步和刷盘类型" class="headerlink" title="2.2 主从同步和刷盘类型"></a>2.2 主从同步和刷盘类型</h4><p>这些都在部署节点时，在配置文件中进行了设置，即设置了Broker角色和刷盘方式</p><table><thead><tr><th>属性</th><th>值</th><th></th><th>含义</th></tr></thead><tbody><tr><td>brokerRole &#x2F;&#x2F;Broker 的角色</td><td>ASYNC_MASTER</td><td>主从异步复制</td><td>Master写成功，返回客户端成功。拥有较低的延迟和较高的吞吐量，但是当Master出现故障后，有可能造成数据丢失</td></tr><tr><td></td><td>SYNC_MASTER</td><td>主从同步双写（推荐）</td><td>Master 和 Slave 均写成功，才返回客户端成功。Maste 挂了以后可以保证数据不丢失，但是同步复制会增加数 据写入延迟，降低吞吐量</td></tr><tr><td>flushDiskType &#x2F;&#x2F;刷盘方式</td><td>ASYNC_FLUSH</td><td>异步刷盘(默认)</td><td>生产者发送的每一条消息并不是立即保存到磁盘，而是 暂时缓存起来，然后就返回生产者成功。随后再异步的 将缓存数据保存到磁盘，有两种情况<br/>1 是定期将缓存中更新的数据进行刷盘，<br/> 2 是当缓存中更新的数据条数达到某一设定值后进行刷 盘。 这种方式会存在消息丢失(在还未来得及同步到磁盘的 时候宕机)，但是性能很好。默认是这种模式。</td></tr><tr><td></td><td>SYNC_FLUSH</td><td>同步刷盘</td><td>生产者发送的每一条消息都在保存到磁盘成功后才返回 告诉生产者成功。这种方式不会存在消息丢失的问题， 但是有很大的磁盘 IO 开销，性能有一定影响</td></tr></tbody></table><p><img src="https://static-2w2.pages.dev/post/mq-rocket-flush.png" alt="img"></p><p><strong>通常情况下，会把 Master 和 Slave 的 Broker 均配置成 ASYNC_FLUSH 异步刷盘方式，主从之间配置成 SYNC_MASTER 同步复制方式，即:异步刷盘+同步复制</strong></p><h4 id="2-3-主从同步流程"><a href="#2-3-主从同步流程" class="headerlink" title="2.3 主从同步流程"></a>2.3 主从同步流程</h4><p>主从同步流程:</p><p>1、从服务器主动建立 TCP 连接主服务器，然后每隔 5s 向主服务器发送 commitLog 文件最大偏移量拉取还未同步的消息;</p><p>2、主服务器开启监听端口，监听从服务器发送过来的信息，主服务器收到从服务 器发过来的偏移量进行解析，并返回查找出未同步的消息给从服务器;</p><p>3、客户端收到主服务器的消息后，将这批消息写入 commitLog 文件中，然后更新commitLog 拉取偏移量，接着继续向主服务拉取未同步的消息</p><h3 id="3-HA-与故障转移"><a href="#3-HA-与故障转移" class="headerlink" title="3.HA 与故障转移"></a>3.<strong>HA</strong> 与<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/controller/design.md">故障转移</a></h3><p>在之前的版本中，RocketMQ 只有 Master&#x2F;Slave 一种部署方式，一组 Broker 中有一个 Master，有零到多个 Slave，Slave 通过同步复制或异步复制方式去同步 Master 的数据</p><p>Master&#x2F;Slave 部署模式，提供了一定的高可用性</p><p>但这样的部署模式有一定缺陷，比如故障转移方面，如果主节点挂了还需要人为手动的进行重启或者切换，无法自动将一个从节点转换为主节点</p><p>如果要实现自动故障转移，根本上要解决的问题是自动选主的问题，即还是选Leader</p><p>比如 Kafka 用 Zookeeper 选 controller，用类 PacificA 算法选 Leader、Redis 哨兵用 Raft 协议选 Leader</p><p>RocketMQ 2019 年 3 月发布的 4.5.0 版本中，利用 Dledger 技术解决了自动选主的问题</p><p>DLedger 就是一个基于 Raft 协议的 commitlog 存储库，也是 RocketMQ 实现新的高可用多副本架构的关键。它的优点是不需要引入外部组件，自动选主逻辑集成到各个节点的进程中，节点之间通过通信就可以完成选主</p><img src="https://static-2w2.pages.dev/post/mq-rocket-dledger.png" alt="image-20230415205559155" style="zoom:50%;" /><p>这种情况下，commitlog 是 Dledger 管理的，具有选主的功能，具体选举流程如下</p><ol><li>当主节点失效后，集群中的其他节点会检测到主节点失效，并开始进行新的 leader 选举。</li><li>集群中的每个节点都会将自己的状态报告给其他节点，并且收集其他节点的状态报告。</li><li>节点根据收到的状态报告，计算出每个节点的可用性，并选择可用性最高的节点作为新的 leader 节点。</li><li>选出新的 leader 节点后，节点将新的 leader 节点信息广播给整个集群，以通知其他节点。</li><li>集群中的每个节点更新自己的 leader 节点信息，然后继续进行数据的读写操作。</li></ol><p>需要注意的是，leader 选举过程中可能会出现网络分区（network partition）等问题，导致集群出现多个主节点。为了避免这种情况，DLedger 采用了类似于 Paxos 算法中的多数派原则，要求集群中超过半数的节点认同新的 leader 节点才能生效，从而保证集群只有一个有效的主节点</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件之RabbitMQ</title>
      <link href="/2023/04/02/MQ%E4%B9%8BRabbitMQ/"/>
      <url>/2023/04/02/MQ%E4%B9%8BRabbitMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><h3 id="1-什么是消息中间件？"><a href="#1-什么是消息中间件？" class="headerlink" title="1.什么是消息中间件？"></a>1.什么是消息中间件？</h3><p>在早期的计算机通信中，都是采用点对点通信，并且两边要使用相同的协议，这无疑是强耦合且低可靠的，于是出现了消息中间件——位于通信双方中间的组件</p><p>官方点说，消息中间件是一种软件架构模式，用于处理分布式系统中的异步通信和数据传输。它是一种基于消息传递的模式，用于解耦不同应用程序或系统之间的通信，以提高系统的可靠性、可扩展性和可维护性</p><p>那么消息中间件具体有什么用呢？简单点说就是<strong>异步、削峰、解耦</strong></p><ul><li>异步：当系统中需要处理大量的请求时，可以将请求发送到消息队列中，而不是直接调用后端服务。后端服务从消息队列中读取请求，并通过异步方式进行处理，从而提高系统的性能和吞吐量。同时，异步方式还可以避免由于请求处理时间过长而导致的请求积压问题，提高系统的响应速度。</li><li>削峰：当系统面临高并发请求时，可以通过消息队列来削峰。具体来说，可以将请求发送到消息队列中，然后由后端服务从消息队列中读取请求进行处理。由于消息队列可以缓存大量的请求，因此可以有效地减少请求的到达率，从而保护系统不被过载。</li><li>解耦：当系统中不同的服务之间需要进行通信时，可以使用消息队列来解耦。具体来说，可以将消息发送到消息队列中，然后由不同的服务从消息队列中读取消息进行处理。这样可以将不同服务之间的通信变为异步方式，避免因为服务之间的耦合而导致的系统复杂性增加</li></ul><p>此外，MQ还支持广播等方式进行通信</p><h3 id="2-带来的问题"><a href="#2-带来的问题" class="headerlink" title="2.带来的问题"></a>2.带来的问题</h3><p>MQ虽好，但是也不能滥用，因为一个系统中引入新的组件，肯定会导致系统更加复杂等问题，具体如下：</p><ul><li><p>运维成本增加：既然要用 MQ，必须要分配资源部署 MQ，还要保证它时刻正常运行</p></li><li><p>系统可用性降低：原来是两个节点的通信，现在还需要独立运行一个服务。虽然一般的MQ都有很高的可靠性和低延迟的特性，但是一旦网络或者 MQ 服务器出现问题，就会导致请求失败，严重地影响业务</p></li><li><p>系统复杂性提高：为什么说复杂?作为开发人员，要使用 MQ，首先必须要理解相关的模型和概念，才能正确地配置和使用 M；。其次，使用 MQ 发送消息必须要考虑消息丢失和消息重复消费的问题。一 旦消息没有被正确地消费，就会带来数据一致性的问题</p></li></ul><h3 id="3-消息协议"><a href="#3-消息协议" class="headerlink" title="3.消息协议"></a>3.消息协议</h3><p>协议是计算机之间通信时共同遵从的一组约定，都遵守相同的约定，计算机之间才能相互交流，是对数据格式和计算机之间交换数据时必须遵守的规则的正式描述<br> 协议三要素:</p><ul><li>语法:即数据与控制信息的结构或格式</li><li>语义:即需要发出何种控制信息，完成何种动作以及做出何种响应</li><li>时序(同步): 即事件实现顺序的详细说明</li></ul><h4 id="3-1-AMQP协议"><a href="#3-1-AMQP协议" class="headerlink" title="3.1 AMQP协议"></a>3.1 AMQP协议</h4><p> <strong>AMQP</strong>(Advanced Message Queuing Protocol)是高级消息队列协议 04 年 JPMorgan Chase(摩根大通集团)联合其他公司共同设计</p><p><strong>特性：</strong> 事务支持、持久化支持，出生金融行业，在可靠性消息处理上具备天然的优势</p><p><strong>应用</strong>：<strong>RabbitMQ</strong>、<strong>ActiveMQ</strong>、OpenAMQ、Apache Qpid、Redhat Enterprise MRG、AMQP Infrastructure、ØMQ、Zyre</p><h4 id="3-2-MQTT协议"><a href="#3-2-MQTT协议" class="headerlink" title="3.2 MQTT协议"></a>3.2 MQTT协议</h4><p><strong>MQTT</strong>(Message Queuing Telemetry Transport)消息队列遥测传输是 IBM 开发的一个即时通讯协议， 物联网系统架构中的重要组成部分</p><p><strong>特性：</strong>轻量、结构简单、传输快、没有事务支持、没有持久化相关设计。</p><p><strong>应用</strong>：<strong>RabbitMQ、ActiveMQ</strong></p><h4 id="3-3-Open-Message-协议"><a href="#3-3-Open-Message-协议" class="headerlink" title="3.3 Open Message 协议"></a>3.3 Open Message 协议</h4><p>Open Messaging 是近一两年由阿里发起，与雅虎、滴滴出行、Streamlio 等公司共同参与创立的分布 式消息中间件、流处理领域的应用开发标准，是国内首个在全球范围内发起的分布式消息领域国际标准 </p><p><strong>特性：</strong>结构简单、解析快、有事务设计、有持久化设计</p><p><strong>应用</strong>：<strong>RocketMQ</strong></p><h4 id="3-4-Kafka协议"><a href="#3-4-Kafka协议" class="headerlink" title="3.4 Kafka协议"></a>3.4 Kafka协议</h4><p>Kafka协议是基于TCP 的二进制协议。消息内部是通过长度来分隔，由一些基本数据类型组成。 <strong>特性：</strong>结构简单、解析快、无事务设计、有持久化设计<br><strong>应用</strong>：<strong>Kafka</strong></p><h3 id="4-持久化"><a href="#4-持久化" class="headerlink" title="4.持久化"></a>4.持久化</h3><p>即将数据存入磁盘，永久保存的过程</p><p>ActivityMQ、RabbitMQ、Kafka、RocketMQ均支持持久化</p><h3 id="5-消息分发策略"><a href="#5-消息分发策略" class="headerlink" title="5.消息分发策略"></a>5.消息分发策略</h3><table><thead><tr><th align="center"></th><th align="center">ActivityMQ</th><th align="center">RabbitMQ</th><th align="center">Kafka</th><th align="center">RocketMQ</th></tr></thead><tbody><tr><td align="center">发布订阅</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">轮询分发</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td><td align="center">&#x2F;</td></tr><tr><td align="center">公平分发</td><td align="center">&#x2F;</td><td align="center">支持</td><td align="center">支持</td><td align="center">&#x2F;</td></tr><tr><td align="center">重发</td><td align="center">支持</td><td align="center">支持</td><td align="center">&#x2F;</td><td align="center">支持</td></tr><tr><td align="center">消息拉取</td><td align="center">&#x2F;</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr></tbody></table><h2 id="二、RabbitMQ基础"><a href="#二、RabbitMQ基础" class="headerlink" title="二、RabbitMQ基础"></a>二、RabbitMQ基础</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>RabbitMQ是一个开源的、高性能、跨平台的消息队列系统，它实现了高可用性、可扩展性和可插拔性。RabbitMQ最初是由LShift公司开发的AMQP（高级消息队列协议）的实现，现已成为了开源社区的一个重要项目</p><p>RabbitMQ的核心思想是生产者将消息发送到队列中，消费者从队列中获取消息并进行处理。RabbitMQ支持多种协议，如AMQP、STOMP、MQTT等，可以通过不同的协议来连接不同的客户端和服务端</p><blockquote><p>需要注意的是，RabbitMQ采用erlang语言开发，限制了它的开放性—因为看不懂</p></blockquote><h3 id="2-架构原理"><a href="#2-架构原理" class="headerlink" title="2.架构原理"></a>2.架构原理</h3><p>话不多说，上图</p><img src="https://static-2w2.pages.dev/post/mq-rabbitmq.png" alt="image-20230412202855830" style="zoom:30%;" /><h3 id="2-1-Broker"><a href="#2-1-Broker" class="headerlink" title="2.1 Broker"></a>2.1 Broker</h3><p>要使用 RabbitMQ 来收发消息，必须要安装一个 RabbitMQ 的服务，可以安装在 Windows 上面也可以安装在 Linux 上面，默认是 5672 的端口。这台 RabbitMQ 的服务器我们把它叫做 Broker，中文翻译是代理&#x2F;中介，因为 MQ 服务器帮助我们做的事情就是存储、转发消息</p><h4 id="2-2-Connection-连接"><a href="#2-2-Connection-连接" class="headerlink" title="2.2 Connection 连接"></a>2.2 Connection 连接</h4><p>无论是生产者发送消息，还是消费者接收消息，都必须要跟 Broker 之间建立一个 连接，这个连接是一个 TCP 的长连接</p><h4 id="2-3-Channel-通道"><a href="#2-3-Channel-通道" class="headerlink" title="2.3 Channel 通道"></a>2.3 Channel 通道</h4><p>如果所有的生产者发送消息和消费者接收消息，都直接创建和释放 TCP 长连接的话，对于 Broker 来说肯定会造成很大的性能损耗，也会浪费时间 </p><p>所以在 AMQP 里面引入了 Channel 的概念，它是一个虚拟的连接，把它翻译成通道，或者消息信道。这样我们就可以在保持的 TCP 长连接里面去创建和释放 Channel，大大了减少了资源消耗<br>不同的 Channel 是相互隔离的，每个 Channel 都有自己的编号。对于每个客户端线程来说，Channel 就没必要共享了，各自用自己的 Channel。 另外一个需要注意的是，Channel 是 RabbitMQ 原生 API 里面的最重要的编程接口，也就是说定义交换机、队列、绑定关系，发送消息，消费消息，调用的都是 Channel 接口上的方法</p><h4 id="2-4-Queue-队列"><a href="#2-4-Queue-队列" class="headerlink" title="2.4 Queue 队列"></a>2.4 Queue 队列</h4><p>连接到 Broker 以后，就可以收发消息了</p><p>在 Broker 上有一个对象用来存储消息，在 RabbitMQ 里面这个对象叫做 Queue。 实际上RabbitMQ 是用数据库来存储消息的，这个数据库跟 RabbitMQ 一样是用 Erlang 开发的，名字叫 Mnesia，可以在磁盘上找到 Mnesia 的存储路径</p><p>Windows 系统保存在用户目录下:</p><ul><li>C:\Users\用户名\AppData\Roaming\RabbitMQ\db\rabbit@用户名-mnesia</li></ul><p>CentOS 保存在&#x2F;var&#x2F;lib 目录下：</p><ul><li>&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;mnesia</li></ul><p>队列也是生产者和消费者的纽带，生产者发送的消息到达队列，在队列中存储。 消费者从队列消费消息</p><h4 id="2-5-Consumer-消费者"><a href="#2-5-Consumer-消费者" class="headerlink" title="2.5 Consumer 消费者"></a>2.5 Consumer 消费者</h4><p>消费者，顾名思义，就是消费消息的角色</p><p>消费者如何从消息队列中获取消息呢？要么被推送，要么自己拉取呗</p><ul><li>Pull模式：对应的方法是 basicGet，消费者自己获取，实时性低一点，但是能根据自己消费能力获取</li><li>Push模式：对应的方法是 basicConsume，消息队列主动推送给消费者，实时性高，但是消费不过来可能造成消息积压</li></ul><blockquote><p>RabbitMQ 中 pull 和 push 都有实现。而 kafka 和 RocketMQ 只有 pull，消费完后再手动提交偏移量，这样可以确保消息处理的顺序和可靠性</p></blockquote><h4 id="2-6-Exchange-交换机"><a href="#2-6-Exchange-交换机" class="headerlink" title="2.6 Exchange 交换机"></a>2.6 Exchange 交换机</h4><p>此处思考一个问题，如果要把一条消息发送给多个队列，被多个消费者消费，应该怎么做?</p><p>此时，生产者要调用多次 basicPublish 的方法，依次发送给多个队列</p><p>这样的话，像消息推送的这种场景，有成千上万个队列的时候，对生产者来说压力太大了</p><p>这个问题，每个消息队列都会面对，那么RabbitMQ是如何解决的呢？</p><p>在RabbitMQ中，使用了一个叫做Exchange的组件解决这个问题</p><p>也就是生产者只需要将消息发送给Exchange即可，具体分发到哪个Queue，由Exchange来完成</p><p>那么Exchange是如何和Queue绑定关系的呢？</p><p>事实上，Exchange和Queue的关系由Exchange的类型来决定，下面会详解</p><h4 id="2-7-Vhost-虚拟机"><a href="#2-7-Vhost-虚拟机" class="headerlink" title="2.7 Vhost 虚拟机"></a>2.7 Vhost 虚拟机</h4><p>为何会出现虚拟机呢？</p><p>设想，如果某个业务系统想要有自己独立的Broker，那么要如何实现呢？总不能再配置一台机制吧？</p><p>因此，RabbitMQ使用了虚拟主机Vhost来解决这个问题</p><p>VHOST 除了可以提高硬件资源的利用率之外，还可以实现资源的隔离和权限的控制。它的作用类似于其他编程语言中的 namespace 和 package，不同的 VHOST 中可以有同名的 Exchange 和 Queue，它们是完全透明的</p><h3 id="3-消息分发机制"><a href="#3-消息分发机制" class="headerlink" title="3.消息分发机制"></a>3.消息分发机制</h3><p>RabbitMQ中有四种类型的交换机，分别是Direct、Topic、Fanout和Headers，其中，Headers不常用</p><p>这些交换机就指定了消息如何传递给Queue</p><h4 id="3-1-Direct-直连"><a href="#3-1-Direct-直连" class="headerlink" title="3.1 Direct 直连"></a>3.1 Direct 直连</h4><p>一个队列与直连类型的交换机绑定，需指定一个明确的绑定键(binding key)</p><p>生产者发送消息时会携带一个路由键(routing key)</p><p>当消息的路由键与某个队列的绑定键完全匹配时，这条消息才会从交换机路由到这个队列上</p><p>多个队列也可以使用相同的绑定键，如下</p><img src="https://static-2w2.pages.dev/post/mq-direct.png" alt="image-20230412210911102" style="zoom:30%;" /><p>此时，如果使用如下语句进行发送，则只有第一个队列能收到消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(“MY_DIRECT_EXCHANGE”,”spring”,”msg <span class="number">1</span>”);</span><br></pre></td></tr></table></figure><p>适用场景：业务用途明确的消息，比如 HR 系统跟销售系统之间通信，传输的是销售系统专用的消息，就可以建一个直连类型的交换机，使用明确的绑定键</p><h4 id="3-2-Topic-主题"><a href="#3-2-Topic-主题" class="headerlink" title="3.2 Topic 主题"></a>3.2 Topic 主题</h4><p>直连模式只能一对一，那如果想要一对多的情况下如何实现呢？</p><p>此时就可以用Topic模式，它在绑定键中使用通配符进行匹配，支持两个通配符</p><ul><li>“#” 代表匹配0个或者多个单词</li><li>“*” 代表匹配一个单词</li></ul><blockquote><p>单词（word）指使用点隔开的字符，如a.bc.def是三个单词</p></blockquote><p>具体举例如下</p><img src="https://static-2w2.pages.dev/post/mq-topic.png" alt="image-20230412211831436" style="zoom:30%;" /><p>如上，如果使用以下语句，则能发送到第2和第3个队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;MY_TOPIC_EXCHANGE&quot;</span>,<span class="string">&quot;senior.netty&quot;</span>, <span class="string">&quot;msg 3&quot;</span>);</span><br></pre></td></tr></table></figure><p>适用场景：适用一些根据业务主题或者消息等级过滤消息的场景，比如说一条消息可能既跟资金有关，又跟风控有关，那就可以让这个消息指定一个多级的路由键</p><h4 id="3-3-FanOut-广播"><a href="#3-3-FanOut-广播" class="headerlink" title="3.3 FanOut 广播"></a>3.3 FanOut 广播</h4><p>广播也是一对多，但是不用指定绑定键，因为它直接发给了所有队列</p><img src="https://static-2w2.pages.dev/post/mq-fanout.png" alt="image-20230412212944241" style="zoom:30%;" /><p>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;MY_FANOUT_EXCHANGE&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;msg 4&quot;</span>);</span><br></pre></td></tr></table></figure><p>会发给所有队列</p><p>适用场景：适合通用的业务消息</p><h3 id="4-持久化与内存管理"><a href="#4-持久化与内存管理" class="headerlink" title="4.持久化与内存管理"></a>4.持久化与内存管理</h3><h4 id="4-1-持久化机制"><a href="#4-1-持久化机制" class="headerlink" title="4.1 持久化机制"></a>4.1 持久化机制</h4><p>持久化就是将数据从内存写入磁盘，这样当系统重启后数据也能够重新读取</p><p>消息的持久化与非持久化可以通过属性设置</p><p>​为了将消息设置为持久化的，需要在生产者发送消息的时候设置消息的 deliveryMode 属性为2，这样消息就会被标记为持久化消息，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;queue-name&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br></pre></td></tr></table></figure><blockquote><p>MessageProperties.PERSISTENT_TEXT_PLAIN即为2</p></blockquote><p>如果消息不需要被持久化，可以将 deliveryMode 属性设置为 1，或者在发送消息时不设置 deliveryMode 属性，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;queue-name&quot;</span>, <span class="literal">null</span>, message.getBytes());</span><br></pre></td></tr></table></figure><p>标记为持久化消息和非持久化消息有何区别呢？</p><ul><li><p>持久化消息：当 RabbitMQ 收到消息时，会将消息储存在内存中，同时也会写入磁盘</p></li><li><p>非持久化消息：只会存在内存中</p><ul><li>当内存使用达到 RabbitMQ 的临界值时，内存中的数据会被交换到磁盘，持久化消息由于本就存在于磁盘中，不会被重复写入</li></ul></li></ul><p>由此可见，并不是说非持久化消息就不会进入磁盘，它可以进入磁盘，只是重启后还是会消失</p><p>从上面的例子可知，消息的持久化是在发消息时，通过 deliveryMode属性设置</p><p>此外，交换器也可以通过参数持久化，而非持久化的消息、队列、交换器在服务重启后会消失，即使已经被写 入磁盘</p><h4 id="4-2-内存控制"><a href="#4-2-内存控制" class="headerlink" title="4.2 内存控制"></a>4.2 内存控制</h4><p>RabbitMQ 中通过内存阈值参数控制内存的使用量，当内存使用超过配置的阈值时，RabbitMQ 会阻塞客户端的连接并停止接收从客户端发来的消息，以免服务崩溃， 同时，会发出内存告警，此时客户端于与服务端的心跳检测也会失效</p><p>当出现内存告警时，可以通过管理命令临时调整</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_vm_memory_high_watermark &lt;fraction&gt;</span><br></pre></td></tr></table></figure><p>fraction 为内存阈值，默认是 0.4，表示 RabbitMQ 使用的内存超过系统内存的 40%时，会产生内存告警，通过此命令修改的阈值在重启后会失效</p><p>可以通过修改配置文件的方式，使之永久生效，但是需要重启服务</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbit.conf</span></span><br><span class="line"><span class="attr">vm_memory_high_watermark.relative</span>=<span class="string">0.4</span></span><br><span class="line"><span class="comment">#vm_memory_high_watermark.absolute=1GB</span></span><br></pre></td></tr></table></figure><p>提供 relative 与 absolute 两种配置方式 </p><ul><li>relative：相对值，也就是前面的fraction参数，建议0.4~0.66，不能太大 </li><li>absolute：绝对值，固定大小，单位为 KB、MB、GB</li></ul><h4 id="4-3-内存换页"><a href="#4-3-内存换页" class="headerlink" title="4.3 内存换页"></a>4.3 内存换页</h4><p>在 RabbitMQ 达到内存阈值并阻塞生产者之前，会尝试将内存中的消息换页到磁 盘，以释放内存空间。内存换页由换页参数控制，默认为 0.5，表示当内存使用量达到 内存阈值的 50%时会进行换页，也就是 0.4*0.5&#x3D;0.2</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vm_memory_high_watermark_paging_ratio</span>=<span class="string">0.5</span></span><br></pre></td></tr></table></figure><p>当阈值大于1时，相当于禁用了换页功能</p><h4 id="4-4-磁盘控制"><a href="#4-4-磁盘控制" class="headerlink" title="4.4 磁盘控制"></a>4.4 磁盘控制</h4><p>RabbitMQ 通过磁盘阈值参数控制磁盘的使用量，当磁盘剩余空间小于磁盘阈值 时，RabbitMQ 同样会阻塞生产者，避免磁盘空间耗尽</p><p>磁盘阈值默认 50M，由于是定时检测磁盘空间，不能完全消除因磁盘耗尽而导致崩溃的可能性，比如在两次检测之间，磁盘空间从大于 50M 变为 0M</p><p>一种相对谨慎的做法是将磁盘阈值大小设置与内存相等</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rabbitmqctl</span> <span class="string">set_disk_free_limit &lt;limit&gt;</span></span><br><span class="line"><span class="comment"># limit 为绝对值，KB、MB、GB</span></span><br><span class="line"><span class="attr">rabbitmqctl</span> <span class="string">set_disk_free_limit mem_relative &lt;fraction&gt; </span></span><br><span class="line"><span class="comment"># fraction 为相对值，建议 1.0~2.0 之间</span></span><br><span class="line"><span class="comment"># rabbitmq.conf</span></span><br><span class="line"><span class="attr">disk_free_limit.relative</span>=<span class="string">1.5</span></span><br><span class="line"><span class="comment"># disk_free_limit.absolute=50MB</span></span><br></pre></td></tr></table></figure><h3 id="5-插件管理"><a href="#5-插件管理" class="headerlink" title="5.插件管理"></a>5.插件管理</h3><p>RabbitMQ 的插件是一种用于扩展和定制 RabbitMQ 功能的方式。它们可以添加额外的功能、协议支持、认证后端、集成、监视和工具等</p><h4 id="5-1-插件列表管理"><a href="#5-1-插件列表管理" class="headerlink" title="5.1 插件列表管理"></a>5.1 插件列表管理</h4><p><code>rabbitmq-plugins list</code></p><p>此命令，列出当前可以安装使用的插件。插件前面[ ] 为空说明，没有安装。有 e* 说明插件是安装了的</p><h4 id="5-2-插件安装"><a href="#5-2-插件安装" class="headerlink" title="5.2 插件安装"></a>5.2 插件安装</h4><p>以 rabbitmq_management为例</p><p><code>rabbitmq-plugins enable rabbitmq_management</code><br> 此命令，就是安装启用管理</p><h4 id="5-3-插件卸载"><a href="#5-3-插件卸载" class="headerlink" title="5.3 插件卸载"></a>5.3 插件卸载</h4><p>将上面的enable改为disable即可</p><p><code>rabbitmq-plugins disable rabbitmq_management</code></p><h2 id="三、死信与限流"><a href="#三、死信与限流" class="headerlink" title="三、死信与限流"></a>三、死信与限流</h2><h3 id="1-订单延时关闭问题"><a href="#1-订单延时关闭问题" class="headerlink" title="1.订单延时关闭问题"></a>1.订单延时关闭问题</h3><p>先来一个经典的面试问题，假如设计一个功能，超过30min未支付的订单要取消，自动关闭，如何实现呢？</p><p>不采用MQ的话，有以下方案：</p><ul><li>定时器：创建订单时就创建一个定时器，到30min就查看订单是否被支付</li><li>轮询：有一个线程定时执行检查订单创建时间和支付状态</li></ul><p>事实上，上面两种方法都有缺点，那么采用MQ的话，如何实现呢？会有何进步？</p><p>在这种情况下，可以使用RabbitMQ的死信队列（Dead Letter Queue）来实现功能</p><p>主要借助RabbitMQ的消息存活时间属性</p><h3 id="2-消息存活时间-TTL（Time-To-Live）"><a href="#2-消息存活时间-TTL（Time-To-Live）" class="headerlink" title="2.消息存活时间 TTL（Time To Live）"></a>2.消息存活时间 TTL（Time To Live）</h3><p>下面分别是通过队列和消息设置过期时间</p><h4 id="2-1-Queue属性设置"><a href="#2-1-Queue属性设置" class="headerlink" title="2.1 Queue属性设置"></a>2.1 Queue属性设置</h4><p>在队列中，可以设置一个消息过期属性<code>x-message-ttl</code>，一旦消息超过了这个时间还未被消费，则会被丢弃</p><blockquote><p>该属性可以针对队列设置，也可以对某消息进行设置</p></blockquote><h4 id="2-2-Message-属性设置"><a href="#2-2-Message-属性设置" class="headerlink" title="2.2 Message 属性设置"></a>2.2 Message 属性设置</h4><p>消息的属性可以在发送时，使用MessageProperties来执行，使用方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>(); messageProperties.setExpiration(<span class="string">&quot;4000&quot;</span>); <span class="comment">// 消息的过期属性，单位 ms</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;这条消息 4 秒后过期&quot;</span>.getBytes(), messageProperties);</span><br><span class="line">rabbitTemplate.send(<span class="string">&quot;GP_TTL_EXCHANGE&quot;</span>, <span class="string">&quot;gupao.ttl&quot;</span>, message);</span><br></pre></td></tr></table></figure><p>假如队列和消息都设置了过期时间，那肯定是时间小的那个生效</p><p>上面为了简便，说设置了过期时间的消息会被丢弃，事实上过期的消息也不能被直接丢弃，因为丢弃了就无法找回了，也就不可能再被消费了，RabbitMQ是将消息丢到一个容器里面，这个容器就是<strong>死信队列</strong></p><h3 id="3-死信"><a href="#3-死信" class="headerlink" title="3.死信"></a>3.死信</h3><p>如果不进行配置，消息过期后是真的会被丢弃的</p><p>可以通过配置，让过期的消息变成死信，从而进入死信队列进行存储</p><h4 id="3-1-死信交换机-DLX-x2F-死信队列-DLQ"><a href="#3-1-死信交换机-DLX-x2F-死信队列-DLQ" class="headerlink" title="3.1 死信交换机 DLX &#x2F; 死信队列 DLQ"></a>3.1 死信交换机 DLX &#x2F; 死信队列 DLQ</h4><p>为什么将这两个东西放到一起说呢？</p><p>因为前面介绍过，除了广播模式，消息是通过交换机Exchange来定位队列的，将所有队列都设置成死信队列也不太可能也没有意义，所以需要设置死信交换机，从而指定存储死信的队列，也就是死信队列</p><blockquote><p>注意，死信队列和死信交换机也都是普通的队列和交换机，只是承担的职责不同罢了</p></blockquote><p>队列在创建的时候可以指定一个死信交换机 DLX(Dead Letter Exchange)。死信交换机绑定的队列被称为死信队列 DLQ(Dead Letter Queue)</p><p>那么消息过期后，就会先找指定的DLX，再通过DLX去找DLQ，消费者可以去消费这个DLQ</p><h4 id="3-2-死信队列实现方案"><a href="#3-2-死信队列实现方案" class="headerlink" title="3.2 死信队列实现方案"></a>3.2 死信队列实现方案</h4><p>下面使用一个例子来用死信队列实现订单延时关闭功能，步骤如下</p><ul><li>声明原交换机，原队列，进行绑定</li><li>再指定原队列的死信交换机—过期时发送</li><li>声明死信交换机，死信队列，使用“#”进行绑定，代表无条件路由</li><li>消费者监听死信队列，检查订单逻辑</li><li>生产者发送消息测试，10s过期</li></ul><p>上述步骤，用代码实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.指定队列的死信交换机</span></span><br><span class="line">Map&lt;String,Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;(); arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,<span class="string">&quot;DEAD_LETTER_EXCHANGE&quot;</span>);</span><br><span class="line"><span class="comment">// arguments.put(&quot;x-expires&quot;,&quot;9000&quot;); // 设置队列的 TTL</span></span><br><span class="line"><span class="comment">// arguments.put(&quot;x-max-length&quot;, 4); // 如果设置了队列的最大长度，超过长度时，先入队 的消息会被发送到 DLX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.声明队列(默认交换机 AMQP default，Direct)</span></span><br><span class="line"><span class="comment">// String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;ORI_USE_QUEUE&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, arguments);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.声明死信交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;DEAD_LETTER_EXCHANGE&quot;</span>,<span class="string">&quot;topic&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 4.声明死信队列</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;DEAD_LETTER_QUEUE&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 5.绑定，此处 Dead letter routing key 设置为 #</span></span><br><span class="line">channel.queueBind(<span class="string">&quot;DEAD_LETTER_QUEUE&quot;</span>,<span class="string">&quot;DEAD_LETTER_EXCHANGE&quot;</span>,<span class="string">&quot;#&quot;</span>); System.out.println(<span class="string">&quot; Waiting for message....&quot;</span>);</span><br></pre></td></tr></table></figure><p>具体流转如下图</p><img src="https://static-2w2.pages.dev/post/mq-dead-letter.png" alt="image-20230412235804612" style="zoom:30%;" /><p>即生产者—&gt;原交换机—&gt;原队列—&gt;超时—&gt;死信交换机—&gt;死信队列—&gt;消费者</p><h4 id="3-3-其他方案"><a href="#3-3-其他方案" class="headerlink" title="3.3 其他方案"></a>3.3 其他方案</h4><p>使用死信队列实现延时消息的缺点:<br>1）如果统一用队列来设置消息的 TTL，当梯度非常多的情况下，比如 1 分钟，2 分钟，5 分钟，10 分钟，20 分钟，30 分钟……需要创建很多交换机和队列来路由消息。</p><p>2）如果单独设置消息的 TTL，则可能会造成队列中的消息阻塞——前一条消息没有出队(没有被消费)，后面的消息无法投递(比如第一条消息过期 TTL 是 30min， 第二条消息 TTL 是10min。10 分钟后，即使第二条消息应该投递了，但是由于第一条消息还未出队，所以无法投递)。<br>3）可能存在一定的时间误差</p><p>因此，在RabbitMQ 3.5.7之后提供插件<code>rabbitmq-delayed-message-exchange</code>实现延时队列的功能，使用方法不再赘述</p><h4 id="3-4-思考"><a href="#3-4-思考" class="headerlink" title="3.4 思考"></a>3.4 思考</h4><p>除了消息过期，还有什么情况消息会变成死信? </p><p>1）消息被消费者拒绝并且未设置重回队列:(<strong>NACK</strong> || Reject ) &amp;&amp; requeue &#x3D;&#x3D; false</p><p>2）队列达到最大长度，超过了 Max length(消息数)或者 Max length bytes(字节数)，最先入队的消息会被发送到 DLX</p><blockquote><p>解释：ACK:acknowledge 消息确认,NACK:Un acknowledge 没有消息确认 </p></blockquote><p>已知，RabbitMQ 的消息是存在磁盘上的，如果是内存节点，会同时存在磁盘和内存中。当 RabbitMQ 生产 MQ 消息的速度远大于消费消息的速度时，会产生大量的消息堆积，占用系统资源，导致机器的性能下降</p><p>那么想要控制服务端接收的消息的数量，应该怎么做呢?</p><p>从RabbitMQ的结构来看，流量控制可以从两个方面来控制</p><p>一个是服务端，一个是消费端</p><h3 id="4-服务端流控"><a href="#4-服务端流控" class="headerlink" title="4.服务端流控"></a>4.服务端流控</h3><p>首先明确下问题，即为什么要进行流控？</p><p>因为消息积压，不加限制可能会内存&#x2F;磁盘爆炸</p><p>所以要限制消息的无限存储，那么如何限制呢？最简单的就是淘汰</p><h4 id="4-1-队列长度"><a href="#4-1-队列长度" class="headerlink" title="4.1 队列长度"></a>4.1 队列长度</h4><p>消息队列有两个属性可以控制长度，一个是控制数量，一个是控制内存</p><ul><li>x-max-length：队列中最大存储最大消息数，超过这个数量，队头的消息会被丢弃</li><li>x-max-length-bytes：队列中存储的最大消息容量(单位 bytes)，超过这个 容量，队头的消息会被丢弃</li></ul><p>消息长度只在消息堆积的情况下有意义，而且这种方式是简单粗暴的删除了先入队的消息，并不是真正的实现了服务端限流</p><h4 id="4-2-内存控制-1"><a href="#4-2-内存控制-1" class="headerlink" title="4.2 内存控制"></a>4.2 内存控制</h4><p>前面说过，RabbitMQ有一个内存告警机制，可以设置一个阈值，达到阈值就会抛出警告并且阻塞所有连接—正好可以用来限流</p><p>所以可以通过内存阈值来进行消息流量的控制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_vm_memory_high_watermark 0.6</span><br></pre></td></tr></table></figure><p>设置成0的话，所有消息都不能发布</p><h4 id="4-3-磁盘控制"><a href="#4-3-磁盘控制" class="headerlink" title="4.3 磁盘控制"></a>4.3 磁盘控制</h4><p>既然内存可以存储消息，通过内存可以进行流量控制，那么同样存储消息的磁盘，当然可以通过磁盘容量来进行相似的控制了</p><p>可以设置当磁盘容量低于指定值时触发流控措施，同样有比例和固定值两种方式</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">disk_free_limit.relative</span> = <span class="string">3.0 # 30%</span></span><br><span class="line"><span class="attr">disk_free_limit.absolute</span> = <span class="string">2GB</span></span><br></pre></td></tr></table></figure><p>此外，如果Broker还可以存，但是消费者消费不过来了，积压太多，也要限流</p><h3 id="5-消费端限流"><a href="#5-消费端限流" class="headerlink" title="5.消费端限流"></a>5.消费端限流</h3><p>默认情况下，如果不进行配置，RabbitMQ 会尽可能快速地把队列中的消息发送到消费者</p><p>但是因为消费者会在本地缓存消息，如果消息数量过多，可能会导致 OOM 或 者影响其他进程的正常运行</p><p>在消费者处理消息的能力有限，例如消费者数量太少，或者单条消息的处理时间 过长的情况下，如果我们希望在一定数量的消息消费完之前，不再推送消息过来，就要用到消费端的流量限制措施</p><p>可以基于 Consumer 或者 channel 设置 prefetch count 的值，含义为 Consumer 端的最大的 <strong>unacked messages</strong> 数目（即未确认）。当超过这个数值的消息未被确认，RabbitMQ 会停止投递新的消息给该消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">2</span>); <span class="comment">// 如果超过 2 条消息没有发送 ACK，当前消费者不再接受队列消息 </span></span><br><span class="line">channel.basicConsume(QUEUE_NAME, <span class="literal">false</span>, consumer);</span><br></pre></td></tr></table></figure><h2 id="四、高可用集群"><a href="#四、高可用集群" class="headerlink" title="四、高可用集群"></a>四、高可用集群</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>为啥要用集群呢？因为高可用啊，集群主要用于实现高可用与负载均衡</p><p>高可用：如果集群中的某些 MQ 服务器不可用，客户端还可以连接到其他 MQ 服务器。不至于影响业务<br>负载均衡：在高并发的场景下，单台 MQ 服务器能处理的消息有限，可以分发给多台 MQ 服务器。减少消息延迟</p><h3 id="2-RabbitMQ集群"><a href="#2-RabbitMQ集群" class="headerlink" title="2.RabbitMQ集群"></a>2.RabbitMQ集群</h3><p>RabbitMQ采用Erlang语言编写，而该语言天生具备分布式的特性，因此RabbitMQ也是天然支持集群的，并不需要通过ZK来实现数据同步</p><p>那么它是如何保持通信并且验证身份的呢？</p><p>首先，肯定是要为每个节点配置需要建立联系的其他节点</p><p>建立联系时需要身份验证，在这里采用erlang.cookie文件进行身份验证，每个节点上该文件保持一致</p><p>服务的端口是 5672，UI 的端口是 15672，集群的端口是 25672</p><p> 集群通过 25672 端口两两通信，需要开放防火墙的端口。 需要注意的是，RabbitMQ 集群无法搭建在广域网上，除非使用 federation 或者shovel 等插件(没这个必要，在同一个机房做集群)</p><h3 id="3-RabbitMQ节点类型"><a href="#3-RabbitMQ节点类型" class="headerlink" title="3.RabbitMQ节点类型"></a>3.RabbitMQ节点类型</h3><p>集群有两种节点类型，一种是磁盘节点(Disc Node)，一种是内存节点(RAM Node)</p><p>磁盘节点(disc)：将元数据(包括队列名字属性、交换机的类型名字属性、绑定、vhost)放在磁盘中</p><blockquote><p>未指定类型的情况下，默认为磁盘节点</p></blockquote><p>服务重启之后，存在磁盘节点中的数据还是会存在，所以像我们的持久化消息、持久 化队列等，都会放置硬盘节点保存</p><p>内存节点(ram)：就是将元数据都放在内存里，内存节点的话，只要服务重启，该节点的所有数据将会丢失</p><p>以在 RabbitMQ 集群里，至少有一个磁盘节点，它用来持久保存我们的元数据，如果RabbitMQ 是单节点运行，则默认就是磁盘节点。但是为了提高性能，其实不需要所有节点都是 disc 的节点，根据需求分配即可</p><blockquote><p><strong>元数据</strong></p><ul><li>队列元数据：包括队列的名称、持久性、最大长度、消息数目等信息。在RabbitMQ中，队列是消息传递的中心，因此队列元数据是非常重要的。</li><li>交换机元数据：包括交换机的名称、类型、持久性、绑定的队列、路由键等信息。交换机用于消息的路由和分发，因此交换机元数据对于消息传递非常重要。</li><li>绑定元数据：包括绑定的队列、交换机、路由键等信息。绑定将队列和交换机连接起来，用于消息的路由和分发。</li><li>连接元数据：包括连接的IP地址、端口号、协议、连接数、用户等信息。连接是RabbitMQ客户端与服务端之间的通信通道。</li><li>用户元数据：包括用户的名称、密码、权限等信息。RabbitMQ使用用户认证来控制对队列、交换机和其他资源的访问权限。</li></ul><p>总之，RabbitMQ的元数据提供了关于队列、交换机、绑定、连接和用户的重要信息，帮助用户管理和控制消息传递</p></blockquote><p> 如果 RabbitMQ 集群只有一个磁盘节点，然后磁盘节点挂了，会发生什么? </p><p>可以正常的投递消息和消费消息，但是不能做以下事:</p><ul><li>不能创建队列</li><li>不能创建交换机</li><li>不能创建用户绑定关系</li><li>不能修改用户权限</li></ul><blockquote><p>为什么不能做这些事情呢？</p><p>因为这些事情的实现都需要把相关信息放到元数据里，元数据需要在磁盘上持久化的</p></blockquote><p>所以，考虑到高可用性，推荐在集群里保持 2 个磁盘节点，这样一个挂了，另一个还可正常工作。但上述最后一点，往集群里增加或删除节点，要求 2 个磁盘节点同时在线</p><p>那么集群如何配置呢？</p><ul><li>配置 hosts 以便相互通信</li><li>同步 erlang.cookie</li><li>加入集群(join cluster 命令)</li></ul><p>RabbitMQ 有两种集群模式：<strong>普通集群模式</strong>和<strong>镜像队列模式</strong></p><h3 id="4-普通集群"><a href="#4-普通集群" class="headerlink" title="4.普通集群"></a>4.普通集群</h3><p>普通集群模式下，不同的节点之间只会相互同步元数据(交换机、队列、绑定关系、Vhost 的定义)，而不会同步消息</p><p>如下图</p><img src="https://static-2w2.pages.dev/post/mq-common.png" alt="image-20230413092205747" style="zoom:40%;" /><p>那么这种模式有什么作用呢？</p><p>这样无论生产者连接的是哪个节点，都能够找到需要存储的位置，比如上面连接的是C，需要将消息存到A上，那么它就能通过C找到A并把消息存到A的消息队列</p><p>好处是生产者连到哪个节点都能发送成功，缺点呢？</p><p>缺点也很明显，A挂了之后就不能存到A了，消息直接没地方存，A的消息也可能丢失</p><p>当初之所以这样设计，主要是出于存储和同步数据的网络开销的考虑，如果所有节点都存储相同的数据， 就无法达到线性地增加性能和存储容量的目的(堆机器)</p><p>但是这种方式明显无法达到高可用的作用，因此就出现了<strong>镜像集群</strong></p><h3 id="5-镜像集群"><a href="#5-镜像集群" class="headerlink" title="5.镜像集群"></a>5.镜像集群</h3><p>镜像集群是什么结构呢？看下图</p><img src="https://static-2w2.pages.dev/post/mq-mirror.png" alt="image-20230413093314789" style="zoom:40%;" /><p>观察图，会发现在普通模式基础上，镜像模式还同步了消息内容到其他节点</p><p>镜像队列模式下，消息内容会在镜像节点间同步，可用性更高。不过也有一定的副作用，系统性能会降低，节点过多的情况下同步的代价比较大</p><p>总结下就是，普通集群为了节省网络和内存等的消耗，只同步了元数据信息</p><p>而镜像集群为了高可用，将消息也同步过去了，这样一台机器挂了其他机器还能接手</p><h3 id="6-高可用实现原理"><a href="#6-高可用实现原理" class="headerlink" title="6.高可用实现原理"></a>6.高可用实现原理</h3><p>首先是连接问题，集群模式下，会存在很多机器节点，那客户端要连接到哪个呢？如果都连接到同一台机器，对这台机器的负担无疑是很大的</p><p>此时就要用到负载均衡组件（例如 HAProxy，LVS，Nignx）了，由负载均衡组件做路由</p><p>而客户端只需要连接到负载均衡组件的IP即可</p><img src="https://static-2w2.pages.dev/post/mq-rabbitmq-lvs.png" alt="image-20230413094133873" style="zoom:40%;" /><p>而负载均衡根据组件不同，实现的原理也不尽相同，主要分为四层负载和七层负载</p><p> <strong>四层负载</strong>：工作在 OSI 模型的第四层，即传输层（TCP 位于第四层），它是<strong>根据 IP 端口</strong>进行转发(LVS 支持四层负载)。RabbitMQ 是 TCP 的 5672 端口</p><p><strong>七层负载</strong>：工作在 OSI 模型的第七层，即应用层（HTTP 位于第七层），可以根据<strong>请求资源类型</strong>分配到后端服务器（Nginx 支持七层负载；HAProxy 支持四层和七层负载）</p><p>但是就像引入MQ使得系统更复杂，会考虑MQ挂掉怎么办，如果负载均衡的组件挂了怎么办？</p><p>此时需要一个具有以下功能的组件</p><ul><li>它本身有路由(负载)功能，可以监控集群中节点的状态(比如监控 HAProxy)， 如果某个节点出现异常或者发生故障，就把它剔除掉</li><li>为了提高可用性，它也可以部署多个服务，但是只有一个自动选举出来的 MASTER 服务器(叫做主路由器)，通过广播心跳消息实现</li><li>MASTER 服务器对外提供一个虚拟 IP，提供各种网络功能。也就是谁抢占到 VIP， 就由谁对外提供网络服务。应用端只需要连接到这一个 IP 就行了</li></ul><p>事实上，确实有这么一个组件，它基于 VRRP 协议(虚拟路由冗余协议 Virtual Router Redundancy Protocol)</p><p>这个组件就是 Keepalived，它具有 Load Balance 和 High Availability 的功能</p><blockquote><p>不止RabbitMQ，事实上，MySQL、MyCat、Redis集群实现方式这部分都类似</p></blockquote><h3 id="7-基于-HAproxy-Keepalived-搭建高可用"><a href="#7-基于-HAproxy-Keepalived-搭建高可用" class="headerlink" title="7.基于 HAproxy+Keepalived 搭建高可用"></a>7.基于 HAproxy+Keepalived 搭建高可用</h3><blockquote><p>在介绍案例之前，先看下 HAproxy+Keepalived是如何配合使用的</p><p>HAproxy 是一种负载均衡器，可以将客户端请求<strong>均衡地</strong>分配到不同的 RabbitMQ 节点上，从而实现负载均衡</p><p>而 Keepalived 则可以将多台服务器虚拟成一个虚拟 IP 地址（VIP），并通过心跳检测来实现服务器之间的故障转移。当某个 RabbitMQ 节点宕机或出现故障时，Keepalived 会自动将 VIP 切换到另一个可用的 RabbitMQ 节点上，从而确保 RabbitMQ 集群的高可用性和可靠性</p><p>在这种情况下，应用程序需要连接到虚拟 IP 地址（VIP），而不是直接连接到 RabbitMQ 节点。当 VIP 切换到另一个 RabbitMQ 节点上时，应用程序会自动重新连接到新的节点，从而保证服务的连续性和可用性</p><p>总结就是</p><p>用户——VIP</p><p>VIP——HAproxy</p><p>HAproxy——RabbitMQ节点</p><p>Keepalived则肩负着检测哪些节点可用的功能</p></blockquote><p>下面看个案例，如下是结构图</p><img src="https://static-2w2.pages.dev/post/mq-keepalived.png" alt="image-20230413094937197" style="zoom:40%;" /><p>这里声明一下，为了高可用，<strong>HAproxy不可以跟RabbitMQ服务装在同一台机器上</strong></p><p>先看看ip规划:</p><ul><li>内存节点 1：192.168.8.144</li><li>内存节点 2：192.168.8.145</li><li>磁盘节点：192.168.8.146</li><li>VIP：192.168.8.149</li></ul><p>具体的，</p><ul><li>这里规划了两个内存节点，一个磁盘节点。所有的节点之间通过镜像队列的方 式同步数据。内存节点用来给应用访问，磁盘节点用来持久化数据</li><li>为了实现对两个内存节点的负载，我们安装了两个 HAProxy，监听两个 5672和 15672 的端口</li><li>安装两个 Keepalived，一主一备。两个 Keepalived 抢占一个 VIP192.168.8.149。 谁抢占到这个 VIP，应用就连接到谁，来执行对 MQ 的负载。</li></ul><p>这种情况下</p><p>Keepalived挂了一个节点，没有影响，因为 BACKUP 会变成 MASTER，抢占 VIP</p><p>HAProxy 挂了一个节点，没有影响，我们的 VIP 会自动路由可用的 HAProxy 服务</p><p>RabbitMQ 挂了一个节点，没有影响， 因为 HAProxy 会自动负载到可用的节点</p><p>最后，可以使用可视化工具监控RabbitMQ的整体情况，这里不再介绍</p><h2 id="五、可靠性"><a href="#五、可靠性" class="headerlink" title="五、可靠性"></a>五、可靠性</h2><h3 id="1-分析"><a href="#1-分析" class="headerlink" title="1.分析"></a>1.分析</h3><p>什么叫可靠性？</p><p>既然使用RabbitMQ进行消息的投递，那么就要考虑一些问题，比如消息发送丢了怎么办？重复消费了怎么办？无法消费怎么办？</p><p>还有许多可能产生的问题，这些问题大部分RabbitMQ都采用了一定的措施来避免，而这些措施，就是消息投递的可靠性机制</p><blockquote><p>需要注意的是，一些可靠性措施会导致RabbitMQ收发效率下降—安全性提高必然导致效率的下降，理所当然；因此这些措施只在需要的场合再去使用，不是说一定要用</p></blockquote><p>根据之前学过的RabbitMQ模型，很容易想到，想保证消息的可靠性，主要在四个方面下功夫</p><ul><li>生产者发送消息到Broker<ul><li>如何保证消息成功投递了呢？</li></ul></li><li>消息从Exchange路由到Queue<ul><li>如何能够正确的路由到Queue呢？路由不到怎么办？</li></ul></li><li>消息在Queue中存储<ul><li>如何保证存储可靠，不会随着宕机等问题丢失？</li></ul></li><li>消费者订阅消费Queue的消息<ul><li>如何保证消费和Queue中删除消息节奏保持一致？</li></ul></li></ul><p>下面就逐个分析这些过程中的可靠性机制</p><h3 id="2-生产者发送消息到Broker"><a href="#2-生产者发送消息到Broker" class="headerlink" title="2.生产者发送消息到Broker"></a>2.生产者发送消息到Broker</h3><p>先看下这一步骤，一些可能导致丢失消息的情况</p><ul><li>网络波动，消息发丢了</li><li>Broker故障，硬盘故障&#x2F;写满了</li></ul><p>那么如何去设计，才能保证消息可靠投递呢？</p><p>很明显，设计一个反馈机制ack，当Broker收到并写好消息之后，返回一个ack告诉生产者消息成功投递了</p><p>在Rabbit当中，设置了两种确认机制来完成这个问题</p><ul><li>Transaction（事务）模式</li><li>COnfirm（确认）模式</li></ul><h4 id="2-1-Transaction（事务）模式"><a href="#2-1-Transaction（事务）模式" class="headerlink" title="2.1 Transaction（事务）模式"></a>2.1 Transaction（事务）模式</h4><p>事务模式怎么使用呢?它在创建 channel 的时候，可以把信道设置成事务模式， 然后就可以发布消息给 RabbitMQ 了</p><p>如果 <code>channel.txCommit();</code>的方法调用成功， 就说明事务提交成功，则消息一定到达了 RabbitMQ 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  channel.txSelect();</span><br><span class="line">  <span class="comment">// 发送消息</span></span><br><span class="line"><span class="comment">// String exchange, String routingKey, BasicProperties props, byte[] body </span></span><br><span class="line">  channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, (msg).getBytes());</span><br><span class="line"><span class="comment">// int i =1/0;</span></span><br><span class="line">channel.txCommit();</span><br><span class="line">System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  channel.txRollback();</span><br><span class="line">System.out.println(<span class="string">&quot;消息已经回滚&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在事务提交执行之前由于 RabbitMQ 异常崩溃或者其他原因抛出异常，这个时候便可以将其捕获，进而通过执行 channel.txRollback()方法来实现事务回滚</p><p>在事务模式里面，只有收到了服务端的 Commit-OK 的指令，才能提交成功，所以可以解决生产者和服务端确认的问题</p><p>但是事务模式有一个缺点，<strong>它是阻塞的</strong>，一条消息没有发送完毕，不能发送下一条消息，它会榨干 RabbitMQ 服务器的性能，所以不建议在生产环境使用</p><p>那么有没有其他可以保证消息被 Broker 接收，但是又不大量消耗性能的方式呢?</p><p>这个就是第二种模式，叫做确认(Confirm)模式</p><h4 id="2-2-Confirm-确认-模式"><a href="#2-2-Confirm-确认-模式" class="headerlink" title="2.2 Confirm(确认)模式"></a>2.2 Confirm(确认)模式</h4><p>确认模式有三种</p><ul><li>普通确认模式</li><li>批量确认模式</li><li>异步确认模式</li></ul><p>首先是普通确认模式</p><p>在生产者这边通过调用 <code>channel.confirmSelect()</code>方法将信道设置为Confirm模式，然后发送消息</p><p>一旦消息被投递到交换机之后（跟是否路由到队列没有关系），RabbitMQ 就会发送一个确认（Basic.Ack）给生产者，也就是调用 <code>channel.waitForConfirms()</code>返回 true，这样生产者就知道消息被服务端接收了。</p><p>如果网络错误，会抛出连接异常，如果交换机不存在，会抛出 404 错误</p><blockquote><p>所以这种方法只是保证从生产者到Exchange可靠</p></blockquote><p>具体代码实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.开启发送方消息确认</span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="comment">// 2.普通 Confirm，发送一条，确认一条</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, msg.getBytes()); </span><br><span class="line"><span class="keyword">if</span> (channel.waitForConfirms()) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;消息发送成功&quot;</span> ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方式效率过低，而且实际生产中大部分场景也不太可能一条一条的发送消息，因此就要用到第二种，批量确认模式</p><p>批量确认，就是在开启 Confirm 模式后，先发送一批消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   channel.confirmSelect();</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 发送消息</span></span><br><span class="line">  <span class="comment">// String exchange, String routingKey, BasicProperties props, byte[] body </span></span><br><span class="line">     channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, (msg +<span class="string">&quot;-&quot;</span>+ i).getBytes());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 批量确认结果，ACK 如果是 Multiple=True，代表 ACK 里面的 Delivery-Tag 之前的消息都 被确认了</span></span><br><span class="line">  <span class="comment">// 比如 5 条消息可能只收到 1 个 ACK，也可能收到 2 个(抓包才看得到)</span></span><br><span class="line">  <span class="comment">// 直到所有信息都发布，只要有一个未被 Broker 确认就会 IOException </span></span><br><span class="line">  channel.waitForConfirmsOrDie(); </span><br><span class="line">  System.out.println(<span class="string">&quot;消息发送完毕，批量确认成功&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="comment">// 发生异常，可能需要对所有消息进行重发</span></span><br><span class="line">  e.printStackTrace();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>只要 <code>channel.waitForConfirmsOrDie();</code>方法没有抛出异常，就代表消息都被服务端接收了</p><blockquote><p>是不是很像并发编程中的countdownlatch？</p></blockquote><p>但是这种方法也不是很好，比如批量，多少条消息算一批合适呢？</p><p>又比如发送1000条消息，前999正常ack，最后一条挂了，这时候就都要重发，不合适吧？</p><p>因此就出现第三种确认模式，可以一边发送一遍确认，这就是异步确认模式</p><p>异步确认模式需要添加一个 ConfirmListener，并且用一个 SortedSet 来维护一 个批次中没有被确认的消息</p><blockquote><p>即添加一个监听和一个未确认集合</p><p>当生产者发送消息后，RabbitMQ 会在确认消息被接收后调用 <code>ConfirmListener</code> 的 <code>handleAck</code> 方法，如果消息发送失败，则调用 <code>handleNack</code> 方法</p><p>异步确认模式中，生产者需要维护一个 <code>unconfirmedSet</code> 集合来存储未被确认的消息。当生产者发送消息后，将消息添加到 <code>unconfirmedSet</code> 集合中。当收到确认消息时，生产者需要从 <code>unconfirmedSet</code> 集合中移除确认消息的序列号。</p><p>如果消息发送失败，生产者需要将 <code>unconfirmedSet</code> 集合中的消息重新发送。如果消息一直发送失败，生产者需要考虑重试次数和重试间隔时间等问题，以避免陷入死循环</p></blockquote><p>代码实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.用来维护未确认消息的 deliveryTag；confirmSet对应上面提到的unconfirmedSet</span></span><br><span class="line">  <span class="keyword">final</span> SortedSet&lt;Long&gt; confirmSet = Collections.synchronizedSortedSet(<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Long&gt;());</span><br><span class="line">  <span class="comment">// 这里不会打印所有响应的 ACK;ACK 可能有多个，有可能一次确认多条，也有可能一次确认一条 </span></span><br><span class="line"><span class="comment">// 1.异步监听确认和未确认的消息</span></span><br><span class="line">  <span class="comment">// 如果要重复运行，先停掉之前的生产者，清空队列</span></span><br><span class="line">  channel.addConfirmListener(<span class="keyword">new</span> <span class="title class_">ConfirmListener</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNack</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;Broker 未确认消息，标识:&quot;</span> + deliveryTag); <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">              <span class="comment">// headSet 表示后面参数之前的所有元素，全部删除 </span></span><br><span class="line">            confirmSet.headSet(deliveryTag + <span class="number">1L</span>).clear();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              confirmSet.remove(deliveryTag);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 这里添加重发的方法</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleAck</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123; <span class="comment">// 如果 true 表示批量执行了 deliveryTag 这个值以前(小于 deliveryTag 的)的所有消 息，如果为 false 的话表示单条确认</span></span><br><span class="line">          System.out.println(String.format(<span class="string">&quot;Broker 已确认消息，标识:%d，多个消息:%b&quot;</span>, deliveryTag, multiple));</span><br><span class="line">          <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">              <span class="comment">// headSet 表示后面参数之前的所有元素，全部删除 </span></span><br><span class="line">            confirmSet.headSet(deliveryTag + <span class="number">1L</span>).clear();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 只移除一个元素</span></span><br><span class="line">              confirmSet.remove(deliveryTag);</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">&quot;未确认的消息:&quot;</span>+confirmSet);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 开启发送方确认模式</span></span><br><span class="line">  channel.confirmSelect();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">nextSeqNo</span> <span class="operator">=</span> channel.getNextPublishSeqNo();</span><br><span class="line">      <span class="comment">// 发送消息</span></span><br><span class="line">      <span class="comment">// String exchange, String routingKey, BasicProperties props, byte[] body </span></span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, (msg +<span class="string">&quot;-&quot;</span>+ i).getBytes()); </span><br><span class="line">    confirmSet.add(nextSeqNo);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;所有消息:&quot;</span>+confirmSet);</span><br></pre></td></tr></table></figure><h3 id="3-消息从交换机路由到队列"><a href="#3-消息从交换机路由到队列" class="headerlink" title="3.消息从交换机路由到队列"></a>3.消息从交换机路由到队列</h3><p>交换机到队列出现异常，可能是routing key错误，也有可能是队列根本就不存在</p><p>那么如何处理呢？主要是以下前两种，最后一种不可靠</p><ul><li>拒绝消息并将其返回给生产者：当交换机无法将消息路由到队列时，将消息标记为“Return”，并将其发送回生产者。生产者可以通过在发送消息时设置 <code>mandatory=true</code> 参数来启用这个模式。</li><li>将消息发送到备用交换机（Alternate Exchange）：备用交换机是一种特殊的交换机，它会接收那些无法路由到其它交换机的消息，并将其重新发送到指定的队列中。</li><li>丢弃消息：当交换机无法将消息路由到队列时，可以直接将其丢弃。这种情况下，生产者无法得知消息是否已经被成功处理。</li></ul><h3 id="4-消息在队列中存储"><a href="#4-消息在队列中存储" class="headerlink" title="4.消息在队列中存储"></a>4.消息在队列中存储</h3><p>这一种情况主要是消息存在内存中，如果重启、宕机等步骤后，消息会丢失</p><p>此外，元数据也需要持久化，防止丢失</p><p>所以主要就是以下步骤</p><ul><li>队列持久化</li><li>交换机持久化</li><li>消息持久化</li><li>集群部署—提高高可用</li></ul><h3 id="5-消息投递到消费者"><a href="#5-消息投递到消费者" class="headerlink" title="5.消息投递到消费者"></a>5.消息投递到消费者</h3><p>如果消费者收到消息后没来得及处理即发生异常，或者处理过程中发生异常，会导致消费失败</p><p>因此，服务端应该以某种方式得知消费者对消息的接收情况，并决定是否重新投递这条消息给其他消费者</p><p>RabbitMQ 提供了消费者的消息确认机制(message acknowledgement)，消费者可以自动或者手动地发送 ACK 给服务端</p><p>如果没有 ACK 会怎么办?永远等待下去?也不会</p><p>没有收到 ACK 的消息，消费者断开连接后，RabbitMQ 会把这条消息发送给其他消费者。如果没有其他消费者，消费者重启后会重新消费这条消息，重复执行业务逻辑(如果代码修复好了还好)</p><p>那么消费者怎么给Broker应答呢？</p><p>有两种方式，一种是自动 ACK，一种是手动 ACK</p><p>首先是自动 ACK，这个也是默认的情况。也就是我们没有在消费者处编写 ACK 的代码，消费者会在收到消息的时候就自动发送 ACK，而不是在方法执行完毕的时候发送 ACK（并不关心你有没有正常消费消息）</p><p>因此正常情况下，如果想保证这一步的可靠性，需要把自动ACK改为手动ACK，当业务处理完，消息正常消费后再手动发送ACK</p><h3 id="6-消费者回调"><a href="#6-消费者回调" class="headerlink" title="6.消费者回调"></a>6.消费者回调</h3><p>考虑一个问题，生产者生产的某消息，最终被消费者消费了，那么它如何知道呢？</p><ul><li>消费者收到消息，处理完毕后，调用生产者的 API（思考:是否破坏解耦？）</li><li>消费者收到消息，处理完毕后，发送一条响应消息给生产者</li></ul><h4 id="6-1-调用生产者-API"><a href="#6-1-调用生产者-API" class="headerlink" title="6.1 调用生产者 API"></a>6.1 调用生产者 API</h4><p>例如:提单系统给其他系统发送了保险消息后（通知通知!发生了一笔保险）</p><p>其他系统必须在处理完消息后调用提单系统提供的 API，来修改提单系统中这笔数 据的状态</p><p>只要 API 没有被调用，数据状态没有被修改，提单系统就认为下游系统没有收到这条消息</p><h4 id="6-2-发送响应消息给生产者"><a href="#6-2-发送响应消息给生产者" class="headerlink" title="6.2 发送响应消息给生产者"></a>6.2 发送响应消息给生产者</h4><p> 例如：商业银行与人民银行二代支付通信(使用 IBM MQ)，无论是人行收到了商业银行的消息，还是商业银行收到了人行的消息，都必须发送一条响应消 息(叫做回执报文)</p><p> 整个通信的流程设计得非常复杂，但是对于金融场景下的消息可靠性保证，是很有用的</p><h3 id="7-补偿机制"><a href="#7-补偿机制" class="headerlink" title="7.补偿机制"></a>7.补偿机制</h3><p>如果生产者的 API 就是没有被调用，也没有收到消费者的响应消息，怎么办？</p><p>由于可能存在网络拥堵等情况，所以可以先等一段时间</p><p>生产者与消费者之间应该约定一个超时时间，对于超出这个时间没有得到响应的消息，才确定为消费失败，比如 5 分钟</p><blockquote><p>5 分钟，对于临时性故障的处理，比如网络恢复，或者重启应用，重启数据库，应该够了</p></blockquote><p>过了 5 分钟依然没有得到回复的消息，才判断为消费失败</p><p>确定消费失败以后怎么办呢？肯定要重发消息了</p><p>此时就要考虑，谁来重发消息，多久重发一次等问题了</p><h4 id="7-1-谁来重发"><a href="#7-1-谁来重发" class="headerlink" title="7.1 谁来重发"></a>7.1 谁来重发</h4><p>首先，肯定是代码重发</p><p>先创建一个定时任务，比如每 30 秒跑一次，找到业务表里面的这条业务状态是中 咕泡出品 必属精品 间状态的记录，查询出来，构建为 MQ 消息，重新发送</p><p>也可以单独设计设计一张消息表，把本系统所以发送出去的消息全部异步地登记起来，找出状态是未回复的消息发送（注意:这种做法毫无疑问会消耗性能、消耗数据库存储空间）</p><h4 id="7-2-多久重发一次"><a href="#7-2-多久重发一次" class="headerlink" title="7.2 多久重发一次"></a>7.2 多久重发一次</h4><p>假如消费者一直没有回复，比如它重启要 20 分钟，你 5 分钟之内尝试重发，肯定还不能正常消费</p><p>所以重发肯定不只发一次，要尝试多次，但是又不能发得太频繁， 给它一点恢复的时间，比如可以设置为 1 分钟重发一次</p><p>也可以设置衰减机制，第一次隔一分钟，第二次隔两分钟（谈恋爱的时候，发消息不回复，开始一天联系一次， 后来一周联系一次，慢慢地失去了信心）<br>时间由定时任务的执行时间决定</p><h4 id="7-3-重发几次"><a href="#7-3-重发几次" class="headerlink" title="7.3 重发几次"></a>7.3 重发几次</h4><p>一般来说，不会重发太多次，2-3次即可</p><h4 id="7-4-重发什么"><a href="#7-4-重发什么" class="headerlink" title="7.4 重发什么"></a>7.4 重发什么</h4><p>一般来说，重发一样的内容</p><h3 id="8-消费幂等性"><a href="#8-消费幂等性" class="headerlink" title="8.消费幂等性"></a>8.消费幂等性</h3><p>所谓幂等性，就是无论第几次消费消息，造成的结果和第一次消费一样</p><p>为什么要幂等性？</p><p>假如转账消费，消费一次+1000元，那要是重复消费就是大问题了</p><p>那么如何解决幂等性问题呢？</p><p>可以使用唯一的业务ID，通过日志或者消息落库来做重复控制</p><h3 id="9-最终一致"><a href="#9-最终一致" class="headerlink" title="9.最终一致"></a>9.最终一致</h3><p>即在投递消费之后，再次核对</p><h3 id="10-消费顺序性"><a href="#10-消费顺序性" class="headerlink" title="10.消费顺序性"></a>10.消费顺序性</h3><p>即保证消费顺序和投递顺序一致</p><p>如何保证？</p><p>一个队列一个消费者</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper</title>
      <link href="/2023/03/31/Zookeeper/"/>
      <url>/2023/03/31/Zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>Zookeeper是一个开源的分布式协调服务，用于管理大型分布式系统中的配置信息、命名服务、分布式锁和分布式应用程序的协同工作等</p><p><strong>经典应用场景？</strong></p><ul><li>命名服务<ul><li>在分布式系统中，不同的节点需要协同工作，但是节点的地址、端口等信息可能会发生变化，此时可以使用Zookeeper作为命名服务，记录节点的地址、端口等信息，并提供动态更新功能</li></ul></li><li>配置管理<ul><li>在分布式系统中，对系统的各个组件的配置信息进行统一管理和分发的一种技术</li></ul></li><li>数据同步<ul><li>是指在分布式系统中，将多个节点之间的数据保持一致的过程</li></ul></li><li>leader选举<ul><li>用于在一个分布式系统中选择一个节点作为Leader（领导者）来协调整个系统的工作</li></ul></li><li>消息队列<ul><li>可作为分布式消息队列组件的一部分</li></ul></li><li>通知系统<ul><li>用作分布式的通知系统，为分布式应用提供可靠的通知和事件服务，通常情况下，Zookeeper的通知系统基于Watch机制实现</li></ul></li></ul><h2 id="二、架构"><a href="#二、架构" class="headerlink" title="二、架构"></a>二、架构</h2><h3 id="1-单机架构"><a href="#1-单机架构" class="headerlink" title="1.单机架构"></a>1.单机架构</h3><img src="https://static-2w2.pages.dev/post/zk-sig.png" alt="image-20230412094507449" style="zoom:50%;" /><p>安装：支持源文件、docker安装</p><p>连接：通过zkCli.sh连接</p><p>管理：图形化界面<a href="https://github.com/DeemOpen/zkui">zkui</a></p><h3 id="2-数据模型与基本操作"><a href="#2-数据模型与基本操作" class="headerlink" title="2.数据模型与基本操作"></a>2.数据模型与基本操作</h3><h4 id="2-1-分层命名空间"><a href="#2-1-分层命名空间" class="headerlink" title="2.1 分层命名空间"></a>2.1 分层命名空间</h4><p>Zookeeper的分层命名空间是指将Zookeeper的节点组织成多层次的树形结构，用于更好地管理和组织节点。每个节点都可以拥有子节点，形成一个树形结构，其中根节点是”&#x2F;“，下面是结构图</p><p><img src="https://static-2w2.pages.dev/post/zk-namespace.png" alt="ZooKeeper 的分层命名空间"></p><p>上面介绍了分层命名空间，它将zookeeper的节点按照树形结构组织，那么节点又是什么结构呢？</p><h4 id="2-2-节点和临时节点"><a href="#2-2-节点和临时节点" class="headerlink" title="2.2 节点和临时节点"></a>2.2 节点和临时节点</h4><blockquote><p>ZooKeeper 树中的每个节点都称为<em>znode</em></p><p>Znode维护一个stat结构，其中包括版本号和数据变化、acl变化</p><p>此外，stat结构还包括时间戳，版本号和时间戳结合起来，允许ZooKeeper验证缓存并协调更新，每当znode的数据更改时，版本号就会增加</p><p>例如，每当客户端检索数据时，它还会收到数据的版本号。当客户端执行更新或删除操作时，必须提供正在更改的znode的数据版本。如果提供的版本号与实际数据的版本号不匹配，更新将失败</p></blockquote><p>节点是指存储数据的最小单元。每个节点都可以包含一些元数据和数据，以及一些ACL（访问控制列表）信息，具体来说，每个节点包含的信息如下：</p><ul><li>路径：节点在Zookeeper中的路径，由斜杠”&#x2F;“分隔的多个名称组成，例如：”&#x2F;myapp&#x2F;config”.</li><li>数据：节点中存储的数据，可以是任意类型的二进制数据。</li><li>元数据：包括节点的创建时间、修改时间、版本号等信息。</li><li>ACL（访问控制列表）：用于控制节点的访问权限。</li></ul><p>节点以<strong>字节码</strong>形式存储在Zookeeper的内存中，并通过Zookeeper的API进行访问和操作</p><blockquote><p>在Zookeeper中，节点数据是以字节码形式存储的，这意味着节点中存储的数据需要被转换为字节流，并以字节流的形式写入Zookeeper的内存中</p><p>使用字节码的好处是可以节省存储空间，并提高数据读取和写入的效率</p></blockquote><p>此外，在Zookeeper中，节点有两种，分别是永久节点与临时节点</p><ul><li>永久节点：是指创建后一直存在的节点，直到被删除或Zookeeper服务停止</li><li>临时节点：是指只在客户端会话期间存在的节点，一旦客户端会话结束或失效，临时节点将被自动删除，临时节点的使用可以有效地避免分布式系统中的资源浪费和竞争问题</li></ul><h4 id="2-3-节点特性"><a href="#2-3-节点特性" class="headerlink" title="2.3 节点特性"></a>2.3 节点特性</h4><p>在Zookeeper中，节点除了基本属性外，还具有一些特性，其中一些特性包括</p><ul><li><strong>持久节点</strong>：持久节点是Zookeeper中最常见的节点类型，它们的生命周期与Zookeeper的生命周期相同。即使客户端与Zookeeper断开连接，持久节点也<strong>会一直存在，直到被显式删除</strong></li><li><strong>临时节点</strong>：临时节点的生命周期与客户端的连接相关联。当客户端与Zookeeper<strong>断开连接时，临时节点将被删除</strong>。这种节点通常用于实现分布式锁等功能</li><li><strong>有序节点</strong>：有序节点是指在创建节点时，Zookeeper会自动为其分配一个<strong>全局唯一的序列号</strong>，并按照序列号的大小进行排序。有序节点通常用于实现队列等功能</li><li><strong>可监听节点</strong>：Zookeeper的节点支持事件监听，当节点<strong>发生变化</strong>时，客户端可以接收到通知。这种特性通常用于实现配置管理等功能</li><li><strong>分层命名空间</strong>：Zookeeper的节点支持分层命名空间，可以使用斜杠（&#x2F;）将节点组织成层次结构。这种特性通常用于实现<strong>配置管理和命名服务</strong>等功能</li></ul><p>此外，介绍两类特殊节点：</p><p><strong>容器节点：</strong>在 ZooKeeper 中，容器节点是指可以包含其他节点的节点，它们本身不存储任何数据，只是作为其他节点的父节点存在。容器节点也可以称为永久节点，因为它们在创建后一直存在，除非被显式删除。</p><p><strong>TTL节点：</strong> TTL 节点是指在创建时指定了生存时间的节点。节点在创建后，在指定的时间之后自动删除。这种节点在 ZooKeeper 中也称为短暂节点（ephemeral node）。可以通过向创建 TTL 节点的请求中添加一个超时时间来实现</p><h4 id="2-4-时间"><a href="#2-4-时间" class="headerlink" title="2.4 时间"></a>2.4 时间</h4><p>在ZooKeeper中，时间是非常重要的概念，它涉及到ZooKeeper的一些关键特性，例如协调更新、数据一致性等，下面是一些相关概念</p><ul><li>Zxid（ZooKeeper Transaction Id）<ul><li>Zxid是ZooKeeper事务ID的缩写，用于唯一标识每个事务</li><li>状态的每次更改都会收到一个zxid 形式的戳记，这公开了对 ZooKeeper 的所有更改的总顺序，每个更改都会有一个唯一的 zxid，如果 zxid1 小于 zxid2，则 zxid1 发生在 zxid2 之前</li></ul></li><li>版本号：记录znode是否变化，每次变化版本号+1</li><li>Ticks：Ticks是ZooKeeper中的一个时间概念，它是一个增量时间单位，表示ZooKeeper的时间</li><li>Real time：是指从机器启动时开始的实际时间，通常用于日志记录等目的</li></ul><blockquote><p>这里详细介绍一下zxid，zxid是事务编号，8字节的整型数，即64个比特位，前32位标识epoch，后32位用来计数<br> zxid的初始值为0，用二进制标识就是 00000000 00000000 00000000 00000000 </p><p>每一次事务请求都会把后面32位的值+1，比如进行了10次事务请求，则zxid变为</p><p> 00000000 00000000 00000000 00000000 <em>00000000 00000000 00000000 0000<strong>1010</strong></em> </p><p>每进行一次leader选举，前32位的值就会+1，并把后面的32位清零，则zxid变为</p><p>00000000 00000000 00000000 0000<strong>0001</strong> <em>00000000 00000000 00000000 00000000</em></p></blockquote><p>在zookeeper中，zxid有以下表现形式，存储在stat结构中</p><ul><li>czxid：表示当前节点被创建时的事务id</li><li>mzxid：表示当前节点被最后一次更新时的事务id</li><li>pzxid：表示该节点的子节点最后一次被修改时的事务id，只有子节点变化才会影响pxzid</li></ul><h2 id="三、高级特性"><a href="#三、高级特性" class="headerlink" title="三、高级特性"></a>三、高级特性</h2><h3 id="1-watch"><a href="#1-watch" class="headerlink" title="1.watch"></a>1.watch</h3><p>在 ZooKeeper 中，客户端可以使用 watch 机制来<strong>监视某个节点</strong>的变化情况，当节点的状态发生变化时，ZooKeeper 会将通知发送给所有注册了该节点的 Watcher</p><p>具体来说，当一个客户端向 ZooKeeper 注册 Watcher 时，它会在节点上设置一个监视器，并与这个节点建立一个会话。当这个节点的状态发生变化时（例如节点被创建、更新或删除），ZooKeeper 会将通知发送到客户端的会话。客户端会接收到这个通知，然后可以处理节点状态的变化</p><p>图解</p><img src="https://static-2w2.pages.dev/post/es-watch.png" alt="image-20230412110600524" style="zoom: 45%;" /><h3 id="2-ACL"><a href="#2-ACL" class="headerlink" title="2.ACL"></a>2.ACL</h3><p>在ZooKeeper中，ACL（Access Control List）是一种机制，<strong>用于控制对znode的访问权限</strong>。每个znode都可以关联一个ACL。ACL定义了哪些用户、哪些操作可以访问该znode</p><p>ZooKeeper支持以下操作权限：</p><ul><li>READ：读取znode的数据和子节点列表</li><li>WRITE：设置znode的数据</li><li>CREATE：创建子节点</li><li>DELETE：删除znode或子节点</li><li>ADMIN：设置znode的ACL</li></ul><p>ACL是一个包含多个元素的列表。每个元素表示一个权限的组合，包括：</p><ul><li>权限模式（scheme）：用于验证身份的机制，例如digest、ip、world、sasl等</li><li>身份标识（id）：用于表示一个用户或角色，例如用户名、IP地址、用户组等</li><li>权限（permission）：对该身份标识具有的权限，例如read、write、create等</li></ul><p>每个ACL元素对应一个唯一的编号，ZooKeeper中将其称为ACL ID。当客户端连接到ZooKeeper时，它可以使用auth API来验证自己的身份。如果身份验证成功，客户端会获得一个会话ID，它将与ACL ID关联。在后续的会话中，客户端只能访问与其关联的ACL ID所允许的节点</p><p>需要注意的是，设置znode的ACL只能在创建znode时进行，不能修改。如果需要修改znode的ACL，必须删除该znode并重新创建。此外，ZooKeeper的ACL不是强制执行的，而是建议性的，也就是说如果有足够的权限，用户仍然可以访问znode。因此，在使用ACL时，应该根据实际情况进行权衡和规划，以确保ZooKeeper集群的安全和稳定性</p><p>以下是常见的ACL方案</p><ul><li>world：world方案是最简单的方案，它可以控制所有用户对znode的访问权限。world方案的规则形式为“scheme:id:perm”，其中scheme为world，id为anyone，perm表示权限（create、delete、read、write、admin）。例如，要授予所有用户读取和写入znode的权限，可以使用规则“world:anyone:rw”。</li><li>auth：auth方案用于控制已通过身份验证的用户对znode的访问权限。它的规则形式为“scheme:id:perm”，其中scheme为auth，id为已经通过身份验证的用户，perm表示权限。例如，要授予名为“user1”的已经通过身份验证的用户读取和写入znode的权限，可以使用规则“auth:user1:rw”。</li><li>digest：digest方案基于用户名和密码来控制访问权限。它的规则形式为“scheme:id:perm”，其中scheme为digest，id为用户名:密码的SHA1摘要值，perm表示权限。例如，要授予用户名为“user1”、密码为“password”的用户读取和写入znode的权限，可以使用规则“digest:user1:3e25960a79dbc69b674cd4ec67a72c62:rw”。</li><li>ip：ip方案基于客户端的IP地址来控制访问权限。它的规则形式为“scheme:ip:perm”，其中scheme为ip，ip为客户端的IP地址，perm表示权限。例如，要授予IP地址为192.168.1.100的客户端读取和写入znode的权限，可以使用规则“ip:192.168.1.100:rw”。</li><li>sasl：sasl方案是一种用于身份验证的开放式标准。它允许客户端使用各种安全协议来进行身份验证，例如Kerberos、OAuth、LDAP等。sasl方案的规则形式为“scheme:id:perm”，其中scheme为sasl，id为已经通过身份验证的用户，perm表示权限。例如，要授予名为“user1”的已经通过SASL身份验证的用户读取和写入znode的权限，可以使用规则“sasl:user1:rw”。</li></ul><p>这些ACL方案可以组合使用，例如可以同时使用digest和auth方案来对访问权限进行更精细的控制。需要注意的是，ACL是在创建znode时设置的，一旦设置后就不能修改。因此，在设计应用程序时需要考虑好权限控制策略。</p><h3 id="3-Monitoring"><a href="#3-Monitoring" class="headerlink" title="3.Monitoring"></a>3.Monitoring</h3><p>在ZooKeeper中，Monitoring通常用于跟踪集群中各个节点的健康状况以及资源使用情况</p><p>监控可以帮助管理员快速发现并解决集群中的问题，确保其稳定性和可靠性</p><p>ZooKeeper提供了一些内置的监控工具和指标，例如：</p><ul><li><strong>Four Letter Words</strong>（四字命令）：通过发送包含特定命令的TCP请求来检查和监视ZooKeeper服务器的状态。这些命令包括“stat”、“ruok”、“mntr”等，每个命令都返回特定的信息和指标</li><li><strong>JMX</strong>：ZooKeeper使用Java管理扩展（JMX）提供了一组监控和管理API，可用于监视服务器性能和状态，包括znode、客户端连接数、延迟、请求计数等</li><li><strong>Metrics</strong>：ZooKeeper还提供了Metrics API，可用于收集和发布关于服务器的指标和数据。可以使用可视化工具（如Grafana）将这些指标呈现出来，以便进行更直观的监控和分析</li></ul><p>通过这些监控工具，管理员可以监视集群的运行状况、查找潜在问题并采取必要的措施来解决它们，从而确保ZooKeeper集群的稳定和可靠性</p><h3 id="4-序列化和反序列化"><a href="#4-序列化和反序列化" class="headerlink" title="4.序列化和反序列化"></a>4.序列化和反序列化</h3><blockquote><p>在分布式系统中，数据需要在网络上传输，而网络上的传输数据只能是二进制的。为了将数据在网络上传输，需要将其序列化成二进制格式，而在接收端需要将其反序列化为原始数据</p></blockquote><p>ZooKeeper采用的是Jute作为其序列化和反序列化的方式</p><p>Jute是ZooKeeper自带的一个二进制编解码库，它提供了一种轻量级的序列化机制，适合于数据结构简单、字段数量不太多的场景。相比于Java自带的序列化方式，Jute的效率更高、数据量更小，同时也更易于跨语言使用</p><h3 id="5-快照数据与事务日志"><a href="#5-快照数据与事务日志" class="headerlink" title="5.快照数据与事务日志"></a>5.快照数据与事务日志</h3><blockquote><p><strong>快照数据</strong>:记录所有ZNode节点及数据某一时刻的快照，保存在zoo.cfg文件配置项的dataDir目录的的version-2中，格式为snapshot.zxid </p><p><strong>事务日志</strong>:记录每一次事务操作的记录，保存在dataLogDir[dataDir]目录的的version-2中，格式为log.zxid</p></blockquote><p>那么他们有什么作用呢？事实上，在zookeeper中，快照数据与事务日志共同配合，用于持久化存储和恢复数据，确保数据的可靠性和一致性，是zookeeper数据持久化的实现方式</p><p><strong>快照数据：</strong></p><p>是ZooKeeper数据的静态拷贝，它记录了ZooKeeper的整个数据树在某个时间点的状态。快照数据包括每个znode的数据内容、版本号、访问控制列表（ACL）和时间戳等信息。当ZooKeeper启动时，它会从快照数据中读取所有znode的状态信息，并使用这些信息重新构建整个数据树。快照数据的作用是提供了一个基准状态，以便ZooKeeper可以在事务日志中记录的操作上进行重放，实现数据的恢复</p><p><strong>事务日志：</strong></p><p>事务日志是ZooKeeper中的所有更新操作的记录。当客户端执行写操作时，它们将生成一个事务，该事务被追加到事务日志中。每个事务都被分配一个唯一的事务ID，该ID由ZXID（ZooKeeper Transaction ID）表示。每个事务都包括操作类型（例如create、set、delete）以及操作所需的数据。当ZooKeeper重启时，它会读取最新的快照数据，然后重新播放在最后一个快照之后的所有事务，以恢复所有更新操作。因此，事务日志的作用是确保数据在发生故障时不会丢失，并且可以保持最终一致性</p><blockquote><p>总的来说，快照数据和事务日志结合起来，保证了ZooKeeper的可靠性和一致性。快照数据提供了一个基准状态，事务日志记录了所有数据更新操作。当ZooKeeper启动时，它使用快照数据来重建数据树，并重放所有事务日志中记录的操作，以实现数据的恢复和一致性</p></blockquote><h2 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h2><ol><li><p><strong>Zookeeper是什么？它的作用是什么？</strong> </p><p>答：Zookeeper是一个开源的分布式协调服务，用于构建分布式应用程序和服务。它提供了一个高可用的、可靠的、有序的节点管理（命名服务）、配置管理、分布式锁、分布式队列等功能。</p></li><li><p><strong>Zookeeper的节点是什么？节点包括哪些信息？</strong> </p><p>答：Zookeeper中的节点被称为znode，包括数据内容、版本号、ACL、时间戳等信息。</p></li><li><p><strong>Zookeeper的watch机制是什么？它的作用是什么？</strong> </p><p>答：Zookeeper的watch机制是一种事件通知机制，当指定的节点发生变化时，客户端将收到通知。它可以用于实现数据的实时同步、分布式锁、分布式队列等功能。</p></li><li><p><strong>Zookeeper中的ACL是什么？它的作用是什么？</strong> </p><p>答：Zookeeper中的ACL（Access Control List）是一种权限控制机制，用于限制对节点的访问。它可以保护节点的安全性，防止恶意访问或篡改数据。</p></li><li><p><strong>Zookeeper的数据存储方式是什么？它有哪些优势？</strong> </p><p>答：Zookeeper的数据存储方式是内存数据库，将节点的数据以字节码的形式存储在内存中。它的优势是读写速度快，支持高并发，适合用于构建高性能的分布式应用。</p></li><li><p><strong>Zookeeper的数据一致性是如何保证的？</strong> </p><p>答：Zookeeper通过ZAB协议（Zookeeper Atomic Broadcast）来保证数据的一致性，ZAB协议采用了一种主从复制的机制，在主节点上进行数据修改，并将数据变更通过ZAB协议广播给从节点，从而实现数据的一致性。</p></li><li><p><strong>Zookeeper如何实现分布式锁？</strong></p><p> 答：Zookeeper实现分布式锁的方法是使用临时顺序节点，每个客户端创建一个临时顺序节点，对应一个锁，当客户端希望获得锁时，它将创建一个新的临时顺序节点，并获取当前所有节点中最小的节点号，如果它是最小的节点号，则认为它获得了锁，否则它将等待前一个节点释放锁后再次尝试。</p></li><li><p><strong>什么是Zookeeper的ZAB协议？它是如何保证数据一致性的？</strong></p><p>Zookeeper是一个开源的分布式协调服务，用于构建分布式应用程序和服务。它提供了一个高可用的、可靠的、有序的节点管理（命名服务）、配置管理、分布式锁、分布式队列等功能</p></li><li><p><strong>Zookeeper的节点是如何命名的？什么是Zookeeper的命名空间？</strong></p></li></ol><p>   Zookeeper的节点使用路径来命名，路径以斜杠（&#x2F;）分隔，例如&#x2F;foo&#x2F;bar。Zookeeper的命名空间是由所有节点路径的集合所组成的层次结构，类似于文件系统中的目录结构。每个节点都被称为znode，并有一个全局唯一的路径名。Zookeeper的命名空间具有层次结构的特点，这使得它非常适合用于分布式应用程序的协调和管理</p><ol start="10"><li><p><strong>什么是Zookeeper的会话（Session）？会话超时时间是多久？</strong> </p><p>Zookeeper的会话（Session）是客户端与Zookeeper服务器之间的连接。当客户端第一次连接到Zookeeper服务器时，它会创建一个会话。Zookeeper的会话是有状态的，它可以在会话期间跨越多个操作。会话超时时间是指客户端在Zookeeper服务器上的会话失效之前允许的空闲时间。如果客户端在这段时间内没有发送心跳，Zookeeper服务器将认为客户端已经死亡，并终止会话</p></li><li><p><strong>什么是Zookeeper的快照（Snapshot）和事务日志（Transaction Log）？</strong> </p><p>Zookeeper的快照（Snapshot）是Zookeeper保存的一个静态数据副本，用于在Zookeeper重启时恢复状态。事务日志（Transaction Log）则是用于保存Zookeeper中所有数据更新的序列化记录，可以在Zookeeper崩溃时用于恢复数据。快照和事务日志是Zookeeper实现高可用性和数据一致性的重要组成部分</p></li><li><p><strong>什么是Zookeeper的客户端与服务器之间的心跳机制？</strong></p><p>Zookeeper的客户端与服务器之间通过心跳机制来维持其连接状态。客户端在与服务器建立连接后，会定时向服务器发送心跳请求，以保证连接不会超时断开。同时，服务器也会定时向客户端发送心跳响应，以表明自己仍然存活。如果客户端在一定时间内没有收到服务器的心跳响应，则会认为服务器已经宕机，并尝试重新连接其他可用的服务器</p></li><li><p><strong>Zookeeper如何处理网络分区（Network Partition）问题？</strong></p></li></ol><pre><code>当出现网络分区时，Zookeeper采用的策略是通过选举机制来选择一个Leader节点，并使其负责处理所有的写请求。其他的节点成为Follower节点，只处理读请求并将写请求转发给Leader节点处理。当网络分区解决后，Follower节点会将所有的写请求发送给Leader节点，以便保证数据的一致性</code></pre><ol start="14"><li><p><strong>如何使用Zookeeper实现服务发现和注册？</strong> </p><p>可以使用Zookeeper的节点监听机制来实现服务发现和注册。当服务启动时，在Zookeeper上创建一个持久节点，并在该节点下创建一个临时节点，节点名称为该服务的IP地址和端口号。其他服务可以监听该节点，并获取到注册的服务信息。</p></li><li><p><strong>你如何使用Zookeeper监控集群状态？</strong> </p><p>可以使用Zookeeper的四字命令来监控集群状态。Zookeeper提供了一些命令，例如<code>stat</code>、<code>srvr</code>和<code>ruok</code>等，可以通过Telnet或nc等工具连接Zookeeper服务器并执行这些命令，以获取集群状态和运行信息</p></li><li><p><strong>你如何使用Zookeeper实现分布式队列？</strong> </p><p>可以使用Zookeeper的有序节点（序列化节点）来实现分布式队列。当消息进入队列时，在Zookeeper上创建一个有序节点，并将消息存储在该节点上。其他消费者可以监听该节点，并获取到队列中的消息</p></li><li><p><strong>你如何使用Zookeeper实现分布式配置管理？</strong> </p><p>可以使用Zookeeper的节点监听机制来实现分布式配置管理。当配置发生变化时，在Zookeeper上创建一个新的节点，并将新的配置信息存储在该节点上。客户端可以监听该节点，并获取到最新的配置信息。</p></li><li><p><strong>Zookeeper的Znode的版本号是如何实现的？它有什么作用？</strong></p><p>Zookeeper的每个Znode节点都有一个版本号，分为两种：数据版本（Data Version）和状态版本（Stat Version）。数据版本表示数据内容的版本号，每次对Znode节点数据进行修改都会使数据版本号加1。状态版本表示Znode的元数据版本号，例如Znode节点的子节点变化、ACL变化等都会引起状态版本号的增加。</p><p>Zookeeper的版本号是基于Zookeeper的ZAB协议实现的。当一个客户端请求对一个Znode节点进行操作时，Zookeeper会检查请求携带的版本号与Znode节点的当前版本号是否一致，若不一致则拒绝请求</p><p>版本号的作用是保证分布式环境下多个客户端对同一份数据进行修改时的一致性</p></li><li><p><strong>什么是选举机制？</strong></p><p>Zookeeper中的Leader选举是指在一个Zookeeper集群中，选举一个节点作为Leader，负责协调和管理整个集群的状态。Leader选举是Zookeeper保证分布式一致性的基础，如果Leader选举失败或出现异常，整个Zookeeper集群就无法正常工作。</p><p>Zookeeper中的Leader选举采用的是ZAB协议（Zookeeper Atomic Broadcast，Zookeeper原子广播协议）实现的。当一个节点启动时，它会与其他节点建立连接，然后尝试成为Leader。具体过程如下：</p><ul><li>选举过程启动：节点开始向其他节点发送Leader选举的请求。</li><li>选票投票：节点收到其他节点的选举请求后，会投票给请求者，同时将自己的选票发送给其他节点。</li><li>统计选票：节点会定期统计选票，当一个节点收到的选票超过半数时，它就会成为Leader。</li><li>发布选举结果：当一个节点成为Leader后，它会向其他节点发送选举结果，告诉它们自己已经成为了Leader。</li><li>同步数据：当一个节点成为Leader后，它会将自己的数据同步给其他节点，确保所有节点的数据一致性。</li></ul><p>需要注意的是，Leader选举并不是一次性的过程，而是一个持续的过程。如果当前的Leader宕机或出现网络分区等问题，会重新触发Leader选举过程，选举一个新的Leader来取代原来的Leader</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch</title>
      <link href="/2023/03/26/ElasticSearch/"/>
      <url>/2023/03/26/ElasticSearch/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><h3 id="1-什么是搜索？"><a href="#1-什么是搜索？" class="headerlink" title="1.什么是搜索？"></a>1.什么是搜索？</h3><p>概念：搜索是指使用计算机程序在互联网或本地计算机存储的数据中查找特定信息的过程</p><p>即输入关键字，获取想要结果的过程</p><p>搜索涉及的种类十分繁杂，包括新闻网页搜索、站内搜索（垂直搜索）等</p><h3 id="2-如何实现搜索"><a href="#2-如何实现搜索" class="headerlink" title="2.如何实现搜索"></a>2.如何实现搜索</h3><h4 id="2-1-传统数据库"><a href="#2-1-传统数据库" class="headerlink" title="2.1 传统数据库"></a>2.1 传统数据库</h4><p>传统MySql数据库能否实现搜索功能呢？答案是肯定的</p><p>但是传统MySql数据库实现搜索只能适用<strong>数据量小，简单搜索</strong>的场景，具有以下弊端</p><ul><li><strong>存储问题：</strong>电商网站商品上亿条时，涉及到单表数据过大必须拆分表，数据库磁盘占用过大必须分库 (mycat)</li><li><strong>性能问题：</strong>解决上面问题后，查询“笔记本电脑”等关键词时，上亿条数据的商品名字段逐行扫描，性能跟不上</li><li><strong>不能分词：</strong>如搜索“笔记本电脑”，只能搜索完全和关键词一样的数据，那么数据量小时，搜索“笔记本电脑”，“电脑”数据要不要给用户</li></ul><h4 id="2-2-全文检索与倒排索引"><a href="#2-2-全文检索与倒排索引" class="headerlink" title="2.2 全文检索与倒排索引"></a>2.2 全文检索与倒排索引</h4><p>在MySql中，其实也支持全文检索，主要依赖于MySql的全文索引来实现，是一种用于快速搜索文本数据的索引技术，MySQL 5.6及以上版本支持全文索引</p><p>全文索引会将指定的列中的文本数据进行分词，去除停用词等处理，生成一个词汇表，将每个词汇与出现该词汇的行进行关联，从而加速文本数据的搜索，需要注意的是，MySQL的全文索引实现是基于<strong>倒排索引</strong>（Inverted Index）的</p><p>何谓倒排索引呢？简单点说就是，以词作为key，出现位置的集合作为value的结构</p><p>举个例子，见下表</p><table><thead><tr><th align="center">ID</th><th align="center">Name</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">课程周边帽子</td></tr><tr><td align="center">2</td><td align="center">课程周边衣服</td></tr><tr><td align="center">3</td><td align="center">课程书籍XXX</td></tr><tr><td align="center">4</td><td align="center">杰伦签名</td></tr></tbody></table><p>那么在对Name列分词，按照倒排索引就可以得到下面的表格</p><table><thead><tr><th align="center">分词term</th><th align="center">IDs</th></tr></thead><tbody><tr><td align="center">课程</td><td align="center">[1,2,3]</td></tr><tr><td align="center">周边</td><td align="center">[1,2]</td></tr><tr><td align="center">书籍</td><td align="center">[3]</td></tr><tr><td align="center">杰伦</td><td align="center">[4]</td></tr><tr><td align="center">…</td><td align="center">…</td></tr></tbody></table><p>由此可见，如果用户输入一个关键词后，能够快速的匹配到分词，从而找到分词出现的位置</p><p>倒排索引源于实际应用中需要根据属性的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。带有倒排索引的文件我们称为倒排索引文件，简称倒排文件(inverted fifile)</p><h4 id="2-3-Lucene"><a href="#2-3-Lucene" class="headerlink" title="2.3 Lucene"></a>2.3 Lucene</h4><p>Lucene是一个非常强大和灵活的全文搜索引擎库，能够广泛应用于各种文本搜索场景，包括网站搜索、企业搜索、电子商务、新闻检索等</p><p>简单点说，就是一个jar包，里面封装了全文检索的引擎、搜索的算法代码。开发时，引入lucen的jar包，通过api 开发搜索相关业务。底层会在磁盘建立索引库</p><h2 id="二、概念介绍"><a href="#二、概念介绍" class="headerlink" title="二、概念介绍"></a>二、概念介绍</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p><strong>Elasticsearch（ES）是基于Lucene构建的分布式搜索引擎，它扩展了Lucene的功能并提供了大规模数据处理、实时搜索、多租户等特性。因此，可以说ES是Lucene的一个扩展和增强版</strong></p><p>ES在Lucene的基础上提供了以下特性：</p><ul><li>分布式架构：ES具有分布式的数据存储和处理能力，可以实现数据分片、节点扩展和高可用等功能</li><li>RESTful API：ES使用基于HTTP协议的RESTful API，可以方便地与其他应用程序和工具进行交互</li><li>实时搜索：ES能够在数据发生变化时实时更新索引，提供实时搜索的能力</li><li>多租户支持：ES支持多租户模式，可以在同一个ES集群中隔离多个应用的数据和搜索请求</li><li>多种查询方式：ES支持多种查询方式，包括全文搜索、精确查询、过滤查询等</li></ul><p>上面介绍的是ES的特性，主要是说ES更加适合大型分布式系统，那么它到底具有哪些功能呢？下面介绍</p><ul><li>分布式的<strong>搜索引擎</strong>和<strong>数据分析引擎</strong><ul><li>搜索:互联网搜索、电商网站站内搜索、OA系统查询 </li><li>数据分析:电商网站查询近一周哪些品类的图书销售前十;新闻网站，最近3天阅读量最高的十个</li><li>关键词，舆情分析。</li></ul></li><li><strong>全文检索，结构化检索，数据分析</strong><ul><li>全文检索:搜索商品名称包含java的图书<ul><li>select * from books where book_name like “%java%”。</li></ul></li><li>结构化检索:搜索商品分类为spring的图书都有哪些<ul><li>select * from books where category_id&#x3D;’spring’</li></ul></li><li>数据分析:分析每一个分类下有多少种图书<ul><li>select category_id,count(*) from books group by category_id</li></ul></li></ul></li><li><strong>对海量数据进行近实时的处理</strong><ul><li>分布式:ES自动可以将海量数据分散到多台服务器上去存储和检索，进行并行查询，提高搜索效 率。相对的，Lucene是单机应用。</li><li>近实时:数据库上亿条数据查询，搜索一次耗时几个小时，是批处理(batch-processing)。而es 只需秒级即可查询海量数据，所以叫近实时。秒级</li></ul></li></ul><blockquote><p>简单来说，就是搜索、分析、分布式和近实时</p></blockquote><h3 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2.适用场景"></a>2.适用场景</h3><p>Elasticsearch（ES）是一个强大的搜索引擎，具有广泛的应用场景，包括但不限于以下几个方面：</p><ul><li><strong>企业搜索</strong>：ES能够处理海量的企业数据，包括文本、图片、视频等类型的数据，能够提供高效、准确的搜索结果。企业搜索场景包括了员工信息搜索、文档搜索、知识库搜索等。</li><li><strong>日志分析</strong>：ES能够对大量的日志数据进行处理和分析，提取关键信息，帮助企业监测业务运营和系统性能。日志分析场景包括了网络日志、系统日志、应用程序日志等。</li><li><strong>电商搜索</strong>：ES能够处理商品信息和用户搜索请求，提供高效、准确的搜索结果。电商搜索场景包括了商品搜索、推荐引擎等。</li><li><strong>网站搜索</strong>：ES能够处理网站上的信息和用户搜索请求，提供高效、准确的搜索结果。网站搜索场景包括了新闻搜索、博客搜索、社交网络搜索等。</li><li><strong>实时监控</strong>：ES能够实时处理数据，包括日志、事件、传感器数据等，可以在实时监控场景中应用。实时监控场景包括了网络监控、物联网监控等。</li></ul><blockquote><p>主要场景还是搜索</p></blockquote><h3 id="3-特点"><a href="#3-特点" class="headerlink" title="3.特点"></a>3.特点</h3><ul><li><strong>高可用性</strong>：ES是一个分布式系统，支持多个节点的部署和自动容错，因此具有高可用性。即使其中某些节点发生故障，系统依然能够正常运行。</li><li><strong>多种数据源支持</strong>：ES支持多种类型的数据源，包括关系型数据库、文档、日志、传感器数据等，因此适用于各种数据分析场景。</li><li><strong>实时搜索和分析</strong>：ES能够在数据发生变化时实时更新索引，提供实时搜索和分析的能力。</li><li><strong>多种查询方式</strong>：ES支持多种查询方式，包括全文搜索、精确查询、过滤查询等，满足不同的搜索需求。</li><li><strong>可扩展性</strong>：ES具有高度可扩展性，可以根据业务需求动态扩展节点和数据存储容量。</li><li><strong>灵活的部署方式</strong>：ES可以在云端或本地环境中部署，支持多种操作系统和编程语言，因此非常灵活</li></ul><blockquote><p>可拓展、高可用、功能强大、部署简单</p></blockquote><h3 id="4-核心概念"><a href="#4-核心概念" class="headerlink" title="4.核心概念"></a>4.核心概念</h3><h4 id="4-1-NRT-Near-Realtime-近实时"><a href="#4-1-NRT-Near-Realtime-近实时" class="headerlink" title="4.1 NRT(Near Realtime):近实时"></a>4.1 NRT(Near Realtime):近实时</h4><p>两方面:</p><ul><li>写入数据时，过1秒才会被搜索到，因为内部在分词、录入索引</li><li>es搜索时:搜索和分析数据需要秒级出结果</li></ul><h4 id="4-2-Cluster-集群"><a href="#4-2-Cluster-集群" class="headerlink" title="4.2 Cluster:集群"></a>4.2 Cluster:集群</h4><p>包含一个或多个启动着es实例的机器群，通常一台机器起一个es实例，同一网络下，集名一样的多个es实例自动组成集群，自动均衡分片等行为，默认集群名为“elasticsearch”</p><h4 id="4-3-Node-节点"><a href="#4-3-Node-节点" class="headerlink" title="4.3 Node:节点"></a>4.3 Node:节点</h4><p>Node是一个单独的ES实例，可以是单独的服务器或虚拟机</p><p>每个Node可以参与一个或多个Cluster，并负责处理Cluster中的数据和请求</p><p>Node可以承载多个Index，每个Index可以包含多个Shard</p><p>节点名自动分配，也可以手动配置</p><h4 id="4-4-Index-索引"><a href="#4-4-Index-索引" class="headerlink" title="4.4 Index:索引"></a>4.4 Index:索引</h4><p>Index是ES中最高层级的数据容器，类似于关系型数据库中的Database</p><p>每个Index都有自己的Mapping和Settings，可以存储多个Document，并且可以被分成多个Shard，每个Shard可以分配到不同的Node上</p><p>索引创建规则如下</p><ul><li><strong>索引名称</strong>：索引名称必须是小写字母，不能包含大写字母或下划线，只能包含字母、数字、连字符和点号</li><li><strong>分片和副本</strong>：创建索引时需要指定分片和副本的数量。分片数量应该根据数据量、查询频率和硬件资源进行调整，以保证索引的性能。副本数量可以提高索引的可用性和容错能力</li><li><strong>Mapping：</strong>Mapping用于定义索引中的文档结构，包括字段类型、分析器、数据格式等。合理地定义Mapping可以提高搜索和分析的性能</li><li><strong>设置</strong>：设置包括索引级别和节点级别的设置。索引级别的设置包括分片和副本、Mapping、刷新间隔、缓存等。节点级别的设置包括JVM堆内存、文件描述符、线程池等</li><li><strong>索引别名</strong>：索引别名是索引的可读名称，可以用于在查询时指定具体的索引。索引别名可以随时更改，可以将多个索引合并成一个别名</li></ul><p>总的来说，ES索引创建的规则包括索引名称、分片和副本、Mapping、设置和索引别名等</p><h4 id="4-5-Document-文档"><a href="#4-5-Document-文档" class="headerlink" title="4.5 Document:文档"></a>4.5 Document:文档</h4><p>es中的最小数据单元。一个document就像数据库中的一条记录。通常以json格式显示。多个 document存储于一个索引(Index)中</p><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">book document</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;book_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line"><span class="string">&quot;book_name&quot;</span>: <span class="string">&quot;carl的笔记&quot;</span>,</span><br><span class="line"><span class="string">&quot;book_desc&quot;</span>: <span class="string">&quot;carl呕心沥血写的菜谱，一定要好好研习&quot;</span>, </span><br><span class="line"><span class="string">&quot;category_id&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line"><span class="string">&quot;category_name&quot;</span>: <span class="string">&quot;java&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-6-Field-字段"><a href="#4-6-Field-字段" class="headerlink" title="4.6 Field:字段"></a>4.6 Field:字段</h4><p>Field是Document中的属性，类似于关系型数据库中的列</p><p>Field可以是不同的数据类型，如字符串、数字、日期、布尔等</p><h4 id="4-7-Type-类型"><a href="#4-7-Type-类型" class="headerlink" title="4.7 Type:类型"></a>4.7 Type:类型</h4><p>在早期的ES版本中，Type是指在一个Index中对数据进行分组的方式，类似于关系型数据库中的表</p><p><strong>分析: 为什么要7.X版本去除Type?</strong><br>因为关系型数据库比非关系型数据库的概念提出的早，而且很成熟，应用广泛。所以，后来很多 NoSQL(包括:MongoDB，Elasticsearch等)都参考并延用了传统关系型数据库的基本概念。由于需要有一个对应关系型数据库表的概念，所以type应运而生。那么为什么我们又需要把type去除呢?并且 需要在7.X版本去除呢?<br>首先，我们可以看一下ES的版本演变。<br>在 5.X 版本中，一个 index 下可以创建多个 type;<br>在 6.X 版本中，一个 index下只能存在一个 type;<br>在7.X 版本中，直接去除了 type 的概念，就是说index 不再会有 type。<br><strong>原因分析:</strong><br><strong>为何要去除 type 的概念?</strong><br>答: 因为 Elasticsearch 设计初期，是直接查考了关系型数据库的设计模式，存在了 type(数据表)的概念<br>但是，其搜索引擎是基于 Lucene 的，这种 “基因”决定了 type 是多余的。 Lucene 的全文检索功能之所以快，是因为<strong>倒序索引</strong>的存在。而这种<strong>倒序索引</strong>的生成是基于 index 的，而并非 type。多个type 反 而会减慢搜索的速度。</p><p>为了保持 Elasticsearch “<strong>一切为了搜索</strong>” 的宗旨，适当的做些改变(去除 type)也是无可厚非的，也是 值得的。</p><p><strong>为何不是在 6.X 版本开始就直接去除 type，而是要逐步去除type?</strong></p><p>答:因为历史原因，前期 Elasticsearch 支持一个 index 下存在多个 type的，而且，有很多项目在使用 Elasticsearch 作为数据库。如果直接去除 type 的概念，不仅是很多应用 Elasticsearch 的项目将面临 业务、功能和代码的大改，而且对于 Elasticsearch 官方来说，也是一个巨大的挑战(这个是伤筋动骨 的大手术，很多涉及到 type源码是要修改的)。</p><p>所以，权衡利弊，采取逐步过渡的方式，最终，推迟到 7.X 版本才完成 “去除 type” 这个 革命性的变革</p><h4 id="4-8-shard-分片"><a href="#4-8-shard-分片" class="headerlink" title="4.8 shard:分片"></a>4.8 shard:分片</h4><p>index数据过大时，将index里面的数据，分为多个shard，分布式的存储在各个服务器上面。可以支持海量数据和高并发，提升性能和吞吐量，充分利用多台机器的cpu</p><h4 id="4-9-replica-副本"><a href="#4-9-replica-副本" class="headerlink" title="4.9 replica:副本"></a>4.9 replica:副本</h4><p>在分布式环境下，任何一台机器都会随时宕机，如果宕机，index的一个分片没有，导致此index不能搜索。所以，为了保证数据的安全，我们会将每个index的分片进行备份，存储在另外的机器上。保证少数机器宕机es集群仍可以搜索。能正常提供查询和插入的分片我们叫做主分片(primary shard)，其 余的我们就管他们叫做备份的分片(replica shard)</p><h4 id="4-10-Mapping-映射"><a href="#4-10-Mapping-映射" class="headerlink" title="4.10 Mapping:映射"></a>4.10 Mapping:映射</h4><p>Mapping用于定义Index中的Document结构，包括Field名称、Field类型、分析器、数据格式等。Mapping的定义可以影响搜索和分析的性能。</p><h4 id="4-11-对比"><a href="#4-11-对比" class="headerlink" title="4.11 对比"></a>4.11 对比</h4><table><thead><tr><th>关系型数据库(比如Mysql)</th><th>非关系型数据库(Elasticsearch)</th></tr></thead><tbody><tr><td>数据库Database</td><td>索引Index</td></tr><tr><td>表Table</td><td>索引Index(原为Type)</td></tr><tr><td>数据行Row</td><td>文档Document</td></tr><tr><td>数据列Column</td><td>字段Field</td></tr><tr><td>约束 Schema</td><td>映射Mapping</td></tr></tbody></table><h2 id="三、核心原理"><a href="#三、核心原理" class="headerlink" title="三、核心原理"></a>三、核心原理</h2><h3 id="1-文件存储"><a href="#1-文件存储" class="headerlink" title="1.文件存储"></a>1.文件存储</h3><p>对应上面介绍的Document概念</p><p>ES是一个文档型数据库，在其中，一条数据就是一个文档，Json格式作为保存形式</p><p>将ES与MySql相关术语对应描述一条数据如下</p><p>一个 Elasticsearch 集群可以包含多个索引(数据库)，也就是说其中包含了很多类型(表)。这些类型中包含了很多的文档(行)，然后每个文档中又包含了很多的字段(列)</p><p>Elasticsearch的交互，可以使用 JavaAPI，也可以直接使用HTTP的Restful API方式</p><h3 id="2-倒排表与分类索引"><a href="#2-倒排表与分类索引" class="headerlink" title="2.倒排表与分类索引"></a>2.倒排表与分类索引</h3><p>在上面的介绍中，可以知道在ES中索引对应数据库中的dataBase</p><p>上面4.4介绍过索引的简历规则，这里不再赘述</p><p>那么在ES中，索引是以什么结构存在的呢？先别急，先看个例子，引入一下概念</p><p>假设有三条结构化数据，存储在MySql中，如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|ID  |Name    |Age    | Sex   | </span><br><span class="line">| -- |:------:| -----:| -----:| </span><br><span class="line">|1   |张三     |18     |Female </span><br><span class="line">|2   |李四     |50     |Male</span><br><span class="line">|3   |王五     |18     |Male</span><br></pre></td></tr></table></figure><p>那么这些数据，在ES当中是如何存储的呢？</p><p>首先是Name</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Term | Posting List |</span><br><span class="line">| -- |:----:|</span><br><span class="line">|张三 |1| </span><br><span class="line">|李四 |2| </span><br><span class="line">|王五 |3|</span><br></pre></td></tr></table></figure><p>Age</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Term | Posting List |</span><br><span class="line">| -- |:----:|</span><br><span class="line">| 50 | 2 |</span><br><span class="line">| 18 | [1,3]  |</span><br></pre></td></tr></table></figure><p>Sex</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Term   | Posting List |</span><br><span class="line">| --    |  :----:    |</span><br><span class="line">| Female |      1       |</span><br><span class="line">| Male   |    [2,3]     |</span><br></pre></td></tr></table></figure><p>可以观察到，上面出现了两个列概念Term和Posting List</p><ul><li><strong>Term：分类索引</strong><ul><li>分类索引则是按照文档的主题或类别来建立索引的数据结构</li></ul></li><li><strong>Posting List：倒排表</strong><ul><li>倒排表是根据文档中的单词或词语来建立索引的数据结构</li></ul></li></ul><blockquote><p>分类索引就是上面的分别根据Name，Age和Sex建立索引</p><p>倒排表就是每个分类索引里面实现的<strong>分词-ids</strong>的结构</p></blockquote><p>从上面的结构，可以论证之前说的，在ES中，倒排索引使用分词作为key，将key出现在的文档id集合作为values，这就是简化的索引结构</p><p>但是像MySql会出现的数据量过大问题一样，当上面的倒排表中，数据量过大怎么办？此时遍历扫描查询效率必然会受到极大的限制</p><h3 id="3-Term-Dictionary-词典"><a href="#3-Term-Dictionary-词典" class="headerlink" title="3.Term Dictionary(词典)"></a>3.<strong>Term Dictionary(词典)</strong></h3><p>在ES中，每个字段Field都有自己的一个词典结构，用于快速查找当中的term值</p><p>那么词典到底是什么呢？</p><p>就像上面的Name列，词典存储的就是”张三”、”李四”和”王五”这三个词条</p><p>除了词条本身，词典还会存储一些元数据信息，比如每个词条出现的文档频率（Document Frequency），即包含该词条的文档数目，以及倒排索引中的位置信息等</p><p>词典的具体实现方式由ES来决定，可选择哈希表、红黑树等数据结构</p><h3 id="4-Term-Index-词典索引）"><a href="#4-Term-Index-词典索引）" class="headerlink" title="4.Term Index(词典索引）"></a>4.<strong>Term Index(词典索引）</strong></h3><p>很明显，仅有词典还是不够的，因为当数据量上来之后，使用词典还是要全表扫描来找到词term，再去倒排表中找文档id，因此会考虑到去用索引结构加速term的查询</p><p>Term Index(词典索引）就是这个作用</p><p>那么如何实现词典索引呢？</p><p>主要分为基于树形的索引和基于哈希表的索引，此处主要介绍树形词典索引</p><img src="https://static-2w2.pages.dev/post/es-dict-index.png" alt="image-20230411135933867" style="zoom:50%;" /><p>索引树实现如上，它本质上是一颗前缀树，在树的节点中会存储词典的偏移量，从偏移量位置向后遍历，下面看一下他们的整体结构</p><img src="https://static-2w2.pages.dev/post/es-dic.png" alt="image-20230411151457452" style="zoom:50%;" /><p>用户查询时，先利用词典索引去词典中定位，再根据词典去倒排表中找到文档id</p><p>词典和倒排表可以存在内存中，也可以存储在磁盘中，上述样例是词典和倒排表都基于磁盘的存储，因为全部放在内存可能会占用空间过多</p><p>查找流程如下：</p><ul><li>用户输入c，根据词典索引，找到c，根据c上的偏移量offset找到词典位置</li><li>读取词典carl，找到对应的倒排表中的位置，从而查出来对应的文档编码</li></ul><p>为了加快访问速度，可以使词典索引存储在内存中，但是词典索引都放在内存中又会占用太多的空间，如何优化这个问题呢？</p><h3 id="5-FST"><a href="#5-FST" class="headerlink" title="5.FST"></a>5.FST</h3><p>FST，全称为finite state transducer，是一种有限状态自动机（finite state machine）的数据结构</p><p>FST 的基本思想是将一个有限状态自动机编码为一个紧凑的数据结构，并将其存储在内存中，以支持快速的查找和匹配操作。在 FST 中，每个状态都对应着一个整数编号，每个状态都可以转移到另一个状态，转移的过程可以使用一个字符或一组字符来触发。在实际的应用中，FST 还可以扩展为支持权重或成本，以支持更复杂的匹配操作</p><p>简单点说，FST就是用来<strong>压缩词典索引</strong>的，下面通过一个案例介绍FST实现思想</p><p>假设有以下字段和序号映射关系：</p><table><thead><tr><th align="center">字段</th><th align="center">序号</th></tr></thead><tbody><tr><td align="center">mop</td><td align="center">0</td></tr><tr><td align="center">moth</td><td align="center">1</td></tr><tr><td align="center">pop</td><td align="center">2</td></tr><tr><td align="center">star</td><td align="center">3</td></tr><tr><td align="center">stop</td><td align="center">4</td></tr><tr><td align="center">top</td><td align="center">5</td></tr></tbody></table><p>很明显，用Map结构可以存储这些对应关系，那么能不能对他们进行压缩，从而使用更少的空间来存储呢？</p><img src="https://static-2w2.pages.dev/post/es-fst.png" alt="image-20230411153455762" style="zoom:50%;" /><p>上图中，将单词拆分成单个字母，通过⭕和–&gt;表示出来</p><p>在–&gt;上，不显示表示权重为0</p><p>如果⭕后面出现分支，就标记权重，最后整条路径上的权重加起来就是这个单词对应的序号</p><p>例如stop，id就是3+0+1+0&#x3D;4</p><p>但是这个树并不会包含所有的term，而是很多term的前缀，通过这些前缀快速定位到这个前缀所属的磁盘的block，再从这个block去找文档列表</p><p>为了压缩词典的空间，实际上每个block都只会保存block 内不同的部分，比如 mop 和 moth 在同一个以 mo 开头的block，那么在对应的词典里面只会保存 p 和th ，这样空间利用率提高了一倍</p><p>早期的ES模糊查询使用编辑距离来计算，使用FST之后将模糊查询效率提升了100倍以上</p><p>现在词典索引已经被压缩，可以通过词典索引+词典找到倒排表位置，文档肯定是存储在磁盘上的，但是倒排表就直接原样放到磁盘上吗？这样会不会占用大量磁盘空间？</p><p>假如1亿个文档，每个文档有10个字段，那单倒排表就需要数十亿个integer空间，不太现实</p><h3 id="6-压缩-Frame-Of-Reference-索引帧"><a href="#6-压缩-Frame-Of-Reference-索引帧" class="headerlink" title="6.压缩-Frame Of Reference 索引帧"></a>6.压缩-Frame Of Reference 索引帧</h3><p>Frame Of Reference主要压缩的就是倒排表posting list</p><p>如果有上千万个同学，而世界上只有男&#x2F;女这样两个性别，每个posting list都会有至少百万个文档id。 Elasticsearch是如何有效的对这些文档id压缩的呢?</p><p>在进行查询的时候经常会进行组合查询，比如查询同时包含man和woman的文档，那么就需要分别查出包含这两个单词的文档的id，然后取这两个id列表的交集;如果是查包含man或者woman的文档， 那么就需要分别查出posting list然后取并集。为了能够高效的进行交集和并集的操作。为了方便压缩， Elasticsearch要求posting list是有序的(为了提高搜索的性能，再任性的要求也得满足)。同时为了减小存储空间，所有的id都会进行delta编码</p><p>举例</p><p>比如现在有id列表 [73, 300, 302, 332, 343, 372] ，转化成每一个id相对于前一个id的增量值(第 一个id的前一个id默认是0，增量就是它自己)列表是 [73, 227, 2, 30, 11, 29] 。在这个新的列表里面，所有的id都是小于255的，所以每个id只需要一个字节（8bit）存储</p><p>实际上ES会做的更加精细，它会把所有的文档分成很多个block，每个block正好包含256个文档，然后 单独对每个文档进行增量编码，计算出存储这个block里面所有文档最多需要多少位来保存每个id，并 且把这个位数作为头信息(header)放在每个block 的前面。这个技术叫Frame of Reference（索引帧）</p><img src="https://static-2w2.pages.dev/post/es-frame.png" alt="image-20230411155345684" style="zoom:50%;" /><blockquote><p>8个二进制位构成一个字节。这种压缩算法的原理就是通过增量，将原来的大数变成小数仅存储增 量值，再精打细算按bit排好队，最后通过字节存储，而不是大大咧咧的尽管是2也是用int(4个字 节)来存储</p></blockquote><p>在返回结果的时候，其实也并不需要把所有的数据直接解压然后一股脑全部返回，可以直接返回一个迭代器 iterator ，直接通过迭代器的 next 方法逐一取出压缩的id，这样也可以极大的节省计算和内存开销</p><p>通过以上的方式可以极大的节省posting list的空间消耗，提高查询性能。不过ES为了提高filter过滤器查询的性能，还做了更多的工作，那就是缓存</p><h3 id="7-缓存-Roaring-Bitmaps-咆哮位图"><a href="#7-缓存-Roaring-Bitmaps-咆哮位图" class="headerlink" title="7.缓存-Roaring Bitmaps 咆哮位图"></a>7.缓存-Roaring Bitmaps 咆哮位图</h3><p>ES会缓存频率比较高的filter查询，其中的原理也比较简单，即生成 (fitler, segment数据空间) 和id列表的映射，但是和倒排索引不同，我们只把常用的filter缓存下来而倒排索引是保存所有的，并且 filter缓存应该足够快，不然直接查询不就可以了。ES直接把缓存的filter放到内存里面，映射的posting list放入磁盘中</p><blockquote><p>ES在filter缓存使用的压缩方式和倒排索引的压缩方式并不相同，filter缓存使用了roaring bitmap的数 据结构，在查询的时候相对于上面的Frame of Reference方式CPU消耗要小，查询效率更高，代价就是需要的存储空间(磁盘)更多。</p><p>Roaring Bitmap是由int数组和bitmap这两个数据结构改良过的成果——int数组速度快但是空间消耗大，bitmap相对来说空间消耗小但是不管包含多少文档都需要12.5MB的空间，即使只有一个文件也要 12.5MB的空间，这样实在不划算，所以权衡之后就有了下面的Roaring Bitmap</p></blockquote><p>Bitmap是一种数据结构，假设有某个posting list: [1,3,4,7,10]<br>对应的bitmap就是:[1,0,1,1,0,0,1,0,0,1]<br>非常直观，用0&#x2F;1表示某个值是否存在，比如10这个值就对应第10位，对应的bit值是1，这样用一 个字节就可以代表8个文档id，旧版本(5.0之前)的Lucene就是用这样的方式来压缩的，但这样的压缩方式仍然不够高效，如果有1亿个文档，那么需要12.5MB的存储空间，这仅仅是对应一个索引字段(我们往往会有很多个索引字段)。于是有人想出了Roaring bitmaps这样更高效的数据结构<br>Bitmap的缺点是存储空间随着文档个数线性增长，Roaring bitmaps需要打破这个魔咒就一定要用到某些指数特性</p><ul><li>Roaring Bitmap首先会根据每个id的高16位分配id到对应的block里面，比如第一个block里面id应该都是在0到65535之间，第二个block的id在65536和131071之间</li><li>对于每一个block里面的数据，根据id数量分成两类<ul><li>如果数量小于4096，就是用short数组保存</li><li>数量大于等于4096，就使用bitmap保存</li></ul></li></ul><blockquote><p>即通过文档id的高16位散射到block上，block的结构则由散射过来的id数量决定</p></blockquote><img src="https://static-2w2.pages.dev/post/es-roaing-bitmap.png" alt="image-20230411160309030" style="zoom:50%;" /><blockquote><p>为什么选择4096作为分界线呢？</p><p>因为当数量小于4096的时候，如果用bitmap就需要8kB的空间，而使用2个字节 的数组空间消耗就要少一点。比如只有2048个值，每个值2字节，一共只需要4kB就能保存，但是 bitmap需要8kB</p></blockquote><h3 id="8-倒排索引实现联合索引"><a href="#8-倒排索引实现联合索引" class="headerlink" title="8.倒排索引实现联合索引"></a>8.倒排索引实现联合索引</h3><p>上面讨论的都是单个索引的流程，那么如何使用倒排索引做联合索引呢？</p><p>两种实现方式：跳表或者bitset</p><ul><li>利用跳表(Skip list)的数据结构快速做“与”运算</li><li>利用上面提到的bitset按位“与”</li></ul><p>首先是跳表，如下</p><img src="https://static-2w2.pages.dev/post/es-skiplist.png" alt="image-20230411160623631" style="zoom:50%;" /><p>将一个有序链表level0，挑出其中几个元素到level1及level2，每个level越往上，选出来的指针元素越少，查找时依次从高level往低查找，比如45，先找到level2的25，最后找到45，查找效率和2叉树的效率相当，但也是用了一定的空间冗余来换取的</p><p>假设有下面三个posting list需要联合索引:</p><img src="https://static-2w2.pages.dev/post/es-skip-index.png" alt="image-20230411160742751" style="zoom:50%;" /><p>如果使用跳表，对最短的posting list中的每个id，逐个在另外两个posting list中查找看是否存在，最后得到交集的结果</p><p>如果使用bitset(基于bitMap)，就很直观了，直接按位与，得到的结果就是最后的交集</p><blockquote><p>注意，这是倒排索引实现联合索引的方式，不是说ES就是这样操作的</p></blockquote><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>**Elasticsearch的索引思路:**将磁盘里的东西尽量搬进内存，减少磁盘随机读取次数(同时也利用磁盘顺序读特性)，结合各种奇技淫巧的压缩算法，用及其苛刻的态度使用内存</p><p>所以，对于使用Elasticsearch进行索引时需要注意:</p><ul><li>不需要索引的字段，一定要明确定义出来，因为默认是自动建索引的</li><li>同样的道理，对于String类型的字段，不需要analysis(分词)的也需要明确定义出来，因为默认也是会analysis的</li><li>选择有规律的ID很重要，随机性太大的ID(比如java的UUID)不利于查询</li></ul><p>关于最后一点，个人认为有多个因素:</p><ul><li>其中一个(也许不是最重要的)因素: 上面看到的压缩算法，都是对Posting list里的大量ID进行压缩的，那如果ID是顺序的，或者是有公共前缀等具有一定规律性的ID，压缩比会比较高;</li><li>另外一个因素: 可能是最影响查询性能的，应该是最后通过Posting list里的ID到磁盘中查找Document 信息的那步，因为Elasticsearch是分Segment存储的，根据ID这个大范围的Term定位到Segment的效率直接影响了最后查询的性能，如果ID是有规律的，可以快速跳过不包含该ID的Segment，从而减少不必要的磁盘读次数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis详解（三）redis场景与实战</title>
      <link href="/2023/03/16/redis%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/03/16/redis%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、场景问题"><a href="#一、场景问题" class="headerlink" title="一、场景问题"></a>一、场景问题</h3><h4 id="1-数据丢失场景"><a href="#1-数据丢失场景" class="headerlink" title="1.数据丢失场景"></a>1.数据丢失场景</h4><p>持久化数据丢失：</p><ul><li>RDB采用定时备份，有可能丢失间隔区间内的数据</li><li>AOF使用追加，也有可能丢失1s的数据</li></ul><p>主从切换：主从切换是异步的，必定会导致数据丢失</p><p>脑裂问题：出现多个master，网络恢复时丢失一些master上的数据</p><h4 id="2-跟数据库数据一致性问题"><a href="#2-跟数据库数据一致性问题" class="headerlink" title="2.跟数据库数据一致性问题"></a>2.跟数据库数据一致性问题</h4><p><strong>缓存一致性问题</strong>：mysql数据变更，如何保证redis的数据一致性呢？</p><p>常见的答案是<strong>延时双删</strong>，即先删redis，再该数据库，然后间隔一定时间再删redis</p><p>防止修改数据期间从redis读到不一致数据</p><p>但是实际上，这个间隔时间如何确定？工作中也基本上没有人用延时双删，因为redis本来就不是一个保证强一致性的数据库，它的优点在于快</p><p>所以最常见的方式，就是直接把redis的数据删除即可，下次查询数据库时再放进去就行了</p><p>常见数据一致性解决方案：</p><ul><li>加锁：牺牲性能，不建议使用</li><li>延时双删：间隔时间不好确定，不建议使用</li><li>最终一致性方案<ul><li>给缓存设置过期时间，允许一部分时间内的数据不一致</li><li>canal监听，在数据变更后同步修改redis数据</li></ul></li></ul><h4 id="3-缓存穿透、击穿、雪崩"><a href="#3-缓存穿透、击穿、雪崩" class="headerlink" title="3.缓存穿透、击穿、雪崩"></a>3.缓存穿透、击穿、雪崩</h4><h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h5><p>定义：查询的key，redis里面没有，db里面也没有</p><p>解决方案：</p><ul><li>封禁ip：如果某ip大量请求不存在的key，直接把这个ip干掉</li><li>布隆过滤器：不存在的一定无法经过布隆过滤器</li></ul><h5 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h5><p>定义：某热点key突然失效，全部请求都打到了db</p><p>解决方案：加互斥锁，不影响正常访问，但是过期后会加锁，防止大量请求到db</p><h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><p>定义：大量热点key同时失效</p><p>解决方案：</p><ul><li>保证redis高可用：防止出现redis挂了导致的缓存雪崩</li><li>设置不同的过期时间</li><li>加互斥锁：很少这么干</li></ul><blockquote><p>但是实际上，现在mysql也都是集群部署，崩不了</p></blockquote><h4 id="4-慢查询、阻塞和bigkey"><a href="#4-慢查询、阻塞和bigkey" class="headerlink" title="4.慢查询、阻塞和bigkey"></a>4.慢查询、阻塞和bigkey</h4><h5 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h5><p>所谓慢查询，就是很慢的查询-_-#</p><p>如何找到？</p><p>在默认配置中，超过10ms的查询就是慢查询（不包含网络时间）</p><p>会保存在慢查询日志当中，也可以通过监控工具进行监控，报警</p><p>如何解决？</p><p>拆分数据</p><h5 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h5><p>通常是指Redis服务器无法立即响应客户端请求的情况</p><p>可以通过业务日志，监控命令来判断阻塞原因</p><ul><li>外部原因：网络阻塞，cpu被占用</li><li>内部原因：<ul><li>指令查询耗时</li><li>数据结构设置不合理，导致查询过久</li><li>fork子线程在进行aof刷盘</li></ul></li></ul><h5 id="bigKey"><a href="#bigKey" class="headerlink" title="bigKey"></a>bigKey</h5><p>指一个key对应的value过大</p><p>可以采用拆分，压缩，分片等方式解决</p><ul><li>拆分：比如hash类型，可以将里面的键值对多拆分拆分，变成小一点的结构</li><li>压缩：采用一定的压缩算法，将数据规模变小，提高存储效率</li><li>分片：想办法把数据映射到不同哈希槽上，对key拆分，别都放到一起</li></ul><h3 id="二、实战"><a href="#二、实战" class="headerlink" title="二、实战"></a>二、实战</h3><h4 id="1-客户端选择"><a href="#1-客户端选择" class="headerlink" title="1.客户端选择"></a>1.客户端选择</h4><p>Jedis</p><ul><li>简单，使用较多</li><li>非线程安全</li><li>支持多种模式</li></ul><p>Lettuce</p><ul><li>线程安全</li><li>支持同步、异步</li><li>支持读写分离</li><li>支持多种模式</li></ul><p>Redission</p><ul><li>支持分布式锁</li><li>支持分布式容器等高级功能</li></ul><h4 id="2-实战之授权"><a href="#2-实战之授权" class="headerlink" title="2.实战之授权"></a>2.实战之授权</h4><p>存储分布式session</p><h4 id="3-实战之用户状态保存"><a href="#3-实战之用户状态保存" class="headerlink" title="3.实战之用户状态保存"></a>3.实战之用户状态保存</h4><p>使用bitmap数据结构，记录用户的一些状态，比如是否点过新人引导，是否领过优惠券，使用0&#x2F;1表示即可，状态不可逆，以用户为粒度进行读写</p><p>同时，mysql里面也要有一个bigint的结构与其对应，保证最终一致性</p><h4 id="4-实战之流量限制"><a href="#4-实战之流量限制" class="headerlink" title="4.实战之流量限制"></a>4.实战之流量限制</h4><p>限流基本概念：</p><ul><li>对访问频率的限制</li><li>对连接数的限制</li><li>对客户端的限制</li><li>对速率的限制</li></ul><p>限流常用算法：</p><ul><li>时间窗算法：设定一段时间内的请求次数上限来进行限流的</li><li>漏桶算法：桶大小固定，出桶速度固定，可能会溢出</li><li>令牌桶算法：能在短时间内处理大量请求<ul><li>桶里最多x个令牌，因此同时最多能支持x个取令牌操作</li><li>有一个线程检测桶里令牌是否低于x，是的话就定时产生令牌放桶里</li><li>拿走令牌的线程也可以在任务处理完毕后，在桶里令牌不到x时放回去</li></ul></li></ul><p>在分布式系统中，可以使用令牌桶算法，使用redis搭配搭配网关gateWay，来进行分布式系统限流</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis详解（二）redis高可用方案</title>
      <link href="/2023/03/06/redis%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/03/06/redis%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、持久化"><a href="#一、持久化" class="headerlink" title="一、持久化"></a>一、持久化</h2><p>为什么要持久化？</p><p>由于redis数据都是保存在内存中的，那么如果遇到断电等问题，没有持久化就会导致所有数据都丢失，这是很严重的问题，因此要对redis进行持久化</p><h3 id="1-RDB快照"><a href="#1-RDB快照" class="headerlink" title="1.RDB快照"></a>1.RDB快照</h3><p>RDB 是 Redis 默认的持久化方案。RDB快照(Redis Database)，当满足 一定条件的时候，会把当前内存中的数据写入磁盘，生成一个快照文件</p><p><strong>什么时候触发呢？</strong></p><p>可以分为自动触发与手动触发</p><h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a><strong>自动触发</strong></h4><ul><li>配置触发，即间隔一定时间备份一次</li><li>shutdown正常关闭</li><li>flushall指令触发</li></ul><h4 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a><strong>手动触发</strong></h4><ul><li>save：主线程去进行备份，备份期间不会去处理其他指令，其他指令必须等待</li><li>bgsave：fork一个子线程去进行备份</li></ul><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h4><ul><li>快</li><li>做备份，恢复快，是非常紧凑的文件<ul><li>新起子线程，子线程会将当前Redis的数据写入一个临时文件 </li><li>当临时文件写完成后，会替换旧的RDB文件</li></ul></li><li>主线程指令操作不需要跟磁盘进行任何交互</li></ul><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a><strong>劣势</strong></h4><ul><li>安全性很低，可能会有数据丢失</li><li>fork子线程可能特别耗时，cpu不友好</li></ul><h3 id="2-AOF追加"><a href="#2-AOF追加" class="headerlink" title="2.AOF追加"></a>2.AOF追加</h3><p>由于RDB的数据可靠性非常低，所以Redis又提供了另外一种持久化方案: Append Only File 简称:AOF，默认关闭，可以配置开启</p><p>那么问题来了，AOF是采用追加的方式实现的，那么它如何追加呢？每条命令都追加吗？</p><p>事实上，AOF有三种磁盘交互策略</p><ul><li>appendfsync always：表示每次写入都要执行fsync（刷新）函数，性能非常慢，但是非常安全</li><li>appendfsync everysec：表示每秒执行一次fsync函数，突然断电可能丢失1s数据</li><li>appendfsync no：由操作系统保证数据同步到磁盘，速度最快</li></ul><h4 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a><strong>重写机制</strong></h4><p>为何要进行重写呢？</p><p>由于AOF是追加的形式，所以文件会越来越大，越大的话，数据加载越慢。 所以需要对AOF文件进行重写</p><p>重写流程有两个版本，这里仅介绍redis7.0之前的</p><ul><li>Redis fork一个子进程，在一个临时文件中写入新的AOF (当前内存的数据生成的新的AOF)</li><li>那么在写入新的AOF的时候，主进程还会有指令进入，那么主进程会在内存缓存区中累计新的指令 (但是同时也会写在旧的AOF文件中，就算重写失败，也不会导致AOF损坏或者数据丢失)</li><li>如果子进程重写完成，父进程会收到完成信号，并且把内存缓存中的指令追加到新的AOF文件中</li><li>替换旧的AOF文件 ，并且将新的指令附加到重写好的AOF文件中。</li></ul><p>但是这种仅使用AOF重写方式存在一个问题，那就是如果当前数据非常大，那么执行效果会很慢，因此可以采用RDB的方式生成新的AOF文件，再用AOF去新文件末尾追加后续指令</p><blockquote><p>何时重写？</p><p>可以配置一个百分比与阈值共同控制</p></blockquote><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul><li>安全性高，就算默认的持久化同步机制，也最多只会导致1s丢失 </li><li>AOF由于某些原因，比如磁盘满了等导致追加失败，也能通过redis-check-aof 工具来修复</li><li>格式都是追加的日志，所以可读性更高</li></ul><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul><li>数据集一般比RDB大</li><li>持久化跟数据加载比RDB更慢</li><li>在7.0之前，重写的时候，因为重写的时候，新的指令会缓存在内存 区，所以会导致大量的内存使用</li><li>并且重写期间，会跟磁盘进行2次IO，一个是写入老的AOF文件，一个 是写入新的AOF文件</li></ul><h2 id="二、集群"><a href="#二、集群" class="headerlink" title="二、集群"></a>二、集群</h2><h3 id="1-Redis主从"><a href="#1-Redis主从" class="headerlink" title="1.Redis主从"></a>1.Redis主从</h3><p><strong>为什么要有主从?</strong></p><ul><li>故障恢复：主挂了或者数据丢失了，从还会有数据冗余</li><li>负载均衡，流量分发，可以主写，从库读，减少单实例的读写压力</li><li>高可用：集群等，都是基于主从去实现的</li></ul><h4 id="1）主从数据同步"><a href="#1）主从数据同步" class="headerlink" title="1）主从数据同步"></a>1）主从数据同步</h4><ul><li>相互之间会建立连接 保存地址 端口等信息</li><li>加入从第一次成为slave，发送数据同步指令</li><li>master收到后比较repid（判断是否同步过）</li><li>不一致或为空，触发全量同步<ul><li>master使用bgsave生成rdb文件，然后把rdb发给slave，同时把自己repid&#x2F;offert给slave</li><li>生成新的rdb期间，会有新的指令，把这些指令放到一个内存</li><li>3.rdb同步完了之后，会把这些新指令也同步过去</li></ul></li><li>假如只是中间断开过，则重新同步，使用增量同步<ul><li>master发现repid符合，则去找这个slave还有哪些没有同步</li><li>offert上次偏移量即可找到上次同步位置</li><li>回去积压缓存那里去找是否有同步记录，找不到的话就全量同步</li></ul></li></ul><blockquote><p>发生主从切换，一定会有数据丢失<br>因为同步是异步的，切换主从的话主数据一定会丢失</p></blockquote><h3 id="2-Redis-sentinel哨兵"><a href="#2-Redis-sentinel哨兵" class="headerlink" title="2.Redis sentinel哨兵"></a>2.Redis sentinel哨兵</h3><p>主从虽然解决了比如负载、数据备份等问题</p><p>但是当master挂了之后，slave是不会直接升级为主，必须手动把slave升级为主</p><p>master挂了后，slave只是状态变更为down，会导致所有服务不可用</p><p>因此出现了哨兵模式来解决这个问题，当一个master挂了之后，能够通过哨兵自动选择出来一个master</p><blockquote><p>官网上哨兵介绍</p><p>Redis sentinel在<strong>不适用Cluster集群</strong>的时候，为Redis提供了高可用性。</p><p>并且提供了监测、通知、自动故障转移、配置提供等功能。</p><p><strong>监控</strong>:能够监控我的Redis各实例是否正常工作</p><p><strong>通知</strong>:如果Redis的实例出现问题，能够通知给其他实例以及sentinel</p><p><strong>自动故障转移</strong>:当我的master宕机，slave可以自动升级为master</p><p><strong>配置提供</strong>:sentinel可以提供Redis的master实例地址，那么客户端只需要 跟sentinel进行连接，master挂了后会提供新的master</p></blockquote><p>需要注意，哨兵机器需要单独设置，哨兵需要独立的服务器来运行，它们不应该与Redis实例运行在同一台机器上，这是为了保证当机器发生故障时，哨兵仍然能够继续运行并监控Redis集群的状态</p><p>哨兵能够实现自动故障转移，主要包括<strong>发现故障</strong>与<strong>故障转移</strong>两个步骤</p><h4 id="1）发现故障"><a href="#1）发现故障" class="headerlink" title="1）发现故障"></a>1）发现故障</h4><ul><li>某哨兵在一定时间内收不到master的回应，该哨兵认为主节点挂了，因此会标记一个主观下线</li><li>询问其他的sentinel，去跟master ping，如果超过quornum（配置的参数）的sentinel认为master挂了，那么就标记为ODwon（客观下线）</li></ul><h4 id="2）故障转移"><a href="#2）故障转移" class="headerlink" title="2）故障转移"></a>2）故障转移</h4><p>客观下线状态，选举一个sentinel去触发故障转移，此时其他sentibel不能触发故障转移</p><ul><li>如果配置的quornum小于等于一半，那么必须超过半数的sentinel授权，才能成为master</li><li>如果quornum超过一半，那么就要quornum数量的授权</li></ul><p>如何选举哪一个slaver为master呢？</p><ul><li>断开时间：超过一定时间失去资格</li><li>优先级slaver_priority：越小优先级越高，但是到0失去资格</li><li>根据slave赋值的偏移量offerset，数据最新的直接升级为master</li><li>RunID—实例启动时配置的唯一id</li></ul><h4 id="3）数据一致性问题"><a href="#3）数据一致性问题" class="headerlink" title="3）数据一致性问题"></a>3）数据一致性问题</h4><p>官方建议最少配置3个sentinel</p><p>原因：</p><p>如果只有1个sentinel实例，则这个实例挂了就不能保证sentinel的高可用性</p><p>如果只有2个sentinel实例，且只有一主一从，quorum&#x3D;1，那么因为网络问题，哨兵和mastre之间断网了，在这期间slave可能被选为master，从而出现两个master与客户端通信，当网络恢复时，一个master会被干掉，恢复成slave，这时它作为master接收的数据都会丢失</p><p>这也就是所谓的<strong>脑裂问题</strong></p><p><strong>指的是当主节点和哨兵节点之间网络分区后，可能导致多个哨兵节点同时将从节点提升为主节点，从而导致主从数据不一致的问题</strong></p><p>脑裂问题解决方案：</p><ul><li>min-replicas-to-write 1：配置至少有 1 个从节点，才能执行写操作。这样可以确保主节点挂掉时，还有至少一个从节点可以接替成为新的主节点，并保证集群数据不会丢失。</li><li>min-replicas-max-lag 10：配置从节点和主节点的数据同步最大延迟时间为 10 秒。如果有某个从节点的数据同步延迟超过了 10 秒，那么就不再允许该从节点成为新的主节点，以防止数据不一致的情况发生。</li></ul><p>这两个配置可以结合使用，保证 Redis 集群在发生主节点故障时，可以自动选举出新的主节点，并且选举出的节点能够保证数据一致性</p><h3 id="3-集群-cluster"><a href="#3-集群-cluster" class="headerlink" title="3.集群 cluster"></a>3.集群 cluster</h3><p>sentinel提供了比如监控、自动故障转移、客户端配置等高可用的 方案，但是没有分片功能。<br>何为分片:就是希望把数据分布到不同的节点。这样如果某些节点异常，其他数据能正常提供服务，跟微服务的思想很相似</p><blockquote><p>官网上介绍cluster提供的功能</p><p>1.多个节点之间的数据拆分，也就是数据分片</p><p>2.当某些节点遇到故障的时候，其他节点还能继续服务</p></blockquote><h4 id="1）hash-solt-虚拟槽"><a href="#1）hash-solt-虚拟槽" class="headerlink" title="1）hash solt 虚拟槽"></a>1）hash solt 虚拟槽</h4><p>如何分片？</p><p>分片就是把不同的数据放到不同的位置，相当于分表，不同的数据放到不同的表里</p><p>在Redis里面，采用的是虚拟槽的概念，就是在redis cluster里面有16384个虚拟节点，存储数据时就往这些节点里面映射，而这些节点由不同的机器负责，由此也就实现了数据的分片存储；后续这些数据跟槽的关系也不会变更，只会随着槽的负责机器不同而到不同的机器上</p><p>那么如何映射到虚拟槽呢？</p><p>计算公式：slot &#x3D; CRC16(key) &amp; 16383</p><blockquote><p>如果想把相关key放入一个虚拟槽,也就是一个实例节点，可以采用{},那么就只会根据{}里面的内容计算hash槽! 比如:<br>zhangsan{18} 跟 lisi{18} 就会在一个虚拟槽</p></blockquote><h4 id="2）部署"><a href="#2）部署" class="headerlink" title="2）部署"></a>2）部署</h4><p>cluster模式下，最少三主三从</p><p>如何把key放到真实节点呢？可以通过命令为不同的主机分配不同范围的槽</p><p>比如三主三从时，可以让master按照如下范围负责虚拟槽</p><p>master1 0-5460虚拟槽<br>master2 5461-10922虚拟槽<br>master3 10923-16383虚拟槽</p><p>这样，每次扩容与缩容，只要改变节点跟虚拟槽之间的关系即可</p><h4 id="3）为什么槽数量是16384？"><a href="#3）为什么槽数量是16384？" class="headerlink" title="3）为什么槽数量是16384？"></a>3）为什么槽数量是16384？</h4><ul><li>16384个槽已经能够满足大多数使用情况了</li><li>16384个槽正好使用2k空间能够表示，再大的话就可能会带来资源的浪费</li></ul><blockquote><p>实际上，有参数可以修改这个值，但是一般不建议修改</p></blockquote><p>扩展：</p><p>由于虚拟槽机制，可以做数据的冷热分离，把一些热数据放到相邻的槽上，从而使他们位于固定的几台机器上，可以特意开几台性能好的机器专门处理这些热数据</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis详解（一）redis基础</title>
      <link href="/2023/02/24/redis%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/02/24/redis%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p><strong>1.为何要有redis？只用mysql不行吗？</strong></p><p>因为mysql为了保证数据安全性，所以每次交互都要落盘，即与磁盘进行交互</p><p>众所周知，磁盘访问的速度是很慢的，所以mysql这种方式极大的限制了高并发与高速访问的速度</p><p><strong>2.那么redis为什么能做到那么快呢？</strong><br>因为mysql是与磁盘进行交互所以比较慢，所以redis就将操作都在内存中进行，所以它是一个内存型数据库，由此使得redis速度很快，此外还有一些其他措施保证redis速度，如下</p><ul><li>它是一个内存型数据库：所以访问不需要与磁盘进行交互，内存会快很多</li><li>它使用单线程进行操作：减少了上下文切换等消耗</li><li>它使用了IO多路复用技术：极大的提升了单线程的速度<ul><li>Redis 2.x版本使用的是select。</li><li>Redis 3.x版本开始引入了Epoll，并在Redis 4.x版本中成为默认的IO多路复用机制。</li><li>Redis 6.x版本中新增了IOCP支持，并在Windows平台上成为默认的IO多路复用机制。</li></ul></li><li>它本身是Key-value结构：类似hashmap，访问速度接近O(1)</li><li>底层数据结构：跳表，sds等采用了空间换时间的思路</li></ul><p><strong>3.CAP理论</strong></p><p>CAP 理论是指在分布式系统中，不可能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）这三个特性，最多只能同时满足其中两个</p><p>redis本质上是一个AP模型，即更加重视可用性和分区容错性，对于一致性要求并不是那么高，因此它的速度在一定程度上也是牺牲一致性来换取的</p><blockquote><p>由此也可以得知，对于数据一致性要求高的场景，就尽量不要选用redis，因为它的优点是快，并不追求数据一致性，如果放到强一致性的场景，并不适合使用redis</p></blockquote><h3 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h3><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><h5 id="1-dict-字典"><a href="#1-dict-字典" class="headerlink" title="1.dict 字典"></a>1.dict 字典</h5><p>redis底层数据结构之一，两种基础数据类型hash和zset底层都有采用这种数据结构</p><p>首先看下server.h中，最外层结构redisDb的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                     <span class="comment">// 数据库键值对存储的哈希表</span></span><br><span class="line">    dict *expires;                  <span class="comment">// 记录键的过期时间的哈希表</span></span><br><span class="line">    dict *blocking_keys;            <span class="comment">// 阻塞客户端的键的哈希表</span></span><br><span class="line">    dict *ready_keys;               <span class="comment">// 可读键的哈希表</span></span><br><span class="line">    dict *watched_keys;             <span class="comment">// 被监视的键的哈希表</span></span><br><span class="line">    <span class="type">int</span> id;                         <span class="comment">// 数据库 ID</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> avg_ttl;              <span class="comment">// 平均 TTL</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> expires_cursor;  <span class="comment">// 上一次检查键的过期时间的游标</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;             <span class="comment">// 要在之后进行内存碎片整理的键列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisMemOverhead</span> *<span class="title">mem_overhead</span>;</span>  <span class="comment">// 内存使用情况的统计信息</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>由上面代码，可见其大量用到了dict的数据结构，它是存储在dict.h文件中定义的数据结果，称为字典，下面是字典数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;     <span class="comment">// 哈希表类型，定义了一组用于操作哈希表的函数指针</span></span><br><span class="line">    <span class="type">void</span> *privdata;     <span class="comment">// 私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];       <span class="comment">// 两个哈希表，通常只使用其中一个，另一个用于重建或扩展</span></span><br><span class="line">    <span class="type">long</span> rehashidx;     <span class="comment">// 哈希表扩展或重建时，rehashidx 表示已经处理的桶的数量</span></span><br><span class="line">    <span class="type">int</span> iterators;      <span class="comment">// 迭代器的数量</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>这里用到了dictht结构的哈希表，它也在dict.h文件中定义，那它的结构是怎样的呢？如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;              <span class="comment">// 哈希表数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;             <span class="comment">// 哈希表桶数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;         <span class="comment">// 哈希表大小掩码，用于计算哈希值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;             <span class="comment">// 键值对的数量</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>再看一下同样在dict.h文件中定义的dictEntry结构，它是类似hashmap的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;                      <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;                  <span class="comment">// 值</span></span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>         <span class="comment">// 指向下一个哈希表节</span></span><br></pre></td></tr></table></figure><p>redisObject结构如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:<span class="number">4</span>;                <span class="comment">// 类型，占用 4 个比特位</span></span><br><span class="line">    unsigned encoding:<span class="number">4</span>;            <span class="comment">// 编码方式，占用 4 个比特位</span></span><br><span class="line">    unsigned lru:LRU_BITS;          <span class="comment">// LRU 时间，占用 LRU_BITS 个比特位</span></span><br><span class="line">    <span class="type">int</span> refcount;                   <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;                      <span class="comment">// 指向实际值的指针</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>看了那么多数据结构，那么他们的关系是怎样的呢？参考下图</p><p><img src="https://static-2w2.pages.dev/post/dict.jpeg" alt="dict"></p><p>则由上面定义与关系图，可总结字典结构的一些数据结构关系如下：</p><ul><li><code>redisDb</code> 包含了所有 Redis 数据库的状态，每个数据库通过 <code>dict</code> 实现一个键值对的哈希表。</li><li><code>dict</code> 是 Redis 的哈希表实现，内部使用 <code>dictht</code> 结构体实现哈希表，<code>dictEntry</code> 结构体表示哈希表中一个键值对。</li><li><code>redisObject</code> 是 Redis 中非常重要的一个结构体，用于表示 Redis 中的所有数据对象，包括字符串、列表、哈希、集合等等。<code>redisObject</code> 包含了该对象的类型、编码方式、引用计数等信息，以及指向实际值的指针</li></ul><p>h[0]是正常情况下用来存储数据的数据结构，h[1]是扩容时使用的临时空间</p><p>dictEntry构成一个table表存储在h[0]当中，每个位置由链表结构组成</p><p>整体结构类似java集合中的hashMap结构，即数组+链表</p><p>只是要注意，链表的每个节点中存储的value使用redisObject结构，这个结构类型通过type来指明</p><p>链表部分，使用头插法插入新数据，因为redis是单线程操作，所以不怕出现死链情况</p><p>头插就可以免去遍历到链表结尾的过程了</p><h5 id="2-字典扩容"><a href="#2-字典扩容" class="headerlink" title="2.字典扩容"></a>2.字典扩容</h5><p><strong>1）扩容时机</strong></p><p>注意，在上面的dictht结构中</p><p>used参数，用来标识已经使用的桶数量</p><p>size参数，表示已经存储的键值对数量</p><p>因此扩容时机就是依据这两个参数来判断</p><ul><li>无子进程在fork刷盘时，used  &gt;&#x3D; size 的时候 进行扩容</li><li>有子进程在刷盘时，要used  &gt;&#x3D; size * 5</li></ul><p>之所以这样设计，是为了使得资源合理利用</p><p><strong>2）扩容流程</strong></p><p>在早期的redis3.x及以前，扩容数组大小是直接取h[0].size * 2，类似hashMap中的扩容机制</p><p>但是在redis4.0及之后，为了更高效的扩容，采用了渐进式迁移的方式，因此扩容大小也修改成了新数组为ht[0].used * 2向上取2的幂，下面是扩容流程</p><ul><li><strong>判断是否扩容：</strong>当满足我扩容条件，触发扩容时，判断是否在扩容，如果在扩容，或者 扩容的大小跟我现在的ht[0].size一样，这次扩容不做。</li><li><strong>new新数组：</strong>new一个新的dictht，大小为ht[0].used * 2(但是必须向上2的幂，比如6 ，那么大小为8) ，并且ht[1]&#x3D;新创建的dictht。</li><li><strong>渐进式数据迁移：</strong>我们有个更大的table了，但是需要把数据迁移到ht[1].table ，所以将 dict的rehashidx(数据迁移的偏移量)赋值为0 ，代表可以进行数据迁移了，也就是可以rehash了。</li><li><strong>数组指向修改：</strong>等待数据迁移完成，数据不会马上迁移，而是采用渐进式rehash，慢慢的把数据迁移到ht[1]</li><li>当数据迁移完成，ht[0].table&#x3D;ht[1] ，ht[1] .table &#x3D; NULL、ht[1] .size &#x3D; 0、ht[1] .sizemask &#x3D; 0、 ht[1] .used &#x3D; 0;</li><li>把dict的rehashidex&#x3D;-1</li></ul><h5 id="3-渐进式迁移"><a href="#3-渐进式迁移" class="headerlink" title="3.渐进式迁移"></a>3.渐进式迁移</h5><p><strong>思考：</strong>为什么会出现渐进式数据迁移呢？</p><p>假如一次性把数据迁移会很耗时间，会让单条指令等待很久很久，会形成阻塞<br>所以，Redis采用的是渐进式Rehash,所谓渐进式，就是慢慢的，不会一次性把所有数据迁移</p><p>那么，什么时候会触发迁移呢？又是如何迁移的？</p><ul><li>每次进行key的crud操作都会进行一个hash桶的数据迁移</li><li>定时任务，进行部分数据迁移</li></ul><p><strong>1）crud触发迁移</strong></p><p>在源码中，每次增删改都会触发**_dictRehashStep**方法，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个代码在增删改查的方法中都会调用</span></span><br><span class="line"><span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br></pre></td></tr></table></figure><p>_dictRehashStep里面调用了dictRehash</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _dictRehashStep(dict *d)&#123;</span><br><span class="line">  <span class="keyword">if</span>(d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看看dictRehash</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果已经完成了rehash，则直接退出 */</span></span><br><span class="line">        <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 如果有正在进行的 AOF 重写，那么可以在重写过程中进行异步重hash操作，</span></span><br><span class="line"><span class="comment">             * 这样就不会阻塞主线程的操作。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (dictIsRehashing(d))</span><br><span class="line">                <span class="comment">/* 异步地执行字典的 rehash 操作 */</span></span><br><span class="line">                dictRehashMilliseconds(d, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从ht[0]表中选择一个非空的bucket */</span></span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) d-&gt;rehashidx++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 获取bucket中的第一个元素 */</span></span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="type">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 保存下一个元素的地址，防止在rehash的过程中被删除 */</span></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 计算元素在ht[1]表中的索引值 */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 插入元素到ht[1]表的bucket中 */</span></span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 更新ht[0]表的元素数量 */</span></span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 更新ht[1]表的元素数量 */</span></span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 处理下一个元素 */</span></span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 释放这个bucket */</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 更新rehash进度 */</span></span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果已经完成了rehash，则释放ht[0]表，将ht[1]表设置为ht[0]表 */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dictRehash是Redis中扩容哈希表的过程，它会将原哈希表ht[0]中的所有元素重新计算哈希值并移动到新哈希表ht[1]中对应的位置。</p><p>通过这种方式，可以避免扩容过程中的数据丢失，同时也保证了扩容操作的高效性和可扩展性。</p><p>在rehash操作过程中，为了避免耗时过长而造成服务不可用，Redis会将操作分批进行，并交给事件循环处理。</p><p><strong>2）定时处理</strong></p><p>配置文件中可以修改多久执行一次定时任务</p><p>下面是定时任务流程，不再看源码</p><ul><li><strong>选任务：</strong>Redis定时从任务队列中选取一定数量的任务。</li><li><strong>算权重：</strong>对于每个选中的任务，计算出任务的执行权重。</li><li><strong>排序：</strong>根据权重排序，选出最高的一批任务进行执行。</li><li><strong>迁移：</strong>执行任务时将需要迁移的键的数据从源节点迁移到目标节点。</li><li><strong>同步：</strong>迁移过程中会进行增量同步，确保数据的一致性。</li><li><strong>删除：</strong>迁移完成后，源节点上的键会被删除。</li><li>执行完一批任务后，如果任务队列中还有剩余的任务，则返回第二步，继续选取任务进行执行。</li><li>如果任务队列中没有剩余任务，则等待一定时间后再次从任务队列中选取任务。</li></ul><blockquote><p>数据量较大时，hash和set的底层结构都采用的dictht</p></blockquote><h4 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h4><h5 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度，即 SDS 存储的字符串的长度</span></span><br><span class="line">    <span class="comment">// 注意这里的长度是指字符串的长度，不包括结尾的空字符 &#x27;\0&#x27;</span></span><br><span class="line">    <span class="comment">// 实际占用空间为 len + 1</span></span><br><span class="line">    <span class="comment">// 如果 SDS 用于存储二进制数据，那么 len 就表示 buf 中已占用空间的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 中未使用的空间的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存字符串数据的数组</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SDS可以看作是一个可以支持动态扩容的数组结构</p><h5 id="2-扩容与缩容"><a href="#2-扩容与缩容" class="headerlink" title="2.扩容与缩容"></a>2.扩容与缩容</h5><p>SDS使用空间预分配和惰性空间释放的方式，可以避免频繁的内存分配和释放，从而提高了内存的利用率，减少了内存碎片的产生</p><p><strong>1）空间预分配</strong></p><p>在SDS扩容时，预先分配一定量的额外空间，避免频繁的内存重新分配操作</p><p>SDS长度如果小于1MB，预分配跟长度一样的，大于1M,每次跟len的大小多1M</p><p><strong>2）惰性空间释放</strong></p><p>当SDS的长度缩短时，并不立即释放多余的空间，而是等待下一次扩容时再进行释放</p><blockquote><p>五种基本数据类型之中，String在数据量不大时底层采用SDS实现，数据量大了采用字节数组实现</p></blockquote><h4 id="压缩列表-ziplist"><a href="#压缩列表-ziplist" class="headerlink" title="压缩列表 ziplist"></a>压缩列表 ziplist</h4><p><strong>压缩列表（ziplist）</strong>是 Redis 内部使用的一种紧凑的、列表式数据结构。它可以存储多个键值对，每个键值对占用一段连续的内存空间，且支持在列表的两端进行高效的插入和删除操作</p><p>压缩列表会根据存入的数据的不同类型以及不同大小，分配不同大小的空间。所以是为了节省内存而采用的。因为是一块完整的内存空间，当里面的元素发生变更时，会产生连锁更<br>新，严重影响我们的访问性能。所以，只适用于数据量比较小的场景</p><blockquote><p>在redis之中，<strong>list</strong>，<strong>set</strong>和<strong>zset</strong>在数据量不大并满足一定条件时，都会采用压缩链表作为存储结构</p></blockquote><p>例如hash类型，当hash对象同时满足以下两个条件的时候，使用ziplist编码:</p><ul><li>哈希对象保存的键值对数量&lt;512个</li><li>所有的键值对的健和值的字符串长度都&lt;64byte(一个英文字母一个字节)</li></ul><h4 id="快速列表-quicklist"><a href="#快速列表-quicklist" class="headerlink" title="快速列表 quicklist"></a>快速列表 quicklist</h4><p><strong>快速列表（quicklist）</strong>是 Redis 中用于实现列表类型的一种数据结构，它是一种紧凑的、节约内存的、压缩列表的变种。</p><p>快速列表可以保存多个元素，并且每个元素可以是不同的类型。快速列表的结构非常紧凑，可以大大减少存储空间的占用。</p><p>把连锁更新的连续块儿，拆成了node节点，连成链表，即双向链表节点里面会持有一个ziplist；本质上还是用了ziplist；多少个ziplist拼成一个node可在配置文件中配置</p><p>所以一定程度上可解决连锁更新的问题</p><p>整体结构图如下</p><p><img src="https://static-2w2.pages.dev/post/quicklist.png" alt="image-20230406193140330"></p><h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p><strong>跳表（Skip List）</strong>是一种随机化数据结构，可以用来实现有序的数据集合，也可以用来加速查找操作。Redis中的有序集合（Sorted Set）就是通过跳表实现的</p><p>数据结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 跳表节点结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 后退指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">    &#125; level[];</span><br><span class="line">    <span class="comment">// 分值 排序使用</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 最大层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>本质上就是通过设置不同层level来构建不同层级的索引，通过索引加速查询</p><p>图解</p><p><img src="https://static-2w2.pages.dev/post/skiplist.png" alt="image-20230406195140282"></p><h3 id="三、基础数据类型"><a href="#三、基础数据类型" class="headerlink" title="三、基础数据类型"></a>三、基础数据类型</h3><h4 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h4><p><strong>实现：</strong></p><p>在数据量较小时，使用SDS实现</p><p>数据量较大则采用字节数组实现</p><p><strong>适用场景：</strong></p><ul><li>缓存</li><li>全局id</li><li>计数器</li><li>限流<ul><li>用一个值记录访问次数，达到就实现限流方案，也算是计数器变种</li></ul></li></ul><h4 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h4><p><strong>实现：</strong></p><p>数据量较小时，使用ziplist实现</p><p>数据量较大时，使用dictht实现</p><p><strong>适用场景：</strong></p><p>适合存储对象等结构化数据</p><h4 id="3-List"><a href="#3-List" class="headerlink" title="3.List"></a>3.List</h4><p><strong>实现：</strong></p><p>数据量较小时，使用ziplist实现</p><p>数据量较大时，使用quicklist实现</p><p><strong>适用场景：</strong></p><ul><li>分布式队列</li><li>消息队列</li><li>异步消息通知</li></ul><h4 id="4-Set"><a href="#4-Set" class="headerlink" title="4.Set"></a>4.Set</h4><p><strong>实现：</strong></p><p>数据量较小时，使用ziplist实现</p><p>数据量较大时，使用dictht实现，只用key不用value，类似Java的Set</p><p><strong>适用场景：</strong></p><p>适用于存储不重复的数据，如用户ID、IP地址、标签等</p><h4 id="5-ZSet"><a href="#5-ZSet" class="headerlink" title="5.ZSet"></a>5.ZSet</h4><blockquote><p>它的排序是通过每个数据携带一个score来实现的</p></blockquote><p><strong>实现：</strong></p><p>数据量较小时，使用ziplist实现</p><p>数据量较大时，使用skiplist实现</p><p><strong>适用场景：</strong></p><p>适用于按照分数排序的数据，如排行榜、优先级队列等</p><h3 id="四、内存管理"><a href="#四、内存管理" class="headerlink" title="四、内存管理"></a>四、内存管理</h3><p>要区分什么是过期策略，什么是淘汰策略</p><h4 id="1-过期策略"><a href="#1-过期策略" class="headerlink" title="1.过期策略"></a>1.过期策略</h4><p>为了保证内存的利用率，会把过期数据进行删除，删除设置了过期时间，并且到期的数据</p><p><strong>1）惰性过期</strong></p><p>要用的时候，会判断是否过期</p><p>缺点是脏数据一直占据内存，很不友好</p><p><strong>2）定期清理</strong></p><ul><li>去设置了过期时间的key里面拿</li><li>以hash桶为维度，扫到20个为止最多拿400个空桶</li><li>找到里面过期的key，进行删除</li><li>过期的比例超过10，就再次扫描</li><li>最多扫描16次，超次截止</li></ul><blockquote><p>所以，过期策略就是怎样淘汰那些设置了过期时间的过期数据</p></blockquote><p>这里有一个面试题，就是当redis大量key同时过期，会导致什么情况？</p><p>想问的是当大量key同时过期，主线程会一直在扫描这些key进行过期处理，导致主线程阻塞</p><p>解决方案：</p><ul><li>设置过期时间时，将过期时间分散开来</li><li>通过参数配置，减少主线程的扫描时间</li></ul><h4 id="2-淘汰策略"><a href="#2-淘汰策略" class="headerlink" title="2.淘汰策略"></a>2.淘汰策略</h4><p>假设没有设置过期时间，或者设置的过期时间没到期，但是内存满了，内存里面的数据都是有效数据，这时需要有一个淘汰策略</p><p>在redis里面，淘汰策略每次不会删除太多数据，因为这时候的数据并没有过期，所以只会按照一定策略将数据删除的正好能够放进新数据即可</p><p><strong>1）淘汰算法</strong></p><ul><li>默认情况下，不能写，能读，写入报错</li><li>所有数据里使用lru&#x2F;lfu</li><li>过期数据里使用lru&#x2F;lfu</li><li>ttl淘汰快过期数据</li><li>random随机</li></ul><p><strong>2）淘汰池</strong></p><p>如何保证不删太多，删的正好够放入新key呢？<br>就是用淘汰池，从里面删除正好数量的数据，实行末位淘汰机制，从最后面开始删</p><p>redis的淘汰并不是全量范围内淘汰，而是根据批次选择，放入淘汰池最应该被淘汰的key<br>注意，这里并不删除key，只是放里面最应该淘汰的</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM（二）JVM之垃圾收集</title>
      <link href="/2023/02/17/JVM%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/02/17/JVM%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>​在Java语言中，由于内存分配和回收由JVM自动进行管理，而不需要手动进行内存管理，这就避免了许多常见的内存管理问题，如内存泄漏、悬挂指针等问题。但是，随着程序运行过程中对象的不断创建和销毁，JVM所管理的内存也会不断产生垃圾。如果不及时清理这些垃圾，就会导致内存不足，甚至导致程序崩溃。因此，垃圾收集成为JVM必不可少的一部分，用于自动地回收无用对象所占用的内存空间，使得可用内存得到最大的利用，从而保证程序的正常运行。</p><h3 id="二、垃圾标记"><a href="#二、垃圾标记" class="headerlink" title="二、垃圾标记"></a>二、垃圾标记</h3><p>既然想要清理垃圾，那么首先要能够找到垃圾，那么有哪些方法可确定一个对象是否是垃圾呢？</p><h4 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1.引用计数法"></a>1.引用计数法</h4><p>引用计数法是一种垃圾收集算法，其核心思想是通过维护每个对象的引用计数器来判断对象是否还有被引用的可能，从而决定是否回收该对象</p><p>具体来说，每当一个对象被引用时，该对象的引用计数器就会加1；当一个对象的引用失效时，该对象的引用计数器就会减1。当某个对象的引用计数器为0时，表示该对象没有任何引用指向它，即无法再被访问，因此可以被回收</p><p><strong>弊端：</strong>如果两个对象相互引用，它们的引用计数器都不为0，但是它们已经不再被程序所使用，因此这两个对象将永远不会被回收</p><h4 id="2-可达性分析法"><a href="#2-可达性分析法" class="headerlink" title="2.可达性分析法"></a>2.可达性分析法</h4><p>可达性分析法是Java虚拟机中最常用的垃圾收集算法之一，也是垃圾收集器判断对象是否存活的标准。该算法的基本思想是通过一系列称为”GC Roots”的对象作为起始点集，从这些节点开始向下搜索，搜索过程中所遇到的对象都被视为存活的对象，反之则被视为垃圾对象。简单来说，如果一个对象不可达（即没有被引用），那么这个对象就被判定为垃圾对象</p><p>GC Roots一般包括以下几种：</p><ul><li><strong>虚拟机栈</strong>中引用的对象</li><li><strong>本地方法栈</strong>中引用的对象</li><li>方法区中<strong>类静态属性</strong>引用的对象</li><li>方法区中<strong>常量</strong>引用的对象</li></ul><p>在可达性分析法中，垃圾收集器会从GC Roots开始，遍历所有的引用关系，如果一个对象没有被引用，就将其判定为垃圾对象，进而对其进行回收。这样可以保证被引用的对象不会被误判为垃圾对象，从而被回收。同时，也可以确保不被引用的对象被及时回收，从而释放内存空间</p><blockquote><p>需要注意的是，标记算法找到的都是可以继续存活的对象，没有被标记到的对象才会被回收</p></blockquote><h3 id="三、垃圾收集算法"><a href="#三、垃圾收集算法" class="headerlink" title="三、垃圾收集算法"></a>三、垃圾收集算法</h3><p>垃圾标记算法可以找到哪些垃圾需要被清除，那么如何清除这些垃圾呢？</p><h4 id="1-标记-清除（Mark-Sweep）"><a href="#1-标记-清除（Mark-Sweep）" class="headerlink" title="1.标记-清除（Mark-Sweep）"></a>1.标记-清除（Mark-Sweep）</h4><p>分为标记和清除两个阶段</p><p>在标记阶段，从根节点开始遍历堆内存中所有的对象，标记所有被引用的对象为“存活”对象，未被标记的对象为“垃圾”对象</p><p>在清除阶段，遍历整个堆内存，回收未被标记的对象所占用的内存。回收完成后，堆内存中将只有存活对象存在</p><p>标记：蓝色部分为能够被标记的对象，灰色是不可达对象</p><img src="https://static-2w2.pages.dev/post/jvm-marksweep1.png" alt="image-20230409160721275" style="zoom: 50%;" /><p>清除：将不可达对象都清除掉</p><img src="https://static-2w2.pages.dev/post/jvm-marksweep2.png" alt="image-20230409160804322" style="zoom:50%;" /><p>优点：实现简单，可以解决循环引用问题</p><p>缺点：产生内存碎片，需要扫描整个堆来处理，所以效率略差</p><h4 id="2-标记-复制（Mark-Copy）"><a href="#2-标记-复制（Mark-Copy）" class="headerlink" title="2.标记-复制（Mark-Copy）"></a>2.标记-复制（Mark-Copy）</h4><p>在内存中划分出两块儿相同大小的区域，每次只使用其中一块儿，清理垃圾时就把其中一块儿上的存活对象复制到另一块儿上</p><img src="https://static-2w2.pages.dev/post/jvm-mark-copy.png" alt="image-20230409170648442" style="zoom: 33%;" /><p>优点：</p><ul><li>无内存碎片</li><li>实现简单，运行高效</li></ul><p>缺点：</p><ul><li>需要额外空间</li><li>存活对象很多时，复制成本高，影响性能</li></ul><h4 id="3-标记-整理（Mark-Compact）"><a href="#3-标记-整理（Mark-Compact）" class="headerlink" title="3.标记-整理（Mark-Compact）"></a>3.标记-整理（Mark-Compact）</h4><p>同样是先标记，但是与标记-清除不同的是，标记之后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p><img src="https://static-2w2.pages.dev/post/jvm-mark-compact.png" alt="image-20230409170806988" style="zoom:33%;" /><h4 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4.分代收集"></a>4.分代收集</h4><p>前面提到过，JVM中的堆内存结构就是为了配合垃圾收集而划分的，那么在堆里面到底是怎么进行垃圾收集的呢？</p><p>在JVM中，采用了垃圾分代收集的概念，将堆内存划分为了Young区和Old区，每个区域采用的垃圾收集算法都不相同</p><p>在Young区中，由于特意划分出了From区和To区，所以很明显，使用的是标记-复制算法</p><p>在Old区中，则根据实际情况，可以选择标记-清除或者标记-整理算法</p><h3 id="四、垃圾收集器"><a href="#四、垃圾收集器" class="headerlink" title="四、垃圾收集器"></a>四、垃圾收集器</h3><p>上面提到的垃圾收集算法都是理论上的算法，那么在实际当中，肯定要有对应的落地实现来完成这些算法，这就是垃圾收集器，下面整体看一下不同垃圾收集器工作的区域和他们之间的配合关系</p><img src="https://static-2w2.pages.dev/post/jvm-gc-1.png" alt="image-20230409162553882" style="zoom:33%;" /><blockquote><p>在介绍不同的垃圾收集器之前，需要先引入一个概念：STW</p><p><strong>STW（Stop-The-World）</strong>指的是停顿式垃圾收集器在进行垃圾回收时，需要暂停应用程序的执行，直到垃圾回收完成。在这个暂停期间，所有应用程序的线程都被挂起，无法继续执行。因此，STW会影响应用程序的响应时间和吞吐量。</p><p>所以在垃圾收集器中，如果想提高吞吐量和响应时间就要尽量减少STW的时间</p></blockquote><h4 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1.Serial收集器"></a>1.Serial收集器</h4><p>Serial收集器是最基本、发展历史最悠久的收集器，曾经(在JDK1.3.1之前)是虚拟机新生代收集的唯一选择</p><p>它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是其在进行垃圾收集的时候需要暂停其他线程</p><p>优点：简单高效，拥有很高的单线程手机效率</p><p>缺点：收集过程中会暂停其他所有线程</p><p>算法：标记-复制算法</p><p>适用范围：新生代</p><p>应用：Client模式下的默认新生代收集器</p><h4 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2.ParNew收集器"></a>2.ParNew收集器</h4><p>可以看作Serial的多线程版本</p><p>优点：多CPU时比Serial效率高</p><p>缺点：收集过程中会暂停其他所有线程，单CPU时比Serial效率差</p><p>算法：标记-复制算法</p><p>适用范围：新生代</p><p>应用：运行在Server模式下的虚拟机中首选的新生代收集器</p><h4 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3.Parallel Scavenge收集器"></a>3.Parallel Scavenge收集器</h4><p>Parallel Scavenge是一个新生代收集器，使用复制算法，支持并行，更加关注吞吐量</p><p><strong>吞吐量&#x3D;运行用户代码的时间&#x2F;（运行用户代码的时间+垃圾收集时间）</strong></p><p>一些参数和它相关</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-XX</span>:<span class="string">MaxGCPauseMillis #控制最大的垃圾收集停顿时间</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">GCTimeRatio#直接设置吞吐量的大小</span></span><br></pre></td></tr></table></figure><h4 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4.Serial Old收集器"></a>4.Serial Old收集器</h4><p>相当于Serial的老年代版本，也是单线程收集器，但是采用的是标记-整理算法，运行过程和Serial一样</p><p>它能够配合上述三种新生代垃圾收集器一起使用</p><h4 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5.Parallel Old收集器"></a>5.Parallel Old收集器</h4><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法</p><p>也是吞吐量优先的垃圾收集器</p><h4 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6.CMS收集器"></a>6.CMS收集器</h4><p>CMS（Concurrent Mark Sweep）垃圾收集器是一种以获取最短回收停顿时间为目标的低延迟垃圾收集器。它是一种并发收集器，可以和用户线程一起工作，尽量减少停顿时间，提高系统的响应速度，使用标记-清除算法</p><p>CMS垃圾收集器的工作流程如下：</p><ul><li><strong>初始标记</strong>：标记GC Roots直接关联的对象，速度较快</li><li><strong>并发标记</strong>：和用户线程一起标记存活对象，速度较慢</li><li><strong>重新标记</strong>：暂停用户线程，标记在并发标记期间产生的新的存活对象，速度较快</li><li><strong>并发清除：</strong>和用户线程一起清除垃圾对象，速度较快</li></ul><img src="https://static-2w2.pages.dev/post/jvm-gc-cms.png" alt="image-20230409163903919" style="zoom:50%;" /><p>得益于它采用的并发标记策略，它具有以下优点</p><ul><li>并发收集：CMS垃圾收集器采用标记-清除算法，其中标记阶段是在应用程序线程运行的同时进行的，因此不需要停顿整个应用程序，从而减少了垃圾收集的停顿时间，使得垃圾收集对应用程序的影响更小。</li><li>低延迟：CMS垃圾收集器具有低延迟的特点，因为它只在垃圾收集过程的标记和清除阶段停顿应用程序线程，而在其他阶段都是与应用程序线程并发执行的。</li><li>内存回收效率高：CMS垃圾收集器在堆内存空间不足时，会触发一次CMS收集，只会回收那些无法再分配的空间，从而避免了Full GC的发生，提高了内存回收效率。</li><li>适用于响应时间要求高的应用程序：由于CMS垃圾收集器具有低延迟的特点，因此适用于响应时间要求高的应用程序，如Web应用等。</li></ul><p><strong>但是采用标记-清除算法也导致了它会产生内存碎片的问题</strong></p><h4 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a>7.G1收集器</h4><p>G1收集器是在JDK 7 Update 4发布之后引入的。</p><p>与传统的分代收集器不同，G1收集器把Java堆分成多个大小相等的独立区域（Region），并按需收集这些独立区域，同时避免全局垃圾收集带来的长时间停顿问题，它的实现原理如下：</p><ul><li>将堆内存<strong>分割成若干个大小相等的内存区域</strong>（Region），每个Region可以是Eden区、Survivor区或Old区</li><li>在Young GC时，G1收集器<strong>只对部分的Young区域进行回收</strong>，而非整个Young区域，以此减少收集的时间</li><li>在Old GC时，G1收集器会<strong>选择多个Region</strong>（包括Young区域和Old区域）进行回收，而非全局扫描整个堆</li><li>在收集时，G1收集器会<strong>优先选择回收垃圾最多的Region</strong></li><li>G1收集器采用<strong>并发标记算法</strong>，可以在应用程序运行的同时进行垃圾收集</li></ul><p>G1收集器的实现原理比较复杂，但它的主要优点是可以大幅度减少STW的时间，并且能够自适应地调整分代大小、分配回收的内存等参数，以提高性能和稳定性</p><p>G1收集器下的堆结构和其他垃圾收集器下的堆结构对比</p><p><img src="https://static-2w2.pages.dev/post/jvm-gc-g1.png" alt="image-20230409164748888"></p><p>G1的垃圾收集过程如下：</p><ul><li><strong>初始标记（Initial Mark）</strong>：STW（Stop the World）的过程，会标记出根对象和部分老年代对象的存活状态，这些存活的对象被标记为”Marked”</li><li><strong>并发标记（Concurrent Mark）</strong>：在堆中进行并发标记，此时应用程序线程和GC线程并发执行，G1会找到所有存活的对象并标记为”Marked”</li><li><strong>最终标记（Final Mark）</strong>：STW的过程，收集器会对整个堆进行扫描，以确保标记出所有存活的对象</li><li><strong>筛选回收（Live Data Counting And Evacuation）</strong>：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划</li></ul><p>在以上过程中，G1收集器会根据各个Region的回收价值，先回收回收价值高的Region，这样可以最大程度的降低GC的停顿时间，并尽可能减少垃圾收集的次数，从而提高应用程序的整体性能</p><h4 id="8-垃圾收集器分类"><a href="#8-垃圾收集器分类" class="headerlink" title="8.垃圾收集器分类"></a>8.垃圾收集器分类</h4><p><strong>串行收集器</strong></p><p>收集器：Serial、Serial Old</p><p>特征：只能有一个垃圾回收线程执行，用户线程暂停</p><p>适用：适用于内存比较小的嵌入式设备</p><p><strong>并行收集器（吞吐量优先）</strong></p><p>收集器：Parallel Scanvenge、Parallel Old</p><p>特征：多条垃圾收集线程并行工作，但此时用户仍然处于等待状态</p><p>适用：适用于科学计算，后台处理等弱交互的场景</p><p><strong>并发收集器（停顿时间优先）</strong></p><p>收集器：CMS、G1</p><p>特征：用户线程和垃圾收集线程同时执行(但并不一定是并行的，可能是交替执行的)，垃圾收集线程在执行的时候不会停顿用户线程的运行</p><p>适用：适用于对于时间有要求的场景，比如web</p><h4 id="9-如何选择垃圾收集器"><a href="#9-如何选择垃圾收集器" class="headerlink" title="9.如何选择垃圾收集器"></a>9.如何选择垃圾收集器</h4><p>选择垃圾收集器的标准</p><ul><li>优先调整堆的大小让服务器自己来选择</li><li>如果内存小于100M，使用串行收集器</li><li>如果是单核，并且没有停顿时间要求，使用串行或JVM自己选</li><li>如果允许停顿时间超过1秒，选择并行或JVM自己选</li><li>如果响应时间最重要，并且不能超过1秒，使用并发收集器</li></ul><p>那么对于G1收集器，何时使用呢？</p><ul><li><strong>50%以上的堆被存活对象占用</strong>：如果堆中存活对象占用堆的50%以上，那么使用传统的标记-清除、标记-整理或复制算法可能<strong>会导致长时间的暂停</strong>。而G1收集器是一款基于分代思想的收集器，它可以把堆空间分为多个不同大小的区域，每个区域都可以独立地进行垃圾回收。这样就可以避免在一次垃圾回收中需要同时处理大量存活对象的情况，降低了STW的时间</li><li><strong>对象分配和晋升的速度变化非常大</strong>：G1垃圾收集器可以通过智能地选择要处理的回收区域，动态调整回收集和堆的大小，优化垃圾回收的效率，从而尽可能减少长时间的STW</li><li><strong>垃圾回收时间比较长</strong>：如果垃圾回收时间比较长，会导致应用程序停顿时间过长，影响用户体验。G1采用了可预测停顿时间的机制，可以根据用户设定的目标停顿时间，合理地分配各个阶段的垃圾回收时间，尽可能减少停顿时间，提高应用程序的性能和可用性</li></ul><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>根据上面的介绍可知，没有万能的垃圾收集器，在不同的业务环境下可以考虑采用不同的垃圾收集器</p><p>相比较而言，CMS和G1这两个并发的垃圾收集器具有比较好的适用性，因为他们采用了停顿时间优先的策略，可以并发标记存活对象，从而减少了STW时间</p><p>在JDK1.8中，Young区默认采用Serial垃圾收集器，Old区默认采用CMS收集器</p><p>在JDK1.9中，默认采用G1收集器</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM（一）JVM基础</title>
      <link href="/2023/01/28/JVM%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/01/28/JVM%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><h3 id="1-什么是JVM"><a href="#1-什么是JVM" class="headerlink" title="1.什么是JVM"></a>1.什么是JVM</h3><p>JVM（Java Virtual Machine）是Java平台的核心组件之一，它是一个在计算机上运行Java字节码的虚拟机。JVM是Java语言的核心特性之一，它提供了Java程序的跨平台能力，因为Java代码可以在任何能够运行JVM的操作系统上运行。</p><p>JVM负责将Java源代码编译成字节码，然后在运行时解释执行这些字节码。JVM还负责内存管理、垃圾回收、安全性、异常处理等方面的任务。</p><h3 id="2-JVM、JRE和JDK"><a href="#2-JVM、JRE和JDK" class="headerlink" title="2.JVM、JRE和JDK"></a>2.JVM、JRE和JDK</h3><p>JRE（Java Runtime Environment）、JVM（Java Virtual Machine）和JDK（Java Development Kit）是三个Java平台中不同的组件。</p><p>JVM是Java平台的核心组件之一，<strong>它是一个在计算机上运行Java字节码的虚拟机</strong>。JVM负责将Java源代码编译成字节码，然后在运行时解释执行这些字节码。JVM还负责内存管理、垃圾回收、安全性、异常处理等方面的任务。</p><p>JRE是Java平台的一部分，<strong>包含了Java应用程序所需要的运行时环境</strong>，包括JVM以及Java标准库中的类和资源文件。JRE可以用于在计算机上运行Java应用程序，但是不能用于编写Java程序。</p><p>JDK是Java开发工具包，它<strong>包含了JRE以及编写Java程序所需要的开发工具</strong>，包括编译器、调试器和其他实用工具。JDK提供了完整的Java开发环境，可以用于编写、编译和测试Java程序。</p><p>因此，JRE是Java应用程序运行时环境，JVM是在其中运行字节码的虚拟机，而JDK是开发Java应用程序所需的完整工具集。JRE和JDK都包含JVM，但是JDK还包含了其他的开发工具。</p><h2 id="二、类加载机制"><a href="#二、类加载机制" class="headerlink" title="二、类加载机制"></a>二、类加载机制</h2><h3 id="1-加载流程一览"><a href="#1-加载流程一览" class="headerlink" title="1.加载流程一览"></a>1.加载流程一览</h3><ul><li><strong>加载</strong>（Loading）：将类的字节码文件加载到JVM内存中。类的字节码可以来自本地磁盘、网络或其他设备，由类加载器负责加载。类加载过程的核心任务是读取字节码文件并创建一个代表该类的Class对象。</li><li><strong>链接</strong>（Linking）：将类的二进制数据合并到JVM的运行时环境中。链接过程可以分为三个阶段：<ul><li><strong>验证</strong>（Verification）：确保类的字节码文件符合JVM规范，不会危害JVM的安全。验证过程包括文件格式验证、字节码验证、符号引用验证和访问权限验证。</li><li><strong>准备</strong>（Preparation）：为类的静态变量分配内存并设置默认初始值。例如，int类型的静态变量默认值为0，对象类型的静态变量默认值为null。</li><li><strong>解析</strong>（Resolution）：将符号引用转换为直接引用。例如，将一个类名转换为对应的Class对象。</li></ul></li><li><strong>初始化</strong>（Initialization）：执行类构造器方法（<clinit>），这个方法由编译器自动添加到类中。类构造器方法包括静态变量的初始化和静态代码块的执行。类初始化过程是在程序运行期间动态地执行的。</li></ul><h3 id="2-加载"><a href="#2-加载" class="headerlink" title="2.加载"></a>2.加载</h3><p>加载是class文件进入虚拟机要经历的第一个阶段，它的主要任务是将编译后的.class文件加载到JVM中，生成对应的Class对象。加载过程可以分为以下三个步骤：</p><ul><li><strong>读取：</strong>通过类的全限定名获取定义该类的二进制字节流。JVM通过类加载器查找类的过程来获取该类的字节码数据。</li><li><strong>转化：</strong>将字节流所代表的静态存储结构转化为方法区的运行时数据结构。在将字节流转换成运行时数据结构之前，需要对字节流进行一定的校验，确保其符合JVM规范和安全性要求。</li><li><strong>入口：</strong>在内存中生成一个代表该类的java.lang.Class对象，<strong>作为该类访问入口</strong>。同时，将该类的Class对象存放到方法区中，并建立相应的引用关系，使得JVM可以通过该Class对象访问到类的方法、变量等相关信息。</li></ul><p>概述一下，<strong>加载的作用就是将编译后的Java类文件加载到JVM中，并在方法区中生成一个代表该类的Class对象，以便于JVM在运行时进行访问和使用</strong></p><h3 id="3-链接"><a href="#3-链接" class="headerlink" title="3.链接"></a>3.链接</h3><p><strong>链接的作用是将编译后的Java类文件中的符号引用转换为直接引用，以便于JVM在运行时能够正确地访问和使用类的方法、变量等相关信息</strong></p><p>链接主要包括三个步骤，如下所示</p><ul><li>验证：确保类文件的字节流中包含的信息符合JVM规范和安全性要求，比如检查类文件的格式、语法、继承关系等</li><li>准备：为类中定义的所有静态变量（static）分配内存，并赋上默认值</li><li>解析：将编译时生成的符号引用（Symbolic Reference）转化为直接引用（Direct Reference），使得虚拟机能够正确地定位并访问类的方法、变量等相关信息</li></ul><p>链接阶段最主要的作用就是将类文件中的符号应用转化为直接引用，那么什么是符号引用，什么又是直接引用呢？</p><h4 id="3-1-符号引用"><a href="#3-1-符号引用" class="headerlink" title="3.1 符号引用"></a>3.1 符号引用</h4><p>首先看比较官方的定义，符号引用主要包括以下信息：</p><ul><li>类的全限定名：用于唯一地标识一个类。</li><li>方法的名称和描述符：用于描述方法的名称和参数类型、返回值类型等信息。</li><li>变量的名称和描述符：用于描述变量的名称和类型信息。</li></ul><p>是不是还有点懵？举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>String</code>、<code>System</code>、<code>out</code>等都是符号引用，<code>println</code>和<code>str</code>也是符号引用。具体来说：</p><ul><li><code>String</code>是一个类的符号引用，用于描述<code>str</code>变量的类型。它的全限定名是<code>java.lang.String</code></li><li><code>System</code>是一个类的符号引用，用于描述<code>out</code>变量的类型。它的全限定名是<code>java.lang.System</code></li><li><code>out</code>是一个静态变量的符号引用，用于描述<code>println</code>方法所输出的目标流。它的名称是<code>out</code>，描述符是<code>Ljava/io/PrintStream;</code>，表示一个<code>PrintStream</code>类型的对象引用</li><li><code>println</code>是一个方法的符号引用，它的名称是<code>println</code>，描述符是<code>(Ljava/lang/String;)V</code>，表示一个接受一个<code>String</code>类型参数，返回值为<code>void</code>的方法</li><li><code>str</code>是一个局部变量的符号引用，它的名称是<code>str</code>，描述符是<code>Ljava/lang/String;</code>，表示一个<code>String</code>类型的对象引用</li></ul><p>简单点说，在编程中用到的类名，变量名，方法名，全是符号引用…</p><blockquote><p>但是需要注意的是，类加载阶段是对静态变量进行初始化的阶段，普通方法内的局部变量只有在调用方法时才会初始化</p></blockquote><h4 id="3-2-直接引用"><a href="#3-2-直接引用" class="headerlink" title="3.2 直接引用"></a>3.2 直接引用</h4><p>直接引用是可以直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。与符号引用相比，直接引用是一种较为底层的引用方式，它指向具体的内存地址或数据结构</p><p>所以将符号引用转换为直接引用后，虚拟机就可以直接访问到对应的内存地址了，可以加速访问速度</p><p>而这也是为什么<strong>解析</strong>这一步位于<strong>准备</strong>后面，因为在准备阶段才为静态变量分配内存，分配了内存之后才能进行符号引用转为直接引用</p><p>但是此时的静态变量只是被赋值给了默认值，还没有将代码中要赋的值交给静态变量，这个工作交给下一个阶段——<strong>初始化</strong>来完成</p><h3 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4.初始化"></a>4.初始化</h3><p>初始化是类加载机制的最后一个阶段，主要是为静态变量赋予初始值，并执行类构造器<clinit>()方法的过程</p><p>那么到这里要产生疑惑了，静态变量赋予初值看得懂，执行类构造器<clinit>()方法是什么意思呢？先看看类初始化的步骤</p><ul><li>虚拟机为类变量分配内存，并赋予默认值。对于基本类型，内存空间被初始化为0或false，对于引用类型，内存空间被初始化为null。</li><li>如果静态变量在声明时就被赋值了，那么虚拟机会将这些赋值语句放到类构造器<clinit>()方法中，并在初始化时执行这些语句。如果静态变量在静态代码块中被赋值了，那么虚拟机也会将这些赋值语句放到<clinit>()方法中，并在初始化时执行。</li><li>如果类存在父类，则会先初始化父类的<clinit>()方法。</li><li>如果静态变量的初始化涉及到其他类或接口，那么会先对这些类或接口进行初始化。</li><li>最后，虚拟机会执行类构造器<clinit>()方法的代码，包括所有静态变量初始化语句和静态代码块中的语句。如果类没有定义<clinit>()方法，那么这个过程就是空的</li></ul><p>定义：<strong>类构造器<clinit>()<strong>方法是由编译器自动收集类中所有</strong>静态变量</strong>的赋值语句和<strong>静态代码块</strong>中的语句合并而成的</p><p>主要包含两个部分</p><ul><li>静态变量</li><li>静态代码块</li></ul><p>所以总结一句话：<strong>初始化阶段就是为静态变量和静态代码块赋予初始值的过程</strong></p><h2 id="三、类加载器"><a href="#三、类加载器" class="headerlink" title="三、类加载器"></a>三、类加载器</h2><p>类加载器是 Java 虚拟机的一个重要组成部分，它的作用是将 Java 类文件加载到 JVM 中，并生成对应的 Java 类对象，为 Java 应用程序提供了动态加载类的功能</p><h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1.分类"></a>1.分类</h3><p>ava 虚拟机内置了三种类加载器：</p><ol><li><strong>启动类加载器</strong>（Bootstrap ClassLoader）：也称为引导类加载器，负责加载 Java 的核心类库，如 rt.jar 等。</li><li><strong>扩展类加载器</strong>（Extension ClassLoader）：也称为系统类加载器，负责加载 Java 的扩展类库，如 $JAVA_HOME&#x2F;lib&#x2F;ext 目录下的 jar 包。</li><li><strong>应用程序类加载器</strong>（Application ClassLoader）：也称为用户自定义类加载器，负责加载应用程序的类，也就是在程序中自己编写的类。</li></ol><p>除了上述三种内置类加载器外，Java 还提供了一些可以自定义的类加载器，例如网络类加载器（NetworkClassLoader）和自定义类加载器（CustomClassLoader）等，用于满足一些特殊的加载需求。</p><h3 id="2-双亲委派机制"><a href="#2-双亲委派机制" class="headerlink" title="2.双亲委派机制"></a>2.双亲委派机制</h3><h4 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h4><p>双亲委派机制是一种类加载器的工作机制，其主要思想是在类加载的过程中，<strong>每个类加载器都会先委派给其父类加载器进行加载，只有当父类加载器无法完成加载任务时，子类加载器才会尝试自行加载</strong>。</p><p>这种机制的主要优势在于避免重复加载和类的版本冲突问题。当一个类加载器需要加载某个类时，它首先会将该请求委派给父类加载器处理。如果父类加载器能够完成加载任务，就直接返回该类对象；如果父类加载器无法完成加载任务，则会将该请求再委派给其父类加载器，直到委派到最顶层的启动类加载器为止。如果最终仍无法找到该类的定义，则会抛出 ClassNotFoundException 异常。</p><p>通过双亲委派机制，可以保证在 JVM 运行过程中，同一个类在不同的类加载器中只会被加载一次，<strong>避免了类的重复加载和版本冲突问题</strong>。此外，双亲委派机制还可以<strong>保证核心类库的安全性，因为核心类库都是由启动类加载器加载的，防止了恶意代码篡改核心类库的情况</strong>。</p><p>那结合上面介绍过的类加载器分类，可以得到在JVM当中的类加载器启动流程</p><ul><li>当应用程序需要加载一个类时，它首先会请求<strong>应用程序类加载器</strong>进行加载</li><li>应用程序类加载器会将该请求委托给<strong>扩展类加载器</strong>进行加载</li><li>扩展类加载器又会将该请求委托给<strong>启动类加载器</strong>进行加载</li><li>如果启动类加载器找到了该类，则直接返回该类的 Class 对象，否则它会让扩展类加载器去加载</li><li>如果扩展类加载器找到了该类，则直接返回该类的 Class 对象，否则它会让应用程序类加载器去加载</li><li>应用程序类加载器尝试去加载该类，如果它也找不到，则会抛出 ClassNotFoundException 异常</li></ul><p>上述流程是从理论上来说的，那么在JDK源码之中，类加载机制是如何实现的呢？</p><h4 id="2-2-源码实现"><a href="#2-2-源码实现" class="headerlink" title="2.2 源码实现"></a>2.2 源码实现</h4><p>类加载器定义在Launcher类中，它是虚拟机启动的入口点，主要负责完成Java虚拟机的启动、类加载、运行等一系列操作，下面看一下删减之后的Launcher类结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Launcher</span> &#123;</span><br><span class="line">  <span class="comment">// 静态变量launcher，调用无参构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Launcher</span> <span class="variable">launcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Launcher</span>();</span><br><span class="line">  <span class="comment">// 类加载器</span></span><br><span class="line">    <span class="keyword">private</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Launcher <span class="title function_">getLauncher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> launcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Launcher</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.loader;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  <span class="comment">// 应用类加载器</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AppClassLoader</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 扩展类加载器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见，三种基本的类加载器，只有应用类加载器与扩展类加载器定义在Launcher类里面</p><ul><li>AppClassLoader：继承自URLClassLoader的静态内部类</li><li>ExtClassLoader：也是继承自URLClassLoader的静态内部类</li></ul><blockquote><p>其中，URLClassLoader是继承自SecureClassLoader，SecureClassLoader继承自ClassLoader</p></blockquote><p>那么引导类加载器在哪里呢？</p><p>事实上，引导类加载器是JVM内部的一部分，它不是Java类，也不位于Launcher类中</p><p>引导类加载器是由JVM自己实现的，用于加载JVM自身需要的类，例如<code>java.lang.Object</code>和<code>java.lang.Class</code>等类。引导类加载器是JVM启动时创建的，且无法在程序中直接获取其实例</p><p>下面继续Launcher类源码，观察一下它的无参构造器内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Launcher</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 扩展类加载器</span></span><br><span class="line">    ExtClassLoader var1;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 双重校验锁实现的单例模式，获取扩展类加载器实例</span></span><br><span class="line">        var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Could not create extension class loader&quot;</span>, var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 声明应用类加载器</span></span><br><span class="line">        <span class="comment">// 应用类加载器的parent设置为var1，即扩展类加载器</span></span><br><span class="line">        <span class="built_in">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Could not create application class loader&quot;</span>, var9);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 设置上下文类加载器</span></span><br><span class="line">    Thread.currentThread().setContextClassLoader(<span class="built_in">this</span>.loader);</span><br><span class="line">    <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.security.manager&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (var2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(var2) &amp;&amp; !<span class="string">&quot;default&quot;</span>.equals(var2)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 使用loadClass进行类加载，这里也是双亲委派实现的地方</span></span><br><span class="line">                var3 = (SecurityManager)<span class="built_in">this</span>.loader.loadClass(var2).newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException var5) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException var6) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var7) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassCastException var8) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            var3 = <span class="keyword">new</span> <span class="title class_">SecurityManager</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (var3 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Could not create SecurityManager: &quot;</span> + var2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.setSecurityManager(var3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面看到，构造器里面调用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(SecurityManager)<span class="built_in">this</span>.loader.loadClass(var2).newInstance();</span><br></pre></td></tr></table></figure><p>这一代码，事实上，双亲委派机制就是依赖类加载器的loadClass实现的，下面看下不同</p><p>首先是应用类加载器的loadClass方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String var1, <span class="type">boolean</span> var2) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var3</span> <span class="operator">=</span> var1.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">    <span class="keyword">if</span> (var3 != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">var4</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (var4 != <span class="literal">null</span>) &#123;</span><br><span class="line">            var4.checkPackageAccess(var1.substring(<span class="number">0</span>, var3));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.ucp.knownToNotExist(var1)) &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="built_in">this</span>.findLoadedClass(var1);</span><br><span class="line">        <span class="keyword">if</span> (var5 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var2) &#123;</span><br><span class="line">                <span class="built_in">this</span>.resolveClass(var5);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> var5;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 调用ClassLoader类里面声明的loadClass方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下ClassLoader里面的loadClass</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 寻找调用parent的loadClass</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 没有parent，调用引导类加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的分析，就可以发现步骤很清晰了</p><p>在一般的类加载流程中，Launcher类调用无参构造器进行以下步骤</p><ul><li>生成扩展类加载器对象—单例生成</li><li>生成应用类加载器对象，把它的parent设置为上面生成的扩展类加载器对象</li><li>调用loadClass方法，这个方法最终是由他们的共同父类ClassLoad实现的</li><li>在loadClass里面，如果对象有设置parent就调用parent的loadClass方法</li><li>如果对象没有设置parent，则调用JVM实现的引导类加载器</li><li>如果父类加载器无法加载指定类，则会尝试自己使用findClass方法加载</li></ul><h2 id="三、运行时数据区"><a href="#三、运行时数据区" class="headerlink" title="三、运行时数据区"></a>三、运行时数据区</h2><img src="https://static-2w2.pages.dev/post/runTime.png" alt="image-20230409105202970" style="zoom: 23%;" /><p>JVM运行时数据区主要由两大类组成，分别是线程共享区域与线程独有区域</p><ul><li>线程共享：方法区，堆</li><li>线程私有：程序计数器，虚拟机栈，本地方法栈</li></ul><h3 id="1-方法区"><a href="#1-方法区" class="headerlink" title="1.方法区"></a>1.方法区</h3><p>方法区（Method Area）是JVM运行时数据区中的一部分，它是所有线程共享的内存区域。它用于存储类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>在Java 8及以前的版本中，方法区是堆（Heap）的一部分</p><p>而在Java 8之后，方法区已经被彻底废弃，取而代之的是元空间（Metaspace）</p><p>方法区主要存储以下几类数据：</p><ul><li><strong>类信息</strong>：每个类的完整结构信息，包括类名、父类名、接口名、字段、方法、访问标志等</li><li><strong>运行时常量池</strong>：每个类都有一个运行时常量池，用于存储编译时生成的字面量（如字符串、数字、类名、方法名等）和符号引用（如类和方法的全限定名、字段的名称和描述符等）</li><li><strong>静态变量</strong>：所有类共享的变量，它们在类加载时被分配空间，并在程序运行期间一直存在</li><li><strong>即时编译器编译后的代码</strong>：在JVM运行过程中，即时编译器会将一些频繁调用的代码编译成本地机器码，然后存储到方法区中，以提高程序运行的效率</li></ul><p>需要注意的是，方法区的内存分配是在JVM启动时就完成的，其大小由-Xmx参数设置的最大堆大小决定。当方法区的空间不足时，会触发Full GC来回收无用的类信息、常量、静态变量等（1.8之前）。因此，当程序中使用大量类、方法、常量等时，需要适当调整JVM的-Xmx参数，以避免出现OOM异常</p><h4 id="1-1-永久代、元空间与方法区"><a href="#1-1-永久代、元空间与方法区" class="headerlink" title="1.1 永久代、元空间与方法区"></a>1.1 永久代、元空间与方法区</h4><p>在JDK8之前，JVM虚拟机采用<strong>永久代</strong>的概念来描述<strong>方法区</strong></p><p>在JDK8及之后，JVM虚拟机使用<strong>元空间</strong>的概念来描述<strong>方法区</strong></p><p>那么永久代和方法区有哪些相似与不同之处呢？</p><p><strong>相似点：</strong>他们都是用来存储类相关信息的，即方法区要存储的<strong>类信息</strong></p><blockquote><p>注意：</p><p>在JDK1.7及之前，运行时常量池位于永久代之中，一起放在堆之中</p><p>但在JDK1.8及之后，永久代被元空间取代，运行时常量池移动到了堆里面，不属于元空间</p></blockquote><p><strong>不同点：</strong></p><ul><li><strong>永久代</strong><ul><li>永久代是堆的一部分，所以也会发生OOM，会有Full GC，产生内存碎片等</li><li>永久代过小会导致频繁GC</li><li>永久代过大会影响Young和Old的内存分配</li></ul></li><li><strong>元空间</strong><ul><li>使用本地内存，不受堆内存限制，避免内存碎片问题</li><li>可以根据应用程序的需要进行动态扩容和释放</li><li>内存回收不需要进行Full GC，减少了GC的时间消耗</li></ul></li></ul><blockquote><p>他们都会发生OOM，但是出现原因不同，解决方式也不同</p></blockquote><h4 id="1-2-运行时常量池"><a href="#1-2-运行时常量池" class="headerlink" title="1.2 运行时常量池"></a>1.2 运行时常量池</h4><p>运行时常量池(Runtime Constant Pool)是在类加载过程中的一部分，用于存储编译器生成的各种字面量和符号引用</p><p><strong>字面量：</strong>包括各种基本类型的值、字符串常量和类名、方法名等</p><p><strong>符号引用：</strong>指向一个在运行时期解析的位置，包括类和接口的全限定名、字段的名称和描述符以及方法的名称和描述符等信息</p><h3 id="2-堆"><a href="#2-堆" class="headerlink" title="2.堆"></a>2.堆</h3><p>在Java中，堆（Heap）是一个运行时数据区，用于存储对象实例</p><p>堆是JVM中最大的一块内存，是所有线程共享的</p><p>JVM启动时，就会自动为堆分配一定大小的初始空间，而且在运行期间也可以通过设置参数来调整堆的大小</p><p>下面看下不同版本的JVM内存分配区别</p><img src="https://static-2w2.pages.dev/post/runTime2.png" alt="版本区别" style="zoom:50%;" /><p>再看下内存分配：</p><img src="https://static-2w2.pages.dev/post/heapMemory.png" alt="image-20230409141325294" style="zoom: 50%;" /><p>由图可见，在JVM当中，堆主要由两部分组成：young区和old区</p><p>其中，young区由Eden、S01区（from Survivor）和S02（To Survivor）区组成</p><h4 id="2-1-Young区"><a href="#2-1-Young区" class="headerlink" title="2.1 Young区"></a>2.1 Young区</h4><p>Young区是Java虚拟机堆中的一个部分，也称为年轻代，是对象分配的主要区域之一</p><p>Young区又被划分为三个部分：<strong>Eden区</strong>、<strong>Survivor区</strong>（From Survivor和To Survivor，也称From和To区）</p><p><strong>分配流程</strong></p><p><strong>Eden区是对象分配的初始区域，在Eden区分配的对象称为新生对象。</strong>当Eden区没有足够的空间分配新生对象时，会触发一次Minor GC，把Eden区中无用的对象及存活的对象移动到Survivor区，如果Survivor区空间不够，则使用分配担保机制把存活的对象移动到老年代中</p><p><strong>Survivor区分为两个大小相等的区域，分别称为From Survivor和To Survivor</strong>。在Survivor区中存活的对象会被移动到另一个Survivor区，而非直接移动到老年代。在进行Minor GC的时候，会把Eden区和一个Survivor区中的存活对象复制到另一个Survivor区中，如果Survivor区空间不够，则同样使用分配担保机制把存活的对象移动到老年代中</p><p><strong>内存划分</strong></p><p>在Young区当中，按照内存大小划分，Eden:S0:S1 &#x3D; 8:1:1</p><p>这是因为在Young区的对象大多是朝生夕死的，生命周期十分短暂，因此需要将Eden区的内存设置的大一点，而Survivor区两个部分设置的一样大小，是因为在Young区采用的GC算法是标记-复制算法，幸存对象会在From和To区之间来回复制，所以需要保持内存大小相同</p><p>更加详细的GC算法后面会分析到，此处不再赘述</p><p><strong>对象晋升</strong></p><p>年轻代中对象晋升到老年代的方式有两种，一种是根据对象年龄晋升，另一种是在新生代中存活的对象达到一定比例后直接晋升</p><p><strong>1）根据对象年龄晋升</strong></p><p>年轻代分为 Eden 区和两个 Survivor 区，当一个对象在 Eden 区出生并经过第一次 Minor GC 后仍然存活，则会被复制到第一个 Survivor 区中，并将对象年龄设为 1。当 Survivor 区中的对象再次经过 Minor GC 后仍然存活，则会被复制到另一个 Survivor 区中，并将对象年龄加 1。当对象年龄达到一定阈值（默认为 15 岁）时，该对象会被晋升到老年代中</p><blockquote><p>需要注意的是，如果设置了 <code>-XX:+NeverTenure</code> 参数，则所有对象都不会晋升到老年代</p></blockquote><p><strong>2）存活对象直接晋升</strong></p><p>当年轻代进行一次 Minor GC 后存活的对象占比达到一定值（默认为 50%），就会直接将这些对象晋升到老年代。这个阈值可以通过 JVM 参数 <code>-XX:MaxTenuringThreshold</code> 来调整</p><h4 id="2-2-Old区"><a href="#2-2-Old区" class="headerlink" title="2.2 Old区"></a>2.2 Old区</h4><p>老年代（Old Generation）是Java堆的一部分，用于存储生命周期较长的对象。通常情况下，新生代的对象会被多次垃圾回收（Minor GC），而老年代中的对象则会经历较少的垃圾回收（Major GC或Full GC）。由于老年代中的对象数量较少，所以垃圾回收时的性能相对较低</p><p>老年代的大小一般要大于新生代，因为老年代中存储的对象寿命更长，而且垃圾回收时的性能相对较低，需要更大的空间来存储和管理对象。在一些JVM的实现中，老年代的大小是可以调整的，以适应不同的应用场景</p><blockquote><p>一般来说，建议将老年代的大小设置为整个堆内存的50%到70%左右，这样可以在一定程度上平衡新生代和老年代的内存分配，提高应用的性能和稳定性</p></blockquote><h3 id="3-虚拟机栈"><a href="#3-虚拟机栈" class="headerlink" title="3.虚拟机栈"></a>3.虚拟机栈</h3><p>虚拟机栈是Java虚拟机运行时数据区之一，用于存储线程的局部变量、操作数栈、方法出口等信息。每个线程在创建时都会创建一个对应的虚拟机栈，用于存储该线程的方法执行过程中的临时数据</p><p>虚拟机栈由栈帧（Stack Frame）组成，每个栈帧对应着Java方法的执行，即在一个线程中，一个方法对应着一个栈帧</p><p>既然方法对应的是栈帧，那么栈帧内部对应的自然就是方法里面可能会有的一些东西了</p><p>栈帧包含局部变量表（Local Variable Table）、操作数栈（Operand Stack）、动态链接（Dynamic Linking）和方法出口（Return Address）等信息</p><img src="https://static-2w2.pages.dev/post/jvmstack.png" alt="image-20230409141152351" style="zoom:33%;" /><p>对应一下关系：</p><ul><li>局部变量表：用于存放方法中定义的局部变量和参数，它的大小在编译期就已经确定了</li><li>操作数栈：用于存放方法执行时所需要的操作数，比如加、减、乘、除等运算的操作数。操作数栈的大小在编译期也已经确定</li><li>动态链接：动态链接是指在程序运行期间进行的链接过程，将代码中使用到的符号引用和方法调用映射到实际内存地址的过程</li><li>方法返回地址：用于存放方法返回时的返回地址</li></ul><p>其中，动态链接和类加载时的“链接”中的“解析”步骤作用类似，将符号引用转换为直接引用</p><p>但是他们的时机不同，前者是类加载时进行的，后者是程序运行时进行的</p><blockquote><p>方法的递归调用就是利用栈帧实现的，递归一次就会生成一个栈帧，这也是为什么不设置递归出口，或者递归此时过多最终会报StackOverflowError的错误</p></blockquote><h3 id="4-本地方法栈"><a href="#4-本地方法栈" class="headerlink" title="4.本地方法栈"></a>4.本地方法栈</h3><p>本地方法栈（Native Method Stack）是与虚拟机栈类似的一块内存区域，但其是为虚拟机执行本地方法（Native Method）服务的，也就是用来执行本地方法的栈。与虚拟机栈类似，本地方法栈也是线程私有的，其生命周期与线程相同</p><p>与虚拟机栈的区别在于，虚拟机栈为Java方法服务的，<strong>而本地方法栈则是为本地方法服务的</strong>。本地方法是使用其他语言（如C&#x2F;C++）实现的方法，因此其执行方式不同于Java方法，需要使用不同的栈来支持本地方法的执行</p><p>本地方法栈的内部结构与虚拟机栈类似，也由栈帧（Stack Frame）组成。栈帧中包含了本地方法的参数、返回值和局部变量等信息。和虚拟机栈一样，本地方法栈也需要检查溢出。当栈空间无法容纳新的栈帧时，会抛出StackOverflowError异常。与虚拟机栈类似，本地方法栈的大小也可以通过参数进行调节</p><h3 id="5-程序计数器"><a href="#5-程序计数器" class="headerlink" title="5.程序计数器"></a>5.程序计数器</h3><p><strong>程序计数器是一块内存空间，它的作用是记录正在执行的线程下一条指令的地址</strong>，是线程私有的</p><p>程序计数器和虚拟机栈中的方法返回地址有相似之处</p><p><strong>相似之处</strong>：</p><p>都是为了支持Java程序的方法调用和返回</p><p><strong>不同之处</strong>：</p><ul><li>程序计数器记录的是当前线程正在执行的字节码指令的地址</li><li>而虚拟机栈中的方法返回地址则是指向方法返回后继续执行的字节码指令地址</li><li>另外，程序计数器不会发生OutOfMemoryError异常，而虚拟机栈则可能会发生</li></ul><h2 id="四、综合理解"><a href="#四、综合理解" class="headerlink" title="四、综合理解"></a>四、综合理解</h2><h3 id="1-区域交互"><a href="#1-区域交互" class="headerlink" title="1.区域交互"></a>1.区域交互</h3><p>上面介绍了虚拟机栈的相关概念，那么虚拟机栈是如何跟其他区域进行交互的呢？运行时数据区的各区之间是如何交互的呢？</p><h4 id="1-1-栈指向堆"><a href="#1-1-栈指向堆" class="headerlink" title="1.1 栈指向堆"></a><strong>1.1 栈指向堆</strong></h4><p>假如栈帧中的变量，为符号引用，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>这时候的栈中元素肯定指向了堆，因为这个对象在堆内存中开辟空间进行存储</p><p><img src="https://static-2w2.pages.dev/post/stackToHeap.png" alt="image-20230409141757104"></p><h4 id="1-2-方法区指向堆"><a href="#1-2-方法区指向堆" class="headerlink" title="1.2 方法区指向堆"></a><strong>1.2 方法区指向堆</strong></h4><p>方法区中会存放静态变量，常量等数据。如果是下面这种情况，就是典型的方法区中元素指向堆中的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object obj=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><img src="https://static-2w2.pages.dev/post/methodToHeap.png" alt="image-20230409141951577" style="zoom:33%;" /><h4 id="1-3-堆指向方法区"><a href="#1-3-堆指向方法区" class="headerlink" title="1.3 堆指向方法区"></a><strong>1.3 堆指向方法区</strong></h4><p>方法区中会包含类的相关信息，堆中则存储构建的类对象，所以如果想根据对象获取类相关信息，肯定有一个能够从堆去方法区找类信息的指向</p><img src="https://static-2w2.pages.dev/post/heapToMethod.png" alt="image-20230409142224093" style="zoom:33%;" /><h3 id="2-对象布局"><a href="#2-对象布局" class="headerlink" title="2.对象布局"></a>2.对象布局</h3><p>对象分配在堆内存当中，由三部分组成：对象头、实例数据和对其填充</p><img src="https://static-2w2.pages.dev/post/obj.png" alt="image-20230409143026721" style="zoom: 50%;" /><ul><li>对象头<ul><li>Mark Word：<ul><li>锁标志位：用于记录对象是否被锁定，如果为0，则表示对象没有被锁定；如果为1，则表示对象被轻量级锁定；如果为10，则表示对象被重量级锁定；如果为11，则表示对象是可偏向的</li><li>偏向线程ID：用于记录偏向锁定的线程ID</li><li>偏向时间戳：用于记录上一次偏向锁定的时间戳</li><li>分代年龄：用于记录对象的分代年龄，当对象在新生代中经历了一次Minor GC，如果存活下来，则分代年龄+1，当分代年龄达到一定值时，就可以晋升到老年代中</li><li>HashCode：用于记录对象的哈希码，如果对象的哈希码没有被计算过，则JVM会对对象进行哈希码的计算，并将结果存储在Mark Word中</li></ul></li><li>Class Pointer：指向方法区中的类信息</li><li>Length：主要用于数组长度保存</li></ul></li><li>实例数据：对象真正存储的数据，包括类的字段信息以及从父类继承下来的字段信息，以及一些对象实例相关的数据</li><li>对其填充：对齐填充的主要目的是为了确保对象实例在内存中的起始地址是8字节的整数倍。这是因为现代处理器在访问内存时，通常会将内存按照一定的块大小（比如64字节）进行读取和写入，而不是逐字节地进行操作。如果对象实例的起始地址不是8字节的整数倍，就可能会导致需要进行跨块读取或写入操作，这样就会影响读写效率</li></ul><p>其中，对象头中的Mark World在之前介绍<a href="https://yzj.life/2023/03/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/#3-MarkWord%E5%AF%B9%E8%B1%A1%E5%A4%B4">sychronized锁</a>时就已有涉及，使用锁标志位来记录对象的锁状态</p><h3 id="3-对象创建"><a href="#3-对象创建" class="headerlink" title="3.对象创建"></a>3.对象创建</h3><p>上面介绍了那么多，那么一个对象的具体创建过程，都经历了什么呢？</p><p>下面是对象在堆上分配的过程</p><p><img src="https://static-2w2.pages.dev/post/jvm-life.png" alt="image-20230409144502716"></p><p>GC划分</p><p>Minor GC：新生代</p><p>Major GC：老年代</p><p>Full GC：新生代+老年代</p><blockquote><p>1.7和之前Full GC还要加上永久代</p></blockquote><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>除了程序计数器之外，其他区域都可能发生OOM。具体而言：</p><ul><li>在堆中，由于存放了大量的对象实例，当堆空间被占满之后，就会导致OOM异常。当然，通过调整堆大小、调整垃圾回收策略等方式，可以尽可能地延缓这个过程</li><li>在方法区（HotSpot虚拟机中是永久代或元空间）中，存放了类的信息、常量池等数据，当存储的数据过多，导致方法区满了，就会抛出OOM异常。Java 8之后，方法区被元空间所取代，但同样可能会因为存储过多的元数据而导致OOM异常</li><li>在虚拟机栈和本地方法栈中，由于存储了方法的局部变量、参数、返回值等数据，当调用的方法层次过深，导致栈空间不足，就会发生栈溢出异常。栈空间的大小是可以通过参数进行调整的，但是过小的栈空间会限制程序的运行，过大的栈空间会占用过多的内存</li></ul><p>此外，堆内存只所以设计成目前的样子，最主要的目的就是要配合GC合理的对堆上对象进行管理，所以有哪些GC算法，都有什么特征，这些GC算法都怎么用呢？后面都会讨论</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql（二）MySql事务与锁</title>
      <link href="/2023/01/17/MySql%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/01/17/MySql%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><p><strong>什么是事务？</strong></p><p>在数据库中，事务（Transaction）是指一系列数据库操作序列，这些操作要么全部执行成功，要么全部执行失败回滚，是保证数据库一致性、完整性和隔离性的基本单位。</p><p><strong>为什么要有事务？</strong></p><p>事务是为了保证数据的一致性、可靠性和隔离性而引入的概念。</p><p>在一个复杂的业务逻辑中，可能包含多个操作，如果这些操作不能保证同时成功或同时失败，就会导致数据的不一致性和不可靠性，甚至会损害数据的完整性。而通过引入事务机制，可以将多个操作视为一个整体，要么全部成功，要么全部失败，保证了数据的一致性和可靠性。</p><p>经典的转账问题，扣款成功了，但是另一个账户因为宕机没转成功，怎么办？</p><p><strong>事务适用场景有哪些？</strong></p><ul><li>要求数据的完整性和一致性的场景，例如银行转账、股票交易等，这些操作都需要在一个事务内完成，保证数据的完整性和一致性。</li><li>高并发场景，例如电商网站的订单处理，会有大量的订单并发写入数据库，使用事务可以保证并发操作的正确性和效率。</li><li>多表操作场景，例如多表关联查询、插入、更新和删除操作，这些操作涉及到多个表的数据，使用事务可以保证数据的一致性，避免出现脏数据。</li></ul><h3 id="2-哪些存储引擎支持事务？"><a href="#2-哪些存储引擎支持事务？" class="headerlink" title="2.哪些存储引擎支持事务？"></a>2.哪些存储引擎支持事务？</h3><p>在MySql中，除了做集群的NDB之外，只有InnoDB支持事务，这也是为什么它能成为默认的存储引擎</p><h3 id="3-事务特性"><a href="#3-事务特性" class="headerlink" title="3.事务特性"></a>3.事务特性</h3><ul><li>原子性（Atomicity）：事务是一个原子操作，要么全部执行成功，要么全部失败回滚<ul><li>使用undo log记录事务开始前的状态，如果事务失败则根据日志回滚</li></ul></li><li>一致性（Consistency）：事务执行前后，数据从一个合法状态变为另一个合法状态，不会破坏数据库的完整性和一致性约束<ul><li>其他三个特性最终就是要完成一致性</li></ul></li><li>隔离性（Isolation）：多个事务之间相互隔离，每个事务都应该感知不到其他事务对数据库的修改。防止多个事务并发执行时发生脏读、不可重复读、幻读等问题<ul><li>加锁</li></ul></li><li>持久性（Durability）：事务执行成功后，对数据库所作的修改将永久保存在数据库中，即使发生系统故障也不会丢失<ul><li>事务提交成功后的修改是永久性的，不会因为掉电、宕机、意外重启等变成原来状态</li></ul></li></ul><p>考虑下之前说过的，InnoDB崩溃恢复是通过什么手段来实现的呢？</p><p>即<a href="https://yzj.life/2023/04/07/MySql%EF%BC%88%E4%B8%80%EF%BC%89/#4%EF%BC%89Redo-Log">redo log</a>和<a href="https://yzj.life/2023/04/07/MySql%EF%BC%88%E4%B8%80%EF%BC%89/#8%EF%BC%89%E5%8F%8C%E5%86%99%E7%BC%93%E5%86%B2">双写缓冲</a></p><p>InnoDB的写是先写入到缓冲池Buffer Pool之中的，这个时候出现异常依赖redo log恢复</p><p>而刷盘过程中出现异常，则主要依赖双写缓冲来恢复现场</p><h3 id="4-数据库事务出现时机"><a href="#4-数据库事务出现时机" class="headerlink" title="4.数据库事务出现时机"></a>4.数据库事务出现时机</h3><p>在使用MyBatis的时候，一般是通过在方法上增加注解@Transaction来标明事务，那么其他情况下MySql就不执行事务了吗？Mysql的事务究竟是什么条件下能够触发呢？</p><h4 id="4-1-自动触发"><a href="#4-1-自动触发" class="headerlink" title="4.1 自动触发"></a>4.1 自动触发</h4><p>在MySql中，默认情况下，<strong>单独的</strong>增删改Sql语句都会触发事务，并且自动提交落到磁盘</p><p>需要注意的是，在InnoDB中，每个事务都有专属于自己的编号，这个编号是递增的</p><h4 id="4-2-手动触发"><a href="#4-2-手动触发" class="headerlink" title="4.2 手动触发"></a>4.2 手动触发</h4><p>那如果想要将多条语句放到一个事务里面执行，要怎么开启呢？</p><p>在MySql里面，手动开启事务有两种方式</p><ul><li>begin</li><li>start transaction</li></ul><p>那开启后如何结束呢？</p><ul><li>rollback：回滚</li><li>commit：正常提交</li><li>客户端连接断开</li></ul><blockquote><p>事务的自动提交可以根据参数设置，比如mybatis在实现事务时，就将事务的自动提交给关闭了</p></blockquote><h3 id="5-事务并发"><a href="#5-事务并发" class="headerlink" title="5.事务并发"></a>5.事务并发</h3><p>在java中，多线程并发可能会导致一些预料之外的事情出现，那么在MySql中，事务并发会出现什么问题呢？</p><h4 id="5-1-脏读"><a href="#5-1-脏读" class="headerlink" title="5.1 脏读"></a>5.1 脏读</h4><p>假设在一个银行系统中，用户A账户余额为1000元，同时有两个事务T1和T2。</p><p>事务T1: A账户余额减去100元，余额变为900元。</p><p>事务T2: A账户余额增加200元，余额变为1200元。</p><p>假设T1先执行，然后在T1执行的过程中，T2也开始执行但是还未提交。此时，如果有一个查询操作读取了账户A的余额，它将读取到的是未提交的T2的数据，即A账户的余额为1200元。如果T2在后面执行失败或者回滚，A账户的余额应该是原来的1000元，但是因为脏读，查询到的余额为1200元，导致数据不一致</p><blockquote><p>脏读是指在数据库中，一个事务读取到了另一个事务未提交的数据。如果该事务后续回滚，那么读取到的数据就是无效的，称为“脏数据”</p><p>脏读是一种可能会导致数据不一致性的问题，因为读取到的数据实际上是未经过确认的数据</p></blockquote><h4 id="5-2-不可重复读"><a href="#5-2-不可重复读" class="headerlink" title="5.2 不可重复读"></a>5.2 不可重复读</h4><p>假设有一个学生表，包含学生姓名和年龄字段。事务T1想要查询该表中年龄在20岁以下的所有学生，并将他们的年龄加1。同时，另一个事务T2在T1查询数据期间将一个20岁以下的学生的年龄从19岁修改为21岁。</p><ul><li>T1查询该表中年龄在20岁以下的所有学生，并将他们的年龄加1，得到一个名为A的学生，年龄由19岁变为了20岁。</li><li>在T1的事务中，再次查询该表中年龄在20岁以下的所有学生，发现A学生已经不符合条件了。</li></ul><p>这个例子中，同一个事务内进行了两次查询，但是得到的结果却不一样，因为另一个事务在T1查询期间修改了数据。这就是不可重复读</p><blockquote><p>不可重复读（Non-repeatable read）是指在同一个事务中，多次读取同一条记录，但是得到的结果不一致</p><p>这是因为在这个事务中，其他事务可能已经<strong>修改或删除</strong>了这条记录，导致当前事务读取的结果与之前不同，因此称为不可重复读</p></blockquote><h4 id="5-3-幻读"><a href="#5-3-幻读" class="headerlink" title="5.3 幻读"></a>5.3 幻读</h4><p>假设有一个银行账户表，其中有一个字段是账户余额。现在有两个事务同时执行：</p><p>事务A：查询账户表中账户余额在1000到2000之间的所有记录。</p><p>事务B：插入一条记录，账户余额为1500。</p><p>在事务A中，由于B事务插入的数据满足查询条件，所以查询结果中会包含这条新插入的记录，导致出现幻读的现象</p><blockquote><p>幻读指在一个事务执行过程中，由于并发的其他事务新增数据行，导致当前事务查询时出现了与之前不同数量的数据行</p></blockquote><p>那么不可重复读和幻读区别在哪呢？</p><ul><li><strong>查询条件</strong>：不可重复读是读取某一行数据前后结果不一；而幻读是读取某一范围内数据行前后不一致的情况</li><li><strong>执行操作</strong>：不可重复读可能由并发事务更新与删除造成，而幻读是由并发事务插入造成的问题</li></ul><h3 id="6-隔离级别"><a href="#6-隔离级别" class="headerlink" title="6.隔离级别"></a>6.隔离级别</h3><p>事务隔离级别有很多行业标准，最常见的是SQL92标准，在SQL92标准中，关于数据库隔离级别的定义如下</p><ul><li><strong>读未提交（read uncommitted）</strong>：允许脏读，事务可以读取到其他未提交事务修改的数据</li><li><strong>读已提交（read committed）</strong>：禁止脏读，事务只能读取到已经提交的数据。一个事务开始时，会获取一个可重复读的快照，每次查询都会使用这个快照，因此会出现在一个事务内多次查询到不同的结果的情况</li><li><strong>可重复读（repeatable read）</strong>：禁止脏读和不可重复读，保证事务执行过程中读取到的数据不变，即多次读取同一数据时结果相同。与读已提交不同的是，在一个事务中多次查询同一数据时，每次查询都会使用最初的快照，而不会使用当前已提交的数据</li><li><strong>串行化（serializable）</strong>：禁止脏读、不可重复读和幻读，是最高的隔离级别。在串行化级别下，事务串行执行，确保每个事务的操作都不会被其他事务干扰</li></ul><p>InnoDB默认采用RR，即可重复读的隔离级别，在这个隔离级别下，InnoDB已解决了幻读问题，后面详细介绍如何解决的</p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（Read Uncommited）</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>读已提交（Read Commited）</td><td><strong>不可能</strong></td><td>可能</td><td>可能</td></tr><tr><td>可重复读（Repeatable Read）</td><td><strong>不可能</strong></td><td><strong>不可能</strong></td><td><em><strong>对InnoDB不可能</strong></em></td></tr><tr><td>串行化（Serializable）</td><td><strong>不可能</strong></td><td><strong>不可能</strong></td><td><strong>不可能</strong></td></tr></tbody></table><h3 id="7-隔离实现"><a href="#7-隔离实现" class="headerlink" title="7.隔离实现"></a>7.隔离实现</h3><p>如果要解决读一致性的问题，保证一个事务中前后两次读取数据结果一致，实现事务隔离，应该怎么做呢？</p><p>这里有两类解决方案，加锁或者快照</p><h4 id="7-1-LBCC"><a href="#7-1-LBCC" class="headerlink" title="7.1 LBCC"></a>7.1 LBCC</h4><p>很容易想到，如果要保持数据前后一致，那么加锁就行了</p><p>在读取数据的时候，锁定要操作的数据，不允许其他数据修改</p><p>这种方案称为基于锁的并发控制Lock Based Concurrency Control（LBCC）</p><p>但是如果读的时候不允许其他修改，那就是不支持并发的读写操作，而大多数应用都是读多写少的，因此这样会极大影响操作数据的效率</p><h4 id="7-2-MVCC"><a href="#7-2-MVCC" class="headerlink" title="7.2 MVCC"></a>7.2 MVCC</h4><p>那么加锁不行，还有什么办法呢？</p><p>在MySql的InnoDB引擎中，采用快照的策略，在修改数据之前建立一个备份或者叫快照，后面读的话就读这个快照就行了</p><p>这个方案被称为<strong>多版本并发控制</strong>Multi Version Concurrency Control（MVCC）</p><p><strong>MVCC原则如下</strong></p><p>一个事务能够看到的数据版本：</p><ul><li>第一次查询之前已经提交的事务的修改</li><li>本事务的修改</li></ul><p>一个事务不能够看见的数据版本：</p><ul><li>在本事务<strong>第一次查询</strong>之后创建的事务（即事务ID比自己的事务ID大）</li><li>活跃的（未提交的）事务的修改</li></ul><p><strong>MVCC效果如下</strong></p><p>一个事务，可以查到在自己开始之前就已经存在的数据，即使后面这个数据被删除或者修改了——因为查的是比自己早的快照</p><p>而在这个事务之后新增的数据，该事务无法查到——还是因为查的都是比自己早的快照</p><blockquote><p>注意是第一次查询之后才创建了本事务的ID</p></blockquote><h4 id="7-3-MVCC快照"><a href="#7-3-MVCC快照" class="headerlink" title="7.3 MVCC快照"></a>7.3 MVCC快照</h4><p>上面提到了MVCC快照，那么这个快照是如何实现的呢？</p><table><thead><tr><th>id</th><th>name</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td>1</td><td>zhangsan</td><td>01</td><td>NULL</td></tr></tbody></table><p>InnoDB为每个事务都分配了一个递增的编号，此外，它为每行记录都实现了两个隐藏字段</p><p><strong>DB_TRX_ID</strong>：6字节，表示事务ID</p><p>数据是在哪个事务插入或者修改为新数据的，就记录为当前事务ID</p><p><strong>DB_ROLL_PTR</strong>：7字节，回滚指针</p><p>数据被删除或记录为旧数据时，记录操作的事务ID，没这个操作就是NULL</p><p>由于MVCC保证一个事务只能读取比自己小的事务ID所标记的数据行，因此可以保证在同一个事务过程中，读取到的数据保持一致</p><p>但是如果数据被修改，事务ID变化，那当前事务如何保证能够读到这个数据修改之前的记录呢？</p><p>答案是undo log</p><p>在undo log之中，存放有数据的旧版本信息，同一条数据多次修改会形成一条数据链</p><p>而DB_ROLL_PTR就是指向undo log的指针</p><p>合理猜想，应该有一个数据结构，能够把当前事务ID，活跃事务ID，当前系统最大事务ID存储起来，这样才能进行判断</p><p>这个数据结构确实存在，被称为Read View（可视性视图），每个事务都会维护一个自己的Read View</p><table><thead><tr><th>m_ids{}</th><th>min_trx_id</th><th>max_trx_id</th><th>creator_trx_id</th></tr></thead><tbody><tr><td>列表，当前系统活跃的事务id</td><td>m_ids的最小值</td><td>系统分配给下一个事务的id</td><td>生成read view事务的事务id</td></tr></tbody></table><p>依靠这个数据结构，事务判断的可见性规则就如下所示：</p><ul><li>从数据的最早版本开始判断（依靠undo log）</li><li>数据版本的trx_id &#x3D; creator_trx_id，本事务修改，可改</li><li>数据版本的trx_id &lt; creator_trx_id（未提交事务的最小ID），说明这个版本在生成RedaView之前已经提交，可以访问</li><li>数据版本的trx_id &gt; creator_trx_id（下一个事务ID），这个版本是在生成ReadView之后开启事务建立的，不能访问</li><li>数据版本的trx_id在min_trx_id和max_trx_id之间，看看是否在m_ids之中<ul><li>如果在，不可以—未提交</li><li>不过不在，可以—已提交</li></ul></li><li>如果当前版本不可见，就找undo log链中的下一个版本</li></ul><p>需要注意的是，在RR隔离级别下，Read View只会在第一次查询时创建一次</p><p>而在RC隔离级别下，每次查询的时候都会创建一个Read View</p><blockquote><p>MVCC保证了一个事务在读取过程中，读取到的快照都是同一个，因此它其实算是在一定程度上解决了脏读，不可重复读与幻读问题，但是并不是完全解决</p><ul><li><p>脏读：可以被MVCC完全解决</p></li><li><p>不可重复读：不一定</p><ul><li>RC：事务每次查询都会创建快照，因此可能读到其他事务提交修改的数据</li><li>RR：全局只有一个事务第一次查询创建的快照</li></ul></li><li><p>幻读：不一定</p><ul><li><p>RC：事务每次查询都会创建快照，因此可能读到其他事务提交修改的数据</p></li><li><p>RR：全局只有一个事务第一次查询创建的快照</p></li></ul></li></ul><p>不确定，后面再改</p></blockquote><h2 id="二、锁"><a href="#二、锁" class="headerlink" title="二、锁"></a>二、锁</h2><h3 id="1-锁的粒度"><a href="#1-锁的粒度" class="headerlink" title="1.锁的粒度"></a>1.锁的粒度</h3><p>已知MyISAM仅支持表锁，InnoDB支持行锁，那行锁和表锁表现有什么区别呢？</p><ul><li>锁定粒度：表锁 &gt; 行锁</li><li>加锁效率：表锁 &gt; 行锁</li><li>冲突概率：表锁 &gt; 行锁</li><li>并发性能：表锁 &lt; 行锁</li></ul><p>事实上，在MySql官网把锁分为了8类</p><ul><li>共享锁&#x2F;互斥锁—行锁<ul><li>基本模式的锁</li></ul></li><li>意向共享锁&#x2F;意向互斥锁—表锁</li><li>Record Locks—行锁<ul><li>锁的算法</li></ul></li><li>Gap Locks—间隙锁<ul><li>锁的算法</li></ul></li><li>next-Key Locks—结合的行锁+间隙锁<ul><li>锁的算法</li></ul></li><li>插入意向锁<ul><li>特殊的间隙锁，允许多个事务同时插入数据到同一范围</li></ul></li><li>自增锁：特殊的表锁，用来防止自增字段重复，数据插入后就会释放，不需要事务提交<ul><li>0:traditional 每次自增都会产生表锁</li><li>1:consecutive 会产生一个轻量级锁，simple insert会获得批量的锁，保证连续插入，默认是这个</li></ul></li><li>Predicate Locks for Spatial Index<ul><li>5.7版本之后新增的一种数据类型的索引锁</li></ul></li></ul><h3 id="2-共享锁"><a href="#2-共享锁" class="headerlink" title="2.共享锁"></a>2.共享锁</h3><p>也称为读锁，行级锁，允许多个事务同时读取该行数据</p><p>共享锁应用：阻塞其他事务的修改，可用在不允许其他事务修改的情况下</p><p>如何加共享锁？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> ...... Lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure><p>如何释放共享锁？</p><ul><li>事务结束</li><li>使用命令显示释放</li></ul><h3 id="3-排他锁"><a href="#3-排他锁" class="headerlink" title="3.排他锁"></a>3.排他锁</h3><p>也称为写锁，行级锁，只要获取排他锁，就不允许其他事务再获取该行数据的读锁和写锁</p><p>排他锁应用：独占数据行，阻塞其他事务</p><p>如何加排他锁？</p><ul><li>操作数据时，增删改默认会加上排他锁</li><li>手动在后面使用for update加排他锁</li></ul><h3 id="4-意向锁"><a href="#4-意向锁" class="headerlink" title="4.意向锁"></a>4.意向锁</h3><p>数据库自己维护，包括意向共享锁与意向排他锁</p><p>意向锁是由Innodb自动维护的，为了提升加表锁的效率，那为何会出现呢？</p><p>思考下，如果加表锁之前，需要确定表中没有行锁，那如何确定？遍历吗？明显不靠谱</p><p>因此加行锁时，InnoDB会自动加上对应的意向锁，从而保证想要加表锁时能够快速的判断当前表中有没有行锁</p><p>意向共享锁（表锁）：表中加行级别共享锁时加上<br>意向排他锁（表锁）：表中加行级别排他锁时加上</p><p>事务结束自动释放</p><h3 id="5-行锁原理"><a href="#5-行锁原理" class="headerlink" title="5.行锁原理"></a>5.行锁原理</h3><h4 id="5-1-无索引表的行锁"><a href="#5-1-无索引表的行锁" class="headerlink" title="5.1 无索引表的行锁"></a>5.1 无索引表的行锁</h4><p>无索引即只能锁住记录</p><p>此时<strong>假设InnoDB锁住的是一行数据或者一条记录</strong></p><p>设有一张t1表，有两字字段，id和name，有1，2，3，4共4条记录</p><p>以下两个事务，先开启事务1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>事务2</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="operator">/</span><span class="operator">/</span> blocked</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">&#x27;t1&#x27;</span>(<span class="string">&#x27;is&#x27;</span>,<span class="string">&#x27;name&#x27;</span>) balues (<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;5&#x27;</span>); <span class="operator">/</span><span class="operator">/</span>blocked </span><br></pre></td></tr></table></figure><p>明明只是给id&#x3D;1加了锁，为什么事务2都会被阻塞呢？</p><p>事实上，这里整张表都被锁住了，即<strong>InnoDB的行锁，锁住的并不是Record</strong></p><p>具体原因后面解释，这里看下一个案例</p><h4 id="5-2-有主键索引的表"><a href="#5-2-有主键索引的表" class="headerlink" title="5.2 有主键索引的表"></a>5.2 有主键索引的表</h4><p>创建一个t2的表，与t1区别是在主键上加了主键索引</p><p>同样操作，事务1开启</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>事务2</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="operator">/</span><span class="operator">/</span> blocked</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">4</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="operator">/</span><span class="operator">/</span> OK</span><br></pre></td></tr></table></figure><p>可见在这里，使用不同的id加锁是可以加锁成功的</p><p>上面已经证实锁住的不是Record，<strong>那是不是锁住的id字段呢？</strong></p><p>继续看下一案例</p><h4 id="5-3-唯一索引"><a href="#5-3-唯一索引" class="headerlink" title="5.3 唯一索引"></a>5.3 唯一索引</h4><p>t3相比t2，是在name字段上加了唯一索引</p><p>同样操作，事务1开启</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;4&#x27;</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>事务2</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;4&#x27;</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="operator">/</span><span class="operator">/</span> blocked</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">4</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="operator">/</span><span class="operator">/</span> blocked</span><br></pre></td></tr></table></figure><p>这里发现，使用id插入也被阻塞了，所以上面的猜测也是错的，<strong>并不是锁住了id这个字段</strong></p><p>从上面案例可以看到，<strong>锁住的并不是record，也不是column</strong>，那么锁住的到底是什么呢？</p><p>事实上，<em><strong>InnoDB的行锁，是通过锁住索引来实现的</strong></em></p><p>这里回顾一下上面的几个问题</p><p><strong>1）为什么案例1里面，锁住一行数据会导致整张表都被锁住呢？</strong></p><p>在索引章节可以知道，如果一张表没有主键，也没有不包含NULL值的唯一索引列，那么就会选择6字节长的ROWID作为隐藏的聚集索引</p><p>在这种情况下，id&#x3D;1加锁，由于没有索引，会导致全表扫描，从而就把每一个隐藏索引都给锁住了</p><p><strong>2）案例2中，为什么通过给唯一索引加锁，也能锁住主键索引呢？</strong></p><p>因为回表查询，所以使用唯一索引加锁时，锁住的也是主键索引</p><h3 id="6-锁的算法"><a href="#6-锁的算法" class="headerlink" title="6.锁的算法"></a>6.锁的算法</h3><p>上面介绍的都是基本的锁，本节讨论点不一样的</p><p>还是上面的t2表，有主键索引，假如插入了主键为1，4，7，10的记录，那么在</p><p>Record Locks，Gap Locks，next-Key Locks三种锁中，锁的范围都是怎样的呢？</p><p><img src="https://static-2w2.pages.dev/post/locks.png" alt="image-20230408164649610"></p><p>这里面的主键都称为Record，所以这里有4个Record</p><p>主键之间不存在的区间就称为Gap，是一个左开右开的区间</p><p>而加上主键与Gap，构成的左开右闭的范围就称为Next-Key</p><h4 id="6-1-记录锁"><a href="#6-1-记录锁" class="headerlink" title="6.1 记录锁"></a>6.1 记录锁</h4><p>当使用唯一性的索引来查询数据，精准匹配到一条记录的时候，使用的就是记录锁，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">4</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>锁住的就是对应的id&#x3D;4的索引</p><h4 id="6-2-间隙锁"><a href="#6-2-间隙锁" class="headerlink" title="6.2 间隙锁"></a>6.2 间隙锁</h4><p>当查询的记录不存在时，没有命中任何一个record，这时候无论是用的等值查询还是范围查询，都是使用的间隙锁</p><p>首先回顾下，t2当中只有1，4，7，10这几条数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">4</span> <span class="keyword">and</span> id <span class="operator">&lt;</span> <span class="number">7</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="operator">/</span><span class="operator">/</span> 锁住(<span class="number">4</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="operator">/</span><span class="operator">/</span>锁住(<span class="number">4</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="operator">/</span><span class="operator">/</span>锁住(<span class="number">10</span>,<span class="operator">+</span>∞)</span><br></pre></td></tr></table></figure><p>需要注意，假如键值最大是10，那如果查询大于10的范围，锁住的范围也是从10开始的</p><h4 id="6-3-临键锁"><a href="#6-3-临键锁" class="headerlink" title="6.3 临键锁"></a>6.3 临键锁</h4><p>当使用范围查询，不仅命中了Record，还包含了Gap间隙，这时候加的就是临键锁</p><p>临键锁是MySql里面默认的行锁算法，相当于记录锁+间隙锁</p><p>因此，当使用唯一索引，匹配到的只有一条数据时，退化成记录锁</p><p>匹配不到的时候，就退化成间隙锁</p><p>还是t2表，如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">5</span> <span class="keyword">and</span> id <span class="operator">&lt;</span> <span class="number">9</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>此时命中了7，所以锁住了(4,7]+7+(7,10]</p><p>注意，不会锁一半间隙，所以这里并不是5和9作为边界</p><p>这也是为什么InnoDB能够在RR级别下解决幻读问题了，因为它这时候采用的就是临键锁</p><p>直接把两边间隙都锁住了，其他事务自然无法插入数据造成幻读了</p><h4 id="6-4-隔离级别实现"><a href="#6-4-隔离级别实现" class="headerlink" title="6.4 隔离级别实现"></a>6.4 隔离级别实现</h4><p>在这里总结下四个隔离级别的实现</p><ul><li>读未提交 Read Uncommited：不加锁</li><li>串行化 Serializable：所有select语句都会转化为共享锁执行，和update、delete互斥</li><li>读已提交 Read Commited：<ul><li>普通的select使用快照读，MVCC实现，每个事务查询生成一个视图</li><li>加锁的select使用记录锁</li><li>会出现幻读，因为没有锁住周边间隙</li></ul></li><li>可重复读 Repeatable Read：<ul><li>普通的select使用快照读，MVCC实现，但是全局用一个视图</li><li>加锁的select以及更新操作使用当前读，底层使用记录锁&#x2F;间隙锁&#x2F;临键锁</li><li>可解决幻读</li></ul></li></ul><blockquote><p>此外，外键约束检查以及重复键检查会用<strong>间隙锁</strong>封锁区间</p></blockquote><p>一般来说，使用默认的RR即可，但是也有用RC的，使用RC相比RR有哪些优点呢？</p><ul><li>RR间隙锁会导致锁定范围扩大</li><li>条件列未用到索引时，RR锁表，RC锁行</li><li>RC的“半一致性”读可以增加update操作的并发性</li></ul><p>在RC中，一个update语句，如果读到了一行已经加锁的记录，此时InnoDB返回记录最近提交的版本，由MySql上层判断此版本是否满足update的where条件</p><p>若满足，则MySql会重新发起一次读操作，读取行的最新版本(并加锁)</p><h3 id="7-死锁"><a href="#7-死锁" class="headerlink" title="7.死锁"></a>7.死锁</h3><p>锁具有互斥的特性，在并发编程中要避免死锁的出现，那在MySql中会不会出现死锁的情况呢？</p><p>在MySql中也是有死锁现象发生的，一个事务持有锁不释放，等待其他事务锁的释放，构成环就会导致死锁</p><h4 id="7-1-锁的释放与阻塞"><a href="#7-1-锁的释放与阻塞" class="headerlink" title="7.1 锁的释放与阻塞"></a>7.1 锁的释放与阻塞</h4><p>前面说过，锁的释放有以下两种情况：</p><ul><li>事务结束：rollback&#x2F;commit</li><li>客户端断开连接</li></ul><p>那么，如果有一个锁持有锁并一直不释放，会永久等待下去吗？</p><p>MySql有参数控制这种情况，默认50s后会释放锁</p><p>事实上，MySql不会等待50s再去释放，它一般通过算法（wait-for graph）是能够检测到死锁的发生的</p><p>死锁发生条件：</p><ul><li>同一时刻只能有一个事务持有锁</li><li>其他事务需要在这个事务释放之后才能获取锁，不可强行剥夺</li><li>多个事务形成等待环路</li></ul><p>因为死锁发生情况虽然复杂，但是都会满足以上三个条件，所以可通过算法检测到</p><h4 id="7-2-锁日志"><a href="#7-2-锁日志" class="headerlink" title="7.2 锁日志"></a>7.2 锁日志</h4><p>在MySql中，可以通过命令查看锁信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock_%&#x27;</span></span><br></pre></td></tr></table></figure><p>得到：</p><ul><li>Innodb_row_lock_current_waits：当前正在等待锁的数量</li><li>Innodb_row_lock_time：系统启动到现在锁定的总时间长度，ms</li><li>Innodb_row_lock_time_avg：每次等待所花平均时间</li><li>Innodb_row_lock__time_max：从系统启动到现在等待时机最长所花时间</li><li>Innodb_row_lock_waits：从系统启动到现在总共等待的次数</li></ul><p>此外，InnoDB还提供了三张表来分析事务与锁的情况</p><ul><li>查询当前运行的所有事务，和具体的语句</li><li>当前出现的锁</li><li>锁等待的对应关系</li></ul><h4 id="7-3-死锁避免"><a href="#7-3-死锁避免" class="headerlink" title="7.3 死锁避免"></a>7.3 死锁避免</h4><p>类似并发编程，MySql中也可以采用一些策略避免死锁</p><ul><li>在程序中，操作多张表时，尽量以相同的顺序访问（避免形成等待环路）</li><li>批量操作单张表数据的时候，先对数据进行排序（避免形成等待环路）</li><li>申请足够级别的锁，如果要操作数据，就申请排他锁</li><li>尽量使用索引访问数据，避免没有where条件的操作，避免锁表</li><li>如果可以，尽量把大事务化为小事务</li><li>使用等值查询而不是范围查询，减少间隙锁对并发影响</li></ul><h2 id="三、性能优化"><a href="#三、性能优化" class="headerlink" title="三、性能优化"></a>三、性能优化</h2><p>性能优化是经常问到的问题，说到数据库性能优化，最常见的思路是什么呢？</p><p>或者说慢SQL如何去优化？</p><p>数据库性能优化，需要从每个环节下手考虑，每个环节都有可以进行优化的地方</p><p><img src="https://static-2w2.pages.dev/post/mysqlProcess.png" alt="image-20230408173557933"></p><h3 id="1-连接——配置优化"><a href="#1-连接——配置优化" class="headerlink" title="1.连接——配置优化"></a>1.连接——配置优化</h3><p>连接可能有什么性能问题呢？</p><p>因为连接数是有上限的，所以达到上限后，新的请求获取不到连接，就会报错</p><p>如何优化呢？</p><p>从两个方面，分别是服务端与客户端</p><h4 id="1-1-服务端"><a href="#1-1-服务端" class="headerlink" title="1.1 服务端"></a>1.1 服务端</h4><ul><li>增加可用连接数—可通过修改参数max_connextions实现</li><li>释放不活动的连接—把默认释放时机调小</li></ul><h4 id="1-2-客户端"><a href="#1-2-客户端" class="headerlink" title="1.2 客户端"></a>1.2 客户端</h4><p>不要每一个请求都新建连接，使用连接池技术</p><p>Druid默认连接池大小是8，Hikari是10</p><p>Hikari给出的文档说PostgreSQL建议设置：机器核数*2+1</p><p>为什么不是连接数越多越好呢？</p><p>因为cpu核数有限，而每一个连接都需要一个线程去处理，过多的连接就会产生过多的线程，从而频繁的上下文切换，导致效率降低</p><h3 id="2-架构优化"><a href="#2-架构优化" class="headerlink" title="2.架构优化"></a>2.架构优化</h3><h4 id="2-1-缓存"><a href="#2-1-缓存" class="headerlink" title="2.1 缓存"></a>2.1 缓存</h4><p>很常用的技术，对于一些慢查询，比如涉及的数据量太大，关联的表过多，反正就是导致查询缓慢的操作，如果变更频率不高，就可以使用redis缓存技术加速访问</p><p>从数据一致性角度考虑，缓存的数据不能是频繁更新的，此外要设置过期时间，保证数据的最终一致性</p><p>这里属于架构层面的优化</p><h4 id="2-2-集群——主从复制"><a href="#2-2-集群——主从复制" class="headerlink" title="2.2 集群——主从复制"></a>2.2 集群——主从复制</h4><p>这主要是提高系统可用性，保证不会一台机器挂了整个服务都挂了</p><p>此外使用读写分离，主写从读也可以提升系统整体效率</p><p>那么使用集群就必然要考虑集群间的数据同步了，MySql的主从复制如何实现的呢？</p><p>前面说过，MySql的所有更新语句都会使用binLog日志进行记载，从数据库根据master传过来的binlog即可同步数据与master一致</p><p>那么binlog是如何同步的呢？</p><p>在master上有一个log dump线程，专门用来把binlog发送给slave</p><p>而从库的sql线程，也会读取relay log，把数据写入数据库</p><p>之后就可以愉快的读写分离了，把写的任务交给master，读的任务交给slave</p><h4 id="2-3-分库分表"><a href="#2-3-分库分表" class="headerlink" title="2.3 分库分表"></a>2.3 分库分表</h4><p>分库分表也是常用的优化手段，包括垂直分库与水平分库分表</p><p>垂直分库：把一个水库按照业务拆分成不同的数据库，即拆列</p><p>水平分库分表：把一张数据量很大的大表，按行拆分成很多个小表</p><h3 id="3-优化器——SQL语句分析与优化"><a href="#3-优化器——SQL语句分析与优化" class="headerlink" title="3.优化器——SQL语句分析与优化"></a>3.优化器——SQL语句分析与优化</h3><p>除了从配置与架构上优化，最常见的就是sql语句的优化了</p><p>优化sql语句的前提是找到慢sql，如何找到呢？</p><h4 id="3-1-慢查询日志"><a href="#3-1-慢查询日志" class="headerlink" title="3.1 慢查询日志"></a>3.1 慢查询日志</h4><p>默认是关闭慢查询日志的，因为保持开启需要一定的代价，可以配置开启</p><p>设置超过多久的语句为慢sql语句，默认10s</p><p>获得慢查询日志后，可以通过工具mysqldumpslow来分析</p><p>还有一些其他系统命令可以监控mysql，此处不再赘述</p><p>因为在企业中，一般都有专门的工具与告警来监控慢查询语句</p><h4 id="3-2-慢查询优化"><a href="#3-2-慢查询优化" class="headerlink" title="3.2 慢查询优化"></a>3.2 慢查询优化</h4><p>通常来说，慢sql优化需要分析该sql的执行计划，如何查看呢？</p><p>使用explain关键字，在sql前面加上该关键字即可查看sql的执行计划</p><blockquote><p>在MySql5.6.3之前只能使用explain分析select，在之后就可以分析update、delete和insert命令了</p></blockquote><p>explain会查出来很多列，如下表，那么这些列都代表什么意思呢？下面逐个分析</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>t1</td><td>NULL</td><td>const</td><td>PRIMARY</td><td>PRIMARY</td><td>4</td><td>const</td><td>1</td><td>100.00</td><td>Using index</td></tr><tr><td>1</td><td>SIMPLE</td><td>t2</td><td>NULL</td><td>ref</td><td>fk_t2_t1</td><td>fk_t2_t1</td><td>5</td><td>test_db.t1.id</td><td>2</td><td>100.00</td><td>Using index</td></tr></tbody></table><p><strong>①id</strong></p><p>id是查询序列编号，一个select就有一个序号，可表示查询顺序</p><p>id值不同：先查询id值大的</p><p>id值相同：根据结果从上往下执行</p><p><strong>②select_type</strong></p><p>不同字段值含义不同，下面是常见的值</p><ul><li><code>SIMPLE</code>：表示这是一个简单的 <code>SELECT</code> 查询，不包含子查询或者联合查询</li><li><code>PRIMARY</code>：表示这是一个包含多个表的查询语句中最外层的 <code>SELECT</code> 查询</li><li><code>SUBQUERY</code>：表示这是一个子查询，MySQL 会在查询执行前执行子查询，然后将其结果传递给外层查询</li><li><code>DERIVED</code>：表示这是一个子查询，MySQL 会将其结果存储在一个临时表中，然后执行外层查询，查询中使用的子查询都被标记为 <code>DERIVED</code></li><li><code>UNION</code>：表示这是一个联合查询，包含多个 <code>SELECT</code> 语句，并且使用 <code>UNION</code> 连接</li><li><code>UNION RESULT</code>：表示这是一个联合查询中的结果集</li></ul><p>除了上述几个常见的取值之外，<code>select_type</code> 还可能出现一些其他取值，例如 <code>DEPENDENT UNION</code>、<code>UNION DISTINCT</code>、<code>DEPENDENT SUBQUERY</code> 等等，这些取值的含义需要根据具体的查询语句来理解</p><p><strong>③type</strong></p><ul><li><strong>system</strong>：表只有一行记录（system表），这是const类型的特例，平常不会出现，优化器不会选择这个访问类型</li><li><strong>const</strong>：使用常数值（如主键或unique索引等）进行查询。这种情况下MySQL在查询之初就可以确定结果，因此查询只会执行一次，是最优的访问类型</li><li><strong>eq_ref</strong>：对于每个索引键，表中只有一条记录与之匹配。常见于使用主键或唯一索引进行等值查询的情况。此类型比ref访问更加优秀，因为索引是唯一的，所以无需执行扫描</li><li><strong>ref</strong>：使用非唯一索引或者唯一索引的非前导列进行等值查询，会返回匹配到的所有行。ref查询通常会使用索引进行访问，但可能会执行全表扫描，例如IN操作符中的查询列表中不同的值超过了索引中的键数时</li><li><strong>range</strong>：对索引进行范围查询，常见于使用BETWEEN、IN等操作符的查询</li><li><strong>index</strong>：Full Index Scan，扫描整个索引，和All访问类型类似，只不过只扫描索引而不扫描数据</li><li><strong>all</strong>：Full Table Scan，遍历全表，效率最低，应尽量避免</li></ul><p>根据以上取值优化顺序从最优到最差为：system、const、eq_ref、ref、range、index、all</p><p>而在实际开发中，system，const，eq_ref都是可遇不可求的，很难优化到这个状态</p><p>比较常见的是ref及之后的这些</p><p>尽量优化到ref&#x2F;range，而all和index都是需要被优化的</p><p><strong>④possible_key、key</strong></p><p>分别表示可能用到的索引与实际用到的索引，如果NULL就是没用到索引</p><p>所以如果分析后发现没有用到索引，就要检查SQL或者创建索引</p><p><strong>⑤key_len</strong></p><p>索引的长度，一般不怎么关注</p><p><strong>⑥rows</strong></p><p>估算所需扫描的行数</p><p><strong>⑦filtered</strong></p><p>表示此查询条件所过滤掉的数据百分比</p><p>如果比例很低，说明存储引擎返回的数据要经过大量过滤，是比较消耗性能的，需要关注</p><p><strong>⑧ref</strong></p><p>表示上述索引的哪个列被使用了，常见的取值为表的列名或常量</p><p><strong>⑨Extra</strong></p><p>Extra是一列用于提供关于查询优化器使用的额外信息的字段。它可以告诉我们很多关于查询执行的细节信息，例如使用了哪些索引、使用了哪些算法、数据来源等等</p><ul><li><em>Using index</em>: 表示查询使用了覆盖索引，所有需要的数据都可以从索引中获取，而不需要回到数据表中读取行。</li><li><strong>Using temporary</strong>: 表示MySQL需要创建临时表来处理查询，例如在GROUP BY或ORDER BY中使用了不在索引列中的列，或者使用了不同的存储引擎等。</li><li><strong>Using filesort</strong>: 表示MySQL需要对结果集进行排序，但是无法使用索引完成排序，因此需要创建临时表并进行文件排序。</li><li>Using join buffer: 表示MySQL使用了连接缓存，连接缓存是MySQL用于优化连接查询的一种内存结构。</li><li>Range checked for each record: 表示MySQL在执行查询时使用了索引范围扫描，对于每一行记录都需要进行索引范围判断，这可能会导致性能问题。</li><li><em>Using where:</em> 表示MySQL使用了WHERE子句过滤数据。</li><li>Using index condition: 表示MySQL使用了索引条件过滤数据，例如使用了WHERE子句中的等值条件；也就是上面提到过的<a href="https://yzj.life/2023/04/07/MySql%EF%BC%88%E4%B8%80%EF%BC%89/#4%EF%BC%89%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%EF%BC%88ICP%EF%BC%89">索引下推</a></li><li>Using sort_union: 表示MySQL使用了多个排序结果集的合并排序，通常是通过UNION或UNION ALL实现的。</li><li>Using intersect: 表示MySQL使用了多个结果集的交集，通常是通过INTERSECT实现的。</li><li>Using index for group-by: 表示MySQL使用了索引来执行GROUP BY操作，这通常可以减少排序操作的成本。</li></ul><p>上述字段中，最常见的是是 Using where 和 Using index</p><p>Using where：表示 MySQL 需要在存储引擎层面获取更多的数据行，然后在执行过滤操作来返回查询结果，这个操作可能会非常耗时，因此需要优化查询条件，减少使用 where 子句的情况</p><p>Using index：表示 MySQL 通过索引直接获取了数据行，而无需进行全表扫描，这通常是一种很好的情况，表示查询性能比较好，不需要过多的优化</p><p>而以下字段需要关注，并且尽量优化掉</p><p>Using filesort：表示 MySQL 在对结果进行排序时需要使用到一个外部的文件排序，这个操作非常耗时，需要优化排序方式</p><p>Using temporary：表示 MySQL 在对结果进行查询时需要使用到一个临时表，也会对查询性能造成影响，需要尽量减少使用</p><h4 id="3-3-SQL与索引优化"><a href="#3-3-SQL与索引优化" class="headerlink" title="3.3 SQL与索引优化"></a>3.3 SQL与索引优化</h4><p>获得了执行计划之后，如何对sql进行优化呢？</p><p>以下是一些常见的sql优化策略</p><ul><li><strong>索引优化</strong>：添加、修改、删除索引来提高查询效率<strong>（加索引）</strong></li><li><strong>SQL 重构</strong>：使用更优雅、更高效的 SQL 写法来减少数据库的工作量<strong>（优化sql）</strong></li><li><strong>分库分表</strong>：对于单表数据量过大的情况，可以将数据分散到多个库或多个表中，减轻单一表的压力<strong>（大表拆分）</strong></li><li>数据库服务器优化：例如增加缓存、优化配置参数等，提高整个数据库服务器的性能</li><li>应用程序优化：例如使用缓存来减轻数据库的负担，或者尽可能减少数据库的访问次数等</li><li><strong>小表驱动大表</strong>：如果在联接查询时，一个表非常小，而另一个表非常大，可以考虑使用小表驱动大表的方式，即先查询小表，再将结果与大表联接。这样可以减少查询大表的数据量</li><li>利用分区表：对于需要经常查询的字段，可以将表按照这些字段的值进行分区，从而加快查询速度<strong>（分片）</strong></li><li>数据库优化器调整：例如更改统计信息、更改优化器的启发式算法等，优化 SQL 执行计划</li></ul><h3 id="4-存储引擎"><a href="#4-存储引擎" class="headerlink" title="4.存储引擎"></a>4.存储引擎</h3><h4 id="4-1-选择"><a href="#4-1-选择" class="headerlink" title="4.1 选择"></a>4.1 选择</h4><p>在实际工作中，不同的业务场景需要选择不同的存储引擎来进行工作，下面是一些场景与选择</p><ul><li>数据库引擎的类型：MySQL有多种类型的数据库引擎，包括InnoDB、MyISAM、Memory等。不同的存储引擎有不同的特点和适用场景，根据不同的应用场景和需求选择合适的存储引擎可以提高数据库的性能和可靠性。</li><li>数据库的读写比例：如果数据库的读操作比较多，可以选择InnoDB等支持行级锁定和事务的存储引擎；如果数据库的写操作比较多，可以选择MyISAM等支持表级锁定和非事务的存储引擎。</li><li>数据库的并发连接数：如果并发连接数较高，可以选择支持多线程操作和缓存技术的存储引擎，比如InnoDB等。</li><li>数据库的数据大小：如果数据库的数据量较小，可以选择Memory等内存型存储引擎；如果数据库的数据量较大，可以选择支持分区和压缩技术的存储引擎，比如InnoDB等。</li><li>数据库的可靠性要求：如果数据库的可靠性要求较高，可以选择支持ACID事务和崩溃恢复技术的存储引擎，比如InnoDB等。</li><li>数据库的查询类型：如果数据库的查询类型是常规的数据检索和聚合查询，可以选择InnoDB等支持行级锁定和索引技术的存储引擎；如果数据库的查询类型是大量的全文检索和复杂的空间查询，可以选择支持全文索引和空间索引的存储引擎，比如MyISAM等。</li><li>数据库的数据访问模式：如果数据库的数据访问模式是以主键为主的随机访问，可以选择支持哈希索引和B+树索引的存储引擎，比如Memory等；如果数据库的数据访问模式是基于范围的扫描访问，可以选择支持B+树索引和全文索引的存储引擎，比如InnoDB等</li></ul><h4 id="4-2-分表或者分区"><a href="#4-2-分表或者分区" class="headerlink" title="4.2 分表或者分区"></a>4.2 分表或者分区</h4><p>分区或者分表是一种常见的数据库水平拆分技术，它将一个大表按照一定规则拆分成多个小表或分区，每个小表或分区之间互相独立，可以分散在不同的物理存储设备上，从而提高数据库的扩展性和性能</p><ul><li><strong>应对海量数据</strong>：当单表数据量很大时，查询性能会变慢，甚至会超出单机存储容量限制，此时可以通过分区或分表将数据拆分到多个物理存储设备上，从而提高查询性能和存储容量。</li><li><strong>提高查询性能</strong>：通过将大表拆分成多个小表或分区，查询时只需在有限的小表或分区中进行，可以减少扫描的数据量，从而提高查询性能。</li><li><strong>提高并发性能</strong>：当多个用户同时访问同一个表时，可能会出现锁竞争和阻塞等问题，而分区或分表可以将数据分散到不同的物理存储设备上，从而减少锁竞争和阻塞等问题，提高并发性能。</li><li><strong>易于维护</strong>：当表的结构比较复杂或者数据量很大时，对其进行维护和管理比较困难，而通过分区或分表可以将表结构和数据分散到多个小表或分区中，从而方便维护和管理。</li></ul><h4 id="4-3-字段定义"><a href="#4-3-字段定义" class="headerlink" title="4.3 字段定义"></a>4.3 字段定义</h4><p>原则：使用可以正确存储数据的最小数据类型</p><p>这样可以减小空间消耗</p><h4 id="4-4-整数类型"><a href="#4-4-整数类型" class="headerlink" title="4.4 整数类型"></a>4.4 整数类型</h4><p>在MySql中，INT有6种类型，不同类型的最大储值范围不一样，占用存储空间也不一样，要合理选择</p><h4 id="4-5-字符类型"><a href="#4-5-字符类型" class="headerlink" title="4.5 字符类型"></a>4.5 字符类型</h4><p>变长情况下选择varchar</p><p>固定长度用char</p><h4 id="4-6-非空"><a href="#4-6-非空" class="headerlink" title="4.6 非空"></a>4.6 非空</h4><p>非空的字段尽量定义成NOT NULL，别忘了<strong>提供默认值</strong></p><h4 id="4-7-不要用外键、触发器、视图"><a href="#4-7-不要用外键、触发器、视图" class="headerlink" title="4.7 不要用外键、触发器、视图"></a>4.7 不要用外键、触发器、视图</h4><p>降低可读性</p><h4 id="4-8-大文件存储"><a href="#4-8-大文件存储" class="headerlink" title="4.8 大文件存储"></a>4.8 大文件存储</h4><p>不要把图片，视频等资源放到数据库中存储，放到NAS上，数据库存储URL即可</p><h4 id="4-9-表拆分或者字段冗余"><a href="#4-9-表拆分或者字段冗余" class="headerlink" title="4.9 表拆分或者字段冗余"></a>4.9 表拆分或者字段冗余</h4><p>不常用字段拆分出去</p><p>为了方便，可以对一些字段冗余存储，防止连表查询</p><h3 id="5-优化总结"><a href="#5-优化总结" class="headerlink" title="5.优化总结"></a>5.优化总结</h3><p>在实际工作中，不仅要能够从技术角度对系统进行优化，还要能够从业务角度进行考虑</p><h4 id="5-1-支付方式"><a href="#5-1-支付方式" class="headerlink" title="5.1 支付方式"></a>5.1 支付方式</h4><p>比如双11，为什么提倡使用花呗或者余额宝支付呢？因为调用自己的接口肯定更快</p><h4 id="5-2-降级措施"><a href="#5-2-降级措施" class="headerlink" title="5.2 降级措施"></a>5.2 降级措施</h4><p>为什么双十一那几天，会停掉一些平常不太用的业务？</p><p>为了把资源都交给最核心的业务</p><h4 id="5-3-分散流量"><a href="#5-3-分散流量" class="headerlink" title="5.3 分散流量"></a>5.3 分散流量</h4><p>为什么双11周期变长了？一方面考虑就是把流量进行了分散</p><p>此外，银行的交易记录只允许按照月份查询也是减少流量的方式</p><blockquote><p>此外，还有限流，削峰等诸多措施来保证系统的并发性能</p></blockquote><h3 id="6-优化步骤"><a href="#6-优化步骤" class="headerlink" title="6.优化步骤"></a>6.优化步骤</h3><p>对于具体的慢sql，如何解决呢？下面是一些步骤</p><p>①分析查询基本情况</p><p>涉及到表的结构，字段的索引，表的数据量，业务含义等，分析后也许这个SQL根本不需要这样写呢？</p><p>②找出原因</p><p>根据执行计划，分析SQL慢的具体原因</p><p>③对症下药</p><p>找到原因之后，进行问题解决，比如</p><ul><li>创建索引&#x2F;联合索引</li><li>改写sql<ul><li>小表驱动大表</li><li>使用join代替子查询</li><li>not exist转换为left join is null</li><li>or改为union</li><li>允许重复的话，使用union all代替union</li><li><strong>大偏移的limit，先过滤再排序</strong></li></ul></li><li>结构优化<ul><li>表结构优化：冗余、拆分、not null等</li><li>架构优化：缓存、读写分离、分库分表</li></ul></li><li>业务优化<ul><li>技术手段行不通，可以考虑在业务层面进行优化</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql（一）Mysql基础</title>
      <link href="/2023/01/07/MySql%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/01/07/MySql%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础架构"><a href="#一、基础架构" class="headerlink" title="一、基础架构"></a>一、基础架构</h2><h3 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1.整体架构"></a>1.整体架构</h3><p>先看看mysql的整体架构图，如下</p><img src="https://static-2w2.pages.dev/post/mysql1.png" alt="image-20230407151051373" style="zoom: 25%;" /><p>即主要分为三层，最上面的连接层，中间的服务层与最底层的存储引擎层</p><h3 id="2-连接层"><a href="#2-连接层" class="headerlink" title="2.连接层"></a>2.连接层</h3><p>MySQL的连接层是指位于MySQL架构中的一个组件，负责管理客户端与MySQL服务器之间的连接，它主要负责以下职责：</p><p>1）<strong>管理连接</strong>：连接层管理客户端与MySQL服务器之间的连接，包括建立、维护和断开连接。连接层能够管理连接池，使得MySQL服务器可以更有效地处理连接请求。</p><p>2）<strong>安全性</strong>：连接层可以提供安全性功能，如SSL&#x2F;TLS协议和数据加密，以确保连接的安全性。这是特别重要的，因为MySQL通常用于存储敏感信息，如用户密码和财务数据。</p><p>3）<strong>协议处理</strong>：连接层能够处理多种协议，如TCP&#x2F;IP、Unix套接字等，以适应不同的操作系统和网络环境。</p><h3 id="3-服务层"><a href="#3-服务层" class="headerlink" title="3.服务层"></a>3.服务层</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>mysql的服务层缓存主要包括三个部分：查询缓存、InnoDB缓存和键值缓存</p><p>1）<strong>查询缓存</strong></p><p>最早的缓存机制，只能匹配完全匹配的sql查询语句，语句稍变就无法匹配</p><p>而且存在表更新操作会清除查询缓存，缓存占用内存过大等问题</p><p>因此在MySQL8.0版本中，已经废弃了查询缓存</p><p>2）<strong>InnoDB缓存</strong></p><p>InnoDB缓存是InnoDB存储引擎中使用的缓存，它存储<strong>表和索引</strong>数据，用于加速查询和数据操作</p><p>InnoDB缓存使用LRU算法进行缓存管理，可以根据需要调整缓存大小，以满足不同的应用需求</p><p>3）<strong>键值缓存</strong></p><p>键值缓存是MySQL 8中新加入的功能，它是一个基于Redis协议的缓存服务，支持主从架构和高可用性，用于存储短期缓存数据，如会话信息、配置信息等</p><h4 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h4><blockquote><p>主要工作是将SQL语句解析成MySQL服务器内部的数据结构</p></blockquote><p><strong>1）语法分析</strong></p><p>对SQL语句进行语法检查，确保语句符合MySQL的语法规范</p><p><strong>2）语义分析</strong></p><p>对SQL语句进行语义检查，确保语句中使用的数据库、表、列等存在，以及是否具有正确的权限</p><p><strong>3）转换SQL语句</strong></p><p>将SQL语句转换成MySQL服务器内部的数据结构，方便后续的查询优化、执行计划生成等操作</p><p>简单点想，可以认为是将sql语句生成了一颗解析树，方便后续生成<strong>执行计划</strong></p><h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>负责对SQL查询进行优化，选择最优的执行计划</p><p>怎么理解上面这句话呢？下面看看优化器具体的职责吧</p><ul><li><strong>查询重写</strong>：优化器会根据查询语句的特点，对查询进行重写，以便更好地进行优化。</li><li><strong>执行计划生成</strong>：优化器会生成多个可能的执行计划，并对这些执行计划进行成本估算，选择成本最小的执行计划作为最终的执行计划。</li><li><strong>索引选择</strong>：优化器会根据查询语句的条件，选择最优的索引，以便更快地查询数据。</li><li><strong>连接顺序选择</strong>：优化器会根据表的大小、索引使用情况等因素，选择最优的连接顺序，以便更快地连接多个表。</li><li><strong>其他优化</strong>：优化器还会根据查询语句的特点，进行其他的优化操作，比如子查询展开、常量合并、条件推导等</li></ul><p>由此可见，一条sql，在优化器这里可能会生成多个执行计划，但是经过一系列代价计算步骤之后，优化器选择出一条它认为代价最小的执行计划作为最终的执行计划</p><blockquote><p>这也是很多慢sql出现的原因，即优化器经过优化后选择了自己认为最优的执行计划，但是实际上和开发者所预期的执行步骤不相符，也并不是最优的</p></blockquote><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>负责执行SQL语句，将查询结果返回给客户端</p><p>它还负责连接、认证、锁及事务管理等，不是重点，不再赘述</p><h4 id="4-存储引擎层"><a href="#4-存储引擎层" class="headerlink" title="4.存储引擎层"></a>4.存储引擎层</h4><p>是实际上执行sql语句，并负责将数据存储在磁盘上，提供对数据的读写操作的最终执行部分</p><p>最常见的存储引擎有innoDB、myisam和memory</p><p><strong>1）InnoDB</strong></p><p>InnoDB是MySQL默认的事务型存储引擎，支持<strong>事务</strong>、<strong>行级锁</strong>和<strong>外键</strong>约束等高级特性</p><ul><li><p>支持事务和行级锁：InnoDB是一个支持事务和行级锁的存储引擎，可以提供高并发和数据安全性</p></li><li><p>支持外键约束：InnoDB支持外键约束，可以保证数据的完整性和一致性</p></li><li><p>适合高并发场景：由于支持事务和行级锁，因此InnoDB适合高并发场景，可以提供高效的并发访问</p></li></ul><p><strong>2）MyISAM存储引擎</strong></p><p>MyISAM是MySQL早期版本的默认存储引擎，<strong>不支持事务和行级锁</strong>，但具有快速的读取和写入性能，适合于一些非事务性应用场景</p><ul><li>支持全文索引：MyISAM支持全文索引，适合需要进行全文搜索的应用场景。</li><li>适合读取频繁的应用场景：由于具有快速的读取和写入性能，因此MyISAM适合读取频繁的应用场景，如日志记录等。</li></ul><p><strong>3）Memory存储引擎</strong></p><p>Memory是一种将数据存储在内存中的存储引擎，适用于临时表和缓存等应用场景</p><ul><li>存储在内存中：Memory存储引擎将数据存储在内存中，因此具有快速的读写性能。</li><li>不支持持久化存储：由于数据存储在内存中，因此Memory存储引擎不支持持久化存储。</li><li>适合临时数据和缓存：Memory存储引擎适合存储临时数据和缓存，如存储用户登录状态等</li></ul><blockquote><p>后面讲到索引，事务及锁的时候，都会再度比较这三个存储引擎的不同表现，此处不再进行更详细比较</p></blockquote><h3 id="5-Innodb"><a href="#5-Innodb" class="headerlink" title="5.Innodb"></a>5.Innodb</h3><h4 id="1）思考"><a href="#1）思考" class="headerlink" title="1）思考"></a><strong>1）思考</strong></h4><p>首先思考一个问题，那就是对于InnoDB存储引擎来说，数据是放在磁盘上的，那么每次对数据进行操作，InnoDB都要去磁盘上寻找数据吗？是不是每次操作多少数据，InnoDB就从磁盘加载多少数据使用呢？</p><p>这很明显不可能，因为磁盘的随机寻址速度是很慢的，那面对这种情况，根据计算机常用的策略，肯定要加缓存了</p><p>事实上，InnoDB确实采用了缓冲池的设计理念，配合预读取的思路，在每次对数据操作时，会先去缓冲池中寻找，找不到再去磁盘读取，而且根据局部性原理，会多读取一部分到缓冲池里，这样当相邻数据被操作时，也能够快速在缓冲池中寻找到</p><p>这也就是InnoDb所谓的<strong>Buffer Pool</strong>与<strong>预读取</strong>了</p><h4 id="2）数据页"><a href="#2）数据页" class="headerlink" title="2）数据页"></a><strong>2）数据页</strong></h4><p>在操作系统上，也存在预读取理念与设计，在数据存储的时候，操作系统将4KB数据划分为一页；而在InnoDB里，一页的大小则被划分为16KB，读取的时候就是按页读取的</p><p>在InnoDB的设计中，一次读取会将相邻的8页数据都读取到缓存里，这样是为了避免频繁访问磁盘，从而提升mysql速率；这个8页可以通过参数配置修改，但是不建议改的过大，原因也很简单，这是要占用内存的，缓冲池就那么大，一次读太多页进去可能很快就满了</p><h4 id="3）数据写入"><a href="#3）数据写入" class="headerlink" title="3）数据写入"></a><strong>3）数据写入</strong></h4><p>缓冲池不仅负责读取，在写入时也是先写入到缓冲池，再统一向磁盘进行写入，内存中与磁盘中页数据不一致的被称为脏页，那脏页何时写回磁盘呢？</p><p>还是前面提到的问题，如果每个修改都直接向磁盘写入，会导致磁盘每次都要随机寻址，导致写入效率低下，降低吞吐量，因此不如先存到缓存里，待系统没那么繁忙时再写回磁盘</p><p>这里写入的是缓冲池里一个称为Change Buffer的地方，属于Buffer Pool一部分</p><blockquote><p>到这里也能看出了，Buffer Pool的存在就是为了增加读与写的速度，提高吞吐量</p></blockquote><h4 id="4）Redo-Log"><a href="#4）Redo-Log" class="headerlink" title="4）Redo Log"></a><strong>4）Redo Log</strong></h4><p>上面将修改的数据暂时存到了内存里，等待到达<strong>某一条件</strong>时统一写入磁盘，这样就会存在一个类似redis持久化时的问题—&gt;还没写到磁盘，服务挂了怎么办？</p><p>因此，mysql采用了Redo Log日志来解决这个问题</p><p>Redo log中记录的是修改操作的<strong>物理数据</strong>，包括修改的数据库页、偏移量、修改前的数据、修改后的数据等信息。这些记录可以用来重做在数据文件上的操作，以保证数据库的一致性和完整性</p><p>这里就又有个问题了，日志肯定也要进行持久化，也就是意味着也要和磁盘进行io操作，那和直接把数据修改写入磁盘有什么区别？</p><ul><li><strong>数据量</strong>：redo log记录的只是对物理数据的操作动作，并没有去操作，所以它的数据量是很小的，也就说明它的写入操作是比直接操作数据要快</li><li><strong>顺序IO</strong>：redo log的写入是顺序IO写入，一次寻址即可，而直接操作数据是随机寻址，会慢很多</li></ul><p>此外，只有在redo log写入磁盘成功后才会触发数据到磁盘的修改操作</p><p>而且redo log也有自己的缓冲池，称为<strong>Redo log buffer</strong>，这是为了防止频繁io导致的上下文切换，统一将redo log写入磁盘</p><p>Redo log带来磁盘写入速度提升的同时，也带来了数据丢失与数据不一致的风险</p><p><strong>数据不一致</strong>：redo log中数据持久化成功了，还没来得及将修改持久化到磁盘，系统就挂了；这种情况很好解决，只要redo log写成功了，机器重启后会再读取redo log进行数据的同步</p><p><strong>数据丢失</strong>：这是由于redo log也采用了缓冲池技术带来的隐患</p><p>写入时机是什么时候呢？</p><p>在配置文件中有一个参数innodb_change_buffer_max_size可以控制，默认是1，即每次事务提交都会将log buffer 写入磁盘</p><h4 id="5）Undo-Log"><a href="#5）Undo-Log" class="headerlink" title="5）Undo Log"></a><strong>5）Undo Log</strong></h4><p>Undo log记录了事务发生之前的数据状态，这样如果数据的修改过程出现了异常，可以根据undo log来进行数据的回滚操作</p><p>有了Undo Log之后，这里看一下以下更新语句会执行哪些步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set name = &#x27;zhangsan&#x27; where id = 1;</span><br></pre></td></tr></table></figure><ul><li>事务开始，从内存或磁盘取到包含这条数据的数据页，返回给server层的执行器</li><li>server层的执行器修改数据页的这一行数据为zhangsan</li><li>记录name&#x3D;zhangsan到undo log</li><li>记录name&#x3D;zhangsan到redo log</li><li>调用存储引擎接口，记录数据页到Buffer Pool（修改name&#x3D;zhangsan）</li><li>事务提交</li></ul><h4 id="6）整体架构图"><a href="#6）整体架构图" class="headerlink" title="6）整体架构图"></a><strong>6）整体架构图</strong></h4><p>了解了上面的知识后，看一下innodb整体架构图</p><img src="https://static-2w2.pages.dev/post/innodb.png" alt="Innodb 逻辑存储结构 – EPHUIZI HOME" style="zoom: 67%;" /><p>左边即上面说的缓冲部分，可见有Buffer Pool、Change Buffer和Log Buffer</p><p>既然是缓冲，那么就存在缓冲池满了的情况，那么在InnoDB中，缓冲池满了怎么处理呢？</p><p>在redis之中，内存淘汰策略有六七种，详情见<a href="https://yzj.life/2023/04/04/redis%E8%AF%A6%E8%A7%A3/#2-%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">redis淘汰策略</a></p><p>在InnoDB之中，内存淘汰策略采用的是变种的LRU策略，分为了young和old区域</p><blockquote><p>这里的区域划分和JVM中的不一样，注意区分</p></blockquote><h4 id="7）LRU"><a href="#7）LRU" class="headerlink" title="7）LRU"></a><strong>7）LRU</strong></h4><p>正常的LRU是采用数组+双向链表来实现的</p><p>在InnoDB里面则采用了一个叫LRU List的结果来实现LRU，里面存储的是指向数据页的指针，并不存储真正的数据页</p><p>上面有提到过InnoDB的预读取机制，即一次并不只是读取需要的数据页，而是读取多个相邻的数据页，那么如果读取到的相邻数据页其实没什么用呢？如何淘汰这些使用频率不高的数据页呢？</p><p>LRU list采用了冷热分离的策略来实现淘汰，即把LRU list分成两部分，靠近head的地方叫做new sublist，用来存放数据，也就是热区；靠近tail的地方称为old sublist，也就是冷区；中间使用midpoint分割，如下图</p><img src="https://static-2w2.pages.dev/post/bofferpool.png" alt="img" style="zoom:67%;" /><p>执行流程：</p><ul><li>所有新数据加入到buffer pool的时候，一律先放到冷数据区的head，不区分预读还是普通读</li><li>因此如果有些预读数据后面没用到，会在old sublist区直接被淘汰</li><li>而放到LRU list之后，如果再次访问，就被移到热区的head<ul><li>为了防止热区数据被污染，只有在1s内再次访问的才能移到热区</li></ul></li><li>如果热区数据长时间没被访问，就会先移动到冷区的head部，最后慢慢移动到tail淘汰</li></ul><p>此外还有很多优化操作，这里不再讨论</p><h4 id="8）双写缓冲"><a href="#8）双写缓冲" class="headerlink" title="8）双写缓冲"></a><strong>8）双写缓冲</strong></h4><p>由于InnoDB是16KB一页，而操作系统是4KB一页，那么在写入一半的时候，系统挂了怎么办？由于这时候是写入的页被损坏了，redo log无法恢复这种数据</p><p>双写缓冲就是解决这个情况的，它设置了一个双写缓冲区，在将数据写入磁盘之前会先写入到这里，待这里写入成功了再向磁盘写入，这样即使磁盘写入出错，也可以利用双写缓冲区进行数据恢复</p><h4 id="9）binlog"><a href="#9）binlog" class="headerlink" title="9）binlog"></a><strong>9）binlog</strong></h4><p>在 MySQL 中，Binlog（Binary Log）是一种二进制日志格式，用于记录数据库的所有修改操作。它记录了所有的 DML（数据操作语言）和 DDL（数据定义语言）语句，包括 INSERT、UPDATE、DELETE、CREATE、ALTER 等操作。</p><p>Binlog 有两个主要的作用：</p><ul><li>数据恢复：当出现数据丢失或者其他意外情况时，可以使用 Binlog 进行数据恢复。通过 replay binlog 的方式，可以重放所有的修改操作，以恢复到丢失数据之前的状态。</li><li>数据复制：Binlog 也是 MySQL 实现主从复制的核心组件之一。主库将修改操作写入 Binlog，从库通过读取 Binlog 并重放这些操作，以保持与主库的数据同步。</li></ul><p>在 MySQL 中，可以通过配置 binlog_format 参数来设置 Binlog 的格式，主要有以下两种：</p><ul><li>STATEMENT：记录 SQL 语句本身，对于相同的语句可以减少 Binlog 的大小，但是可能会出现不一致的情况，比如 UUID() 函数、NOW() 函数等在从库和主库执行的结果不一致。</li><li>ROW：记录 SQL 语句执行后的行数据变更，相对于 STATEMENT 格式，Binlog 的大小会更大，但是可以保证从库的数据与主库完全一致。同时，ROW 格式也可以避免因为 SQL 语句执行时出现的隐式转换等问题导致的不一致</li></ul><h2 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><p>索引是一种数据结构，用于提高数据库的查询效率</p><p>索引可以看作是对数据库中的某个列或多个列的值进行排序和分组的数据结构，它可以帮助数据库系统快速地定位到符合查询条件的数据行，从而提高查询的速度</p><p>常见的有B+树索引，哈希索引和全文索引</p><p><strong>B+树索引</strong>：最常见，支持范围查询，排序和分组等操作</p><p><strong>哈希索引</strong>：适合等值查询</p><p><strong>全文索引</strong>：适合文本数据的全文搜索</p><h3 id="2-索引类型"><a href="#2-索引类型" class="headerlink" title="2.索引类型"></a>2.索引类型</h3><p>在创建索引时，会选择索引类型，那么不同类型的索引，都有什么性质呢？</p><p>在InnoDB里面，索引有三种类型</p><ul><li><strong>普通索引</strong>：普通索引没有唯一性限制，可重复</li><li><strong>唯一索引</strong>：不能有重复的值，可为空<ul><li>主键索引是特殊的唯一索引，不允许有空值</li></ul></li><li><strong>全文索引</strong>：用于文本类型数据全文检索</li></ul><p>此外，索引还可以分为聚簇索引和非聚簇索引</p><ul><li><strong>聚簇索引</strong>：将表的数据存储和索引存储在一起<ul><li>每张表唯一</li><li>一般默认主键索引作为唯一索引</li></ul></li><li><strong>非聚簇索引</strong>：包括普通索引，唯一索引，全文索引等，用于加速查找</li></ul><blockquote><p>关于聚簇索引后面还会详细分析，这里不再讨论</p></blockquote><h3 id="3-B-树"><a href="#3-B-树" class="headerlink" title="3.B+树"></a>3.B+树</h3><p>在InnoDB中，采用的是B+树来构造索引，但是它经常被拿来问与B树的区别，那就先来看下B树的结构</p><img src="https://static-2w2.pages.dev/post/B.png" alt="image-20230407210607863" style="zoom: 33%;" /><p>由上图可以看出来，B树的非叶子节点也会进行数据的存储，并且叶子节点是独立的，下面分析下它的优劣</p><p>优点：</p><ul><li>减少IO：相比二叉树，B树每个节点分出的叉更多，因此可以保证更低的IO次数查询到数据，从而提高磁盘读写效率</li><li>性能稳定：高度较低，遍历层数较少，从而性能稳定</li><li>支持动态扩容：可在数据增加时自动调整结构</li></ul><p>缺点：</p><ul><li>维护成本高</li><li>插入和删除相对较慢</li></ul><p>尽管B树的表现已经很优秀了，但是还是存在一些问题的，下面看下B+树的结构</p><img src="https://static-2w2.pages.dev/post/B+.png" alt="B+树" style="zoom:33%;" /><p>由图可知，B+树的叶子节点使用双向链表连接在一起，因此支持范围查询</p><p>B+树的非叶子节点仅存储索引数据，因此每个非叶子节点处都能存储更多的索引数据</p><p>对比B树如下：</p><ul><li>更少的IO：B+树每个非叶子节点仅存储索引数据，因此可以放下更多的子节点，整体上能够使得B+树的高度更低，从而较少IO，提升查询效率</li><li>更适合范围查询：B+树的叶子节点使用双向链表串联在一起，因此更适合范围查询</li><li>更适合高并发插入：B树的所有数据都存储在叶子节点上，因此对于插入操作来说，只需要更新叶子节点上的链表即可，不需要更新非叶子节点，从而减少锁的粒度，提高并发性能</li></ul><h3 id="4-索引落地"><a href="#4-索引落地" class="headerlink" title="4.索引落地"></a>4.索引落地</h3><p>此处仅对比InnoDB和MyISAM中的索引实现</p><h4 id="1）MyISAM"><a href="#1）MyISAM" class="headerlink" title="1）MyISAM"></a><strong>1）MyISAM</strong></h4><p>它其中有两个文件，分别是.MYD和.MYI文件</p><p>.MYD：数据文件，存放数据记录</p><p>.MYI：索引文件，存放索引</p><p>那么如何根据索引找到数据呢？</p><p>MyISAM的B+树，叶子节点存储的是数据文件对应的磁盘记录，然后到数据文件里面获取数据</p><h4 id="2）InnoDB"><a href="#2）InnoDB" class="headerlink" title="2）InnoDB"></a><strong>2）InnoDB</strong></h4><p>与MyISAM不同的是，InnoDB的叶子节点里面直接存储了数据</p><p>所以有个说法，即在InnoDB里面<strong>索引即数据，数据即索引</strong>，就是这个意思</p><p>这里就有个问题出现了，索引那么多，数据存在哪个索引的叶子节点呢？</p><ul><li><p><strong>聚簇索引</strong>：在InnoDB中，聚簇索引就是<strong>索引键值</strong>的<strong>逻辑</strong>顺序跟<strong>表数据行</strong>的<strong>物理</strong>存储数据是一致的</p></li><li><p><strong>非聚簇索引&#x2F;二级索引：</strong>InnoDB之中，不是聚簇索引的索引，都是非聚簇索引</p></li></ul><p>而在InnoDB之中，为了防止每次更新索引后都要更新所有的索引叶子节点，所以只在聚簇索引的叶子节点之中存储了真正的数据值，而其他二级索引的叶子节点都是指向聚簇索引的叶子节点</p><p>哪些索引能称为聚簇索引呢？</p><ul><li><strong>主键索引</strong>：当表中存在主键索引时，主键索引就是聚簇索引</li><li><strong>唯一索引</strong>：如果没有定义主键，那么InnoDB会选择第一个不包含NULL值的唯一索引作为主键索引<ul><li>不包含NULL值也是主键索引和唯一索引的最明显区别</li></ul></li><li><strong>隐藏列</strong>：如果上面两者都没有，那么InnoDB就会创建一个6字节长的ROWID列作为隐藏的聚集索引，它是随着行记录的写入而递增的</li></ul><blockquote><p>回表查询</p><p>相比主键索引成为的聚簇索引，二级索引叶子节点存储的往往是主键的id值，因此使用二级索引查找数据时，需要再根据id值走一遍主键索引，这就是所谓的<strong>回表查询</strong></p></blockquote><h3 id="5-索引使用原则"><a href="#5-索引使用原则" class="headerlink" title="5.索引使用原则"></a>5.索引使用原则</h3><p>什么样的数据列适合建立索引呢？</p><h4 id="1）离散度"><a href="#1）离散度" class="headerlink" title="1）离散度"></a><strong>1）离散度</strong></h4><p>离散度公式：</p><p>count(distinct(column_name))&#x2F;count(*)</p><p>即去重后数据&#x2F;总数据行</p><p>离散度越大越适合创建索引</p><h4 id="2）联合索引最左匹配"><a href="#2）联合索引最左匹配" class="headerlink" title="2）联合索引最左匹配"></a><strong>2）联合索引最左匹配</strong></h4><p>所谓联合索引，即使用多个数据列创建一个索引</p><p>联合索引生效的前提是要按照创建联合索引的顺序，从左向右匹配才能使得索引生效</p><p><strong>最左匹配原则：</strong>最左匹配原则是指，在一个联合索引（复合索引）中，如果查询条件涉及到联合索引的多个列，那么查询时应该优先使用联合索引的最左边的列。</p><p>例如，对于联合索引 (a, b, c)，如果查询条件中包含 a、b、c 三个列，那么应该以 a 作为第一关键字进行匹配，只有在 a 相等的情况下，才会去匹配 b，以此类推。如果查询条件只包含 b、c 两个列，那么联合索引就无法使用。</p><h4 id="3）覆盖索引"><a href="#3）覆盖索引" class="headerlink" title="3）覆盖索引"></a><strong>3）覆盖索引</strong></h4><p>覆盖索引指的是在查询语句中，可以直接通过索引来获取所需的数据，而不必访问数据表。具体来说，如果一个查询涉及的列都在同一个索引中，那么这个索引就是一个覆盖索引。</p><p>使用覆盖索引的好处是可以减少查询所需的 IO 操作和 CPU 计算，从而提高查询性能。因为不需要访问数据表，所以查询所需的时间和资源就会更少。</p><p>在使用覆盖索引时，需要注意以下几点：</p><ul><li>索引要包含所有需要查询的列，而且要尽量少地包含其他列，因为不需要的列会增加索引的大小，导致查询性能降低</li><li>使用 SELECT * 或 SELECT col1, col2 … 语句时，不能使用覆盖索引，因为这些语句需要返回表中所有列的值</li><li>覆盖索引对于频繁更新、插入或删除的表来说，并不是最优的选择，因为每次操作都需要更新索引</li></ul><h4 id="4）索引下推（ICP）"><a href="#4）索引下推（ICP）" class="headerlink" title="4）索引下推（ICP）"></a><strong>4）索引下推（ICP）</strong></h4><p>索引下推（Index Condition Pushdown，简称ICP）是MySQL查询优化器的一项优化技术，用于减少查询所需的IO操作，提高查询性能</p><p>在传统的查询中，MySQL会首先根据索引查找到满足条件的数据行，然后再从磁盘中读取这些数据行的其他列，最后再进行筛选和聚合等操作。这个过程中，需要进行大量的磁盘IO操作，耗费大量的时间和资源</p><p>而索引下推则是将筛选和聚合等操作尽可能地推到索引层进行处理，避免了不必要的磁盘IO操作，从而提高了查询性能。具体来说，MySQL查询优化器会根据查询条件，判断哪些条件可以直接在索引上进行计算，哪些条件需要在数据行中计算。然后，MySQL会将可以在索引上计算的条件转化为对应的索引扫描条件，以减少数据行的读取，提高查询效率</p><p>说人话，<strong>就是把过滤的动作交给存储引擎做完，而不是在服务层过滤</strong></p><p>ICP默认开启</p><p>举个例子，假如有联合索引(last_name,fast_name)</p><p>执行以下查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> last_name <span class="operator">=</span> <span class="string">&#x27;wang&#x27;</span> <span class="keyword">and</span> first_name <span class="keyword">like</span> <span class="string">&#x27;%zi&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这个语句如何执行呢？</p><p>第一种查询方式</p><ul><li>假如根据联合索引查出所有姓wang的二级索引数据三个主键值：6，7，8</li><li>回表，到主键索引上查询所有符合条件的数据</li><li>把这3条数据返回给server层，在server层过滤出以zi结尾的名字</li></ul><p>这种方式存在问题，此时是只用到了wang这个索引，查到3条数据给server层，然后再在server层进行过滤%zi，获得最后两条数据，那假如wang过滤出来1000w条数据，实际上%zi只有一条数据符合呢？这个任务都交给server层是很不合理的</p><p>第二种查询方式</p><ul><li>根据联合索引查出所有姓wang的二级索引数据：3个索引</li><li>然后从二级索引中筛选出所有first_name以zi结尾的索引—1个索引，id为8</li><li>然后回表查询，到主键上找所有符合条件的数据返回</li></ul><p>很明显，第二种查询方式效果更好，而这也就是所谓的索引下推</p><h3 id="6-索引的创建与使用"><a href="#6-索引的创建与使用" class="headerlink" title="6.索引的创建与使用"></a>6.索引的创建与使用</h3><p>索引创建需要遵循一定的原则，而不是可以随意创建的，因为随着数据结构的变更，维护索引也需要成本的</p><p>以下是一些创建索引尽量遵循的原则</p><ul><li>在用于where判断order排序和join的on，group by的字段上创建索引</li><li>索引的个数不要太多</li><li>过长的字段，使用前缀索引</li><li>区分度太低的字段，不要建立索引，例如性别</li><li>频繁更新的值不要建立索引<ul><li>可能导致页分裂</li></ul></li><li>随机无序的值，不建议作为索引，如身份证<ul><li>无序，分裂</li></ul></li><li>组合索引把散列度高的放在前面</li><li>创建复合索引，而不是修改单列索引</li></ul><h3 id="7-索引失效"><a href="#7-索引失效" class="headerlink" title="7.索引失效"></a>7.索引失效</h3><p>那么什么时候建立的索引使用不到呢？</p><p>索引失效多是因为一些操作导致结果不确定，从而无法使用索引</p><ul><li>索引列上使用函数和表达式，逻辑运算符进行计算</li><li>字符串不加引号，出现了隐式转换</li><li>like前面用了%</li><li>负向查询<ul><li>如NOT LIKE</li></ul></li><li>‘!&#x3D; ‘和 ‘&lt;&gt;’还有’NOT IN’这三者在某些情况下可以<ul><li>跟数据库版本，数据量，数据选择度都有关系</li></ul></li></ul><p>其实，是否使用索引，最终都是由优化器决定</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶之并发编程（七）ThreadPoolExecutor</title>
      <link href="/2022/12/02/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2022/12/02/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><h4 id="1-思考"><a href="#1-思考" class="headerlink" title="1.思考"></a>1.思考</h4><p>先来考虑下，假如没有线程池，每次使用多线程都要创建并销毁，可能存在什么问题？</p><ol><li><strong>资源消耗：</strong>线程的创建和销毁是一项昂贵的操作，会消耗大量的 CPU 和内存资源。频繁地创建和销毁线程可能会导致资源的浪费和系统性能的下降。</li><li><strong>稳定性：</strong>在创建和销毁线程的过程中，线程状态的切换可能会导致程序不稳定。例如，在线程销毁之前，可能存在一段时间的竞态条件，导致程序出现不一致的行为。</li><li><strong>并发性能：</strong>在高并发场景下，频繁地创建和销毁线程会导致线程数的不稳定，进而影响程序的并发性能。过多的线程数会导致 CPU 和内存的浪费，而过少的线程数则会导致任务执行的延迟和并发性能的下降。</li></ol><p>因此，使用线程池可以避免频繁地创建和销毁线程，从而节省资源、提高程序的稳定性和并发性能。</p><h4 id="2-设计"><a href="#2-设计" class="headerlink" title="2.设计"></a>2.设计</h4><p>既然想要利用池化技术解决线程频繁创建和销毁的问题，那么该如何设计呢？</p><p><strong>如何实现线程的复用？</strong></p><p>能实现线程复用的唯一方式，就是让线程不结束</p><p><strong>那么如何让线程能够执行新的任务呢？</strong></p><p>共享内存—&gt;List.add()</p><p><strong>那么线程无任务时，就一直空转吗？</strong></p><p>有任务来时，执行任务；无任务时，阻塞</p><p><strong>结论：</strong></p><p>使用阻塞队列的方式，来实现线程池技术，从而完成线程的复用</p><h4 id="3-执行流程"><a href="#3-执行流程" class="headerlink" title="3.执行流程"></a>3.执行流程</h4><blockquote><p>具体设计流程参考下图</p></blockquote><p><img src="https://static-2w2.pages.dev/post/threadPoolDesign.png" alt="image-20230406143137653"></p><h3 id="二、源码"><a href="#二、源码" class="headerlink" title="二、源码"></a>二、源码</h3><blockquote><p>线程池中的核心线程是延迟初始化的</p></blockquote><ul><li>先初始化核心线程。</li><li>调用阻塞队列的方法，把task存进去。(offer() -&gt; true&#x2F;false)<ul><li>如果true ，说明当前的请求量不大， 核心线程就可以搞定。 </li><li>false，增加工作线程(非核心线程)<ul><li>如果添加失败，说明当前的工作线程数量达到了最大的线程数，直接调用拒绝策略。</li></ul></li></ul></li></ul><h4 id="1-构造器"><a href="#1-构造器" class="headerlink" title="1.构造器"></a>1.构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, // 核心线程数</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,// 最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,// 超时销毁时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit,// 时间单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,// 阻塞队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,// 线程工厂</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;<span class="comment">// 拒绝策略</span></span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池创建时，这七大参数是必不可少的，但是像线程工厂和拒绝策略可不填，有默认值可用，下面详解这七个参数</p><ul><li><p><strong>corePoolSize：</strong>核心线程数，线程池中常态化保持的线程数量</p></li><li><p><strong>maximumPoolSize：</strong>最大线程数，当核心线程与阻塞队列都满了，再有新的任务进来，而还没达到最大线程数，则会创建新的线程处理任务</p></li><li><p><strong>keepAliveTime：</strong>超时销毁时间，超过核心线程数量的线程，休息这个时间后还没有任务处理，就会自动关闭；</p></li><li><p><strong>unit：</strong>上一个参数的时间单位</p></li><li><p><strong>workQueue：</strong>阻塞队列，用于保存任务，详情可参考<a href="https://yzj.life/2023/03/28/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/#%E4%B8%89%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97">阻塞队列</a></p></li><li><p><strong>threadFactory：</strong>线程工程，用于生产线程，可采用默认值</p></li><li><p><strong>handler：</strong>拒绝策略</p><ul><li>AbortPolicy（默认策略）：当任务添加到线程池中被拒绝时，将抛出RejectedExecutionException异常。</li><li>CallerRunsPolicy：当任务添加到线程池中被拒绝时，将该任务添加到当前线程执行。</li><li>DiscardPolicy：当任务添加到线程池中被拒绝时，将直接丢弃该任务，不做任何处理。</li><li>DiscardOldestPolicy：当任务添加到线程池中被拒绝时，将丢弃最早加入线程池的任务，并尝试重新提交当前任务。</li></ul><p>除了上述四种策略之外，也可以通过实现RejectedExecutionHandler接口，自定义拒绝策略。</p></li></ul><h4 id="2-execute"><a href="#2-execute" class="headerlink" title="2.execute"></a>2.execute</h4><ul><li>如果当前运行的线程数少于corePoolSize，尝试使用给定的命令作为新线程的第一个任务来启动一个新线程。addWorker方法会原子地检查runState和workerCount，因此可以防止出现错误警报，以避免在不需要添加线程时添加线程并返回false</li><li>如果可以成功将任务加入到队列中，那么我们仍然需要双重检查是否应该添加一个线程（因为现有线程在上次检查后已经死亡），或者在进入此方法后池已关闭。因此，我们重新检查状态，如果需要，在停止时回滚排队操作，或者在没有线程时启动一个新线程</li><li>如果无法将任务加入队列，则尝试添加一个新线程。如果失败，我们知道线程池已关闭或已饱和，因此拒绝该任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">  <span class="comment">// 判断当前工作线程数是否小于核心线程数(延迟初始化)</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">      <span class="comment">// 添加工作线程的同时，执行command</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// workQueue.offer 添加到阻塞队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 如果阻塞队列满了，则添加工作线程(扩容的线程)</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">      <span class="comment">// 启用拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-addWorker"><a href="#3-addWorker" class="headerlink" title="3.addWorker"></a>3.addWorker</h4><p>尝试向线程池中添加一个新的工作线程</p><ul><li>如果线程池中当前的工作线程数小于corePoolSize，则会尝试创建一个新的工作线程，并将给定的任务作为该线程的第一个任务。这个操作是原子的，即只有一个线程能够进行，避免了竞争条件。</li><li>如果任务不能立即分配给线程执行，会将任务放入工作队列中。</li><li>如果工作队列已满，将尝试创建新的工作线程来处理任务。</li><li>如果无法创建新的工作线程，则会根据设置的拒绝策略来处理该任务。默认的拒绝策略是抛出RejectedExecutionException异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    retry:</span><br><span class="line">  <span class="comment">// 通过原子操作来增加线程数量 一般cas操作都是配合死循环使用</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="comment">// 增加线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 初始化工作线程</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 构建一个工作线程，此时线程还未启动</span></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                  <span class="comment">// 线程构建成功，加入容器中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                  <span class="comment">// 添加线程成功</span></span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">              <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里能看到，新创建的线程进入了workers，这个容器是何方神圣呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br></pre></td></tr></table></figure><p>定义如上，用到了一个内部类Worker，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    Runnable firstTask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line">  ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，这是一个对工作线程进行包装的类，那么自然，workers中存储的也就都是创建好的线程了</p><h4 id="4-run"><a href="#4-run" class="headerlink" title="4.run"></a>4.run</h4><p>在上面的Work类中，存在run方法，即线程要执行的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    runWorker(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上执行任务的方法，具体实现步骤如下</p><ul><li>获取当前 <code>Worker</code> 线程对象所持有的 <code>Thread</code> 对象，这里的 <code>Thread</code> 对象在 <code>Worker</code> 对象的构造函数中被创建。</li><li>循环执行以下步骤：<ul><li>如果 <code>Worker</code> 对象的 <code>firstTask</code> 不为 null，说明这个线程还没有开始执行任务，那么就执行 <code>firstTask</code>，并将 <code>firstTask</code> 置为 null。</li><li>如果 <code>Worker</code> 对象的 <code>firstTask</code> 为 null，那么就从任务队列中取出一个任务进行执行。这里的任务队列就是 <code>ThreadPoolExecutor</code> 的 <code>BlockingQueue</code> 对象，它用于存储还未被执行的任务。如果队列为空，则调用 <code>getTask()</code> 方法阻塞等待队列中有新的任务。</li><li>如果 <code>getTask()</code> 方法返回 null，说明任务队列已经被关闭，那么就直接跳出循环。</li><li>执行任务。执行任务的过程中，可能会抛出异常，这时需要调用 <code>afterExecute()</code> 方法进行一些清理工作，比如将异常打印出来或者记录日志。</li></ul></li><li>如果循环结束，说明线程要么被要求退出，要么发生了异常，需要将 <code>Worker</code> 线程对象从线程池中移除，同时也要执行一些清理工作，比如中断当前线程、调用 <code>processWorkerExit()</code> 方法等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// while循环保证当前线程不结束. 直到task为null</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 自己实现的互斥锁，利用了AQS框架，为什么这里要使用锁呢？</span></span><br><span class="line">          <span class="comment">// 表示当前线程正在运行一个任务，如果其他地方要shutdown()</span></span><br><span class="line">          <span class="comment">// 你必须要等我执行完成；即保证正常关闭</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();<span class="comment">// 是否应该触发中断</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 空的实现</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-getTask"><a href="#5-getTask" class="headerlink" title="5.getTask"></a>5.getTask</h4><p>用于获取任务队列中的下一个任务</p><p>两个参数：firstTask和core，分别表示线程第一次获取任务时的任务以及线程是否为核心线程</p><p>核心逻辑如下</p><ul><li>如果线程池的状态为STOP，即线程池已关闭并且没有任务等待执行，那么返回null。这个判断是为了确保线程在关闭时能够正确退出。</li><li>如果线程为非核心线程或者线程池中正在运行的线程数大于核心线程数，那么调用workQueue的poll方法从任务队列中获取任务。如果获取到的任务不为null，则直接返回该任务。</li><li>如果线程为核心线程且线程池中正在运行的线程数小于等于核心线程数，则调用workQueue的take方法从任务队列中获取任务。take方法会在任务队列为空时自动阻塞线程，直到队列中有任务或线程池被关闭。如果获取到的任务不为null，则直接返回该任务。</li><li>如果获取到的任务为null，则返回null。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"><span class="comment">// 配合cas自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"><span class="comment">// 如果线程池处在结束状态，直接返回null. 需要清理掉所有的工作线程</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 是否允许超时</span></span><br><span class="line">      <span class="comment">// 如果当前工作线程数量大于核心线程数</span></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">          <span class="comment">// 减少工作线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">// 表示要销毁当前工作线程</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 获取任务过程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">          <span class="comment">// 如果阻塞队列没有任务，当前工作线程会阻塞在这里</span></span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;<span class="comment">// 中断异常</span></span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、线程池参数设置"><a href="#三、线程池参数设置" class="headerlink" title="三、线程池参数设置"></a>三、线程池参数设置</h3><ul><li>IO密集型 CPU 2core+1 </li><li>CPU利用率不高</li><li>CPU密集型 CPU +1 </li><li>CPU利用率很高，会增加上下文切换.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶之并发编程（六）ThreadLocal</title>
      <link href="/2022/11/20/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2022/11/20/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p><code>ThreadLocal</code> 是一个 Java 提供的线程局部变量类。它的主要作用是为每个线程提供独立的变量副本，使得每个线程都可以独立地修改自己所拥有的变量副本，而不会影响其他线程的副本</p><h3 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h3><h4 id="1-ThreadLocalMap"><a href="#1-ThreadLocalMap" class="headerlink" title="1.ThreadLocalMap"></a>1.ThreadLocalMap</h4><p>ThreadLocalMap是实现ThreadLocal的根本所在，因此分析ThreadLocalMap的代码即可了解ThreadLocal的实现原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部类Entry，使用弱引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Entry类型的数组，用于存储set进来的value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * table大小标记</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容阈值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容阈值是长度的2/3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setThreshold</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">        threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器 传入第一个key，和对应的值，即第一次set值时才会进行初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器 继承父线程的ThreadlocalMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> &#123;</span><br><span class="line">        Entry[] parentTable = parentMap.table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> parentTable.length;</span><br><span class="line">        setThreshold(len);</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> parentTable[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> key.childValue(e.value);</span><br><span class="line">                    <span class="type">Entry</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">while</span> (table[h] != <span class="literal">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    table[h] = c;</span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-set方法"><a href="#2-set方法" class="headerlink" title="2.set方法"></a>2.set方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法十分简单，直接传进来要存储的value，然后获得ThreadLocalMap放进去即可</p><p>但是要注意，这里调用了两个其他方法，分析下这两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了线程的threadLocals参数，这个参数如何定义的呢？在Thread类里面，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>即<strong>每个线程都有一个ThreadLocalMap类型的threadLocals变量，用于存储threadLocal值</strong></p><p>所以set操作，最后其实都是放在了线程内，即拿到当前操作的线程，获取线程内部的threadlocals对象，将threadlocal作为key，存储进threadlocals里面去</p><p>假如线程的threadlocals对象尚未初始化，则会调用下述方法，来进行ThreadLocalMap对象的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终是使用ThreadLocalMap的构造器创建了对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造器 传入第一个key，和对应的值，即第一次set值时才会进行初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">  <span class="comment">// 使用table存储value数值</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">  <span class="comment">// 根据哈希取模确定位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 创建Entry对象，传入key和value</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 设置阈值</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就是真正的set方法实现的地方，上面调用了map .set(this,value)，最终调用的是ThreadLocalmap内的set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 发生哈希冲突，依次往后遍历，找到第一个不冲突的位置</span></span><br><span class="line">  <span class="comment">// nextIndex保证找到数组最后之后从头开始查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"><span class="comment">// 如果key相等，则覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 如果key过期或者被清理，不存在的话</span></span><br><span class="line">      <span class="comment">// 调用replaceStaleEntry，清理失效的key和对应的value</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">  <span class="comment">//清理</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里介绍下replaceStaleEntry方法，它内部调用了cleanSomeSlots方法，而在cleanSomeSlots内部又调用了expungeStaleEntry方法，那么这三个方法有什么用呢？</p><p>首先说回threadLocalMap中数据的存储方法，是采用Entry数组进行的存储，面对冲突，采用的开放地址法解决冲突，这种方法实现简单，就是不断往后遍历，直到找到空位置，插入即可；但是也存在很大的问题，那就是当一些数据失效时，本来连续的数据就会存在空缺，这时候再进行查询，查到空位就会停止了，因此需要提供一个策略，保证失效数据被清除后能够重整数据位置，而上面的这三个方法，就是实现这个清理过程的</p><p>首先看expungeStaleEntry方法，传入的staleSlot对应位置的key为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key为null，所以value可以直接清除</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash 重新计算位置，调整结构</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// 左边的都是遍历过的，无空缺，所以往后走调整就行</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">      <span class="comment">// key已被清除，对应位置清除</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 比较哈希值是否相同，即判断这个key是否采用过开放地址法解决冲突</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">          <span class="comment">// 使用过开放地址法，因此</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">              <span class="comment">// 原位置清空</span></span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 还是按照开放地址法解决冲突方式，从前往后，找到空位置插入</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 现在的i是从传入位置，第一次往后走到的key为null位置</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面的源码分析，可以知道expungeStaleEntry方法主要是什么作用了，它主要是重新调整key为null后面那些key的位置，保证能够不出现空缺</p><p>由于在table表中，staleSlot位置的key没了，那么之前通过开放地址法经过这个key，往后排的那些key都不能再被查到了，因此需要调整它后面的数据位置，走到第一个key为null的位置即可，具体参考下图</p><p><img src="https://static-2w2.pages.dev/post/threadlocal.png" alt="image-20230406195704176"></p><p>下面再看cleanSomeSlots方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入key为null的位置i，table长度n</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 复制一个table，可以认为局部数组访问速度加快</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 往后走一步</span></span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">      <span class="comment">// 取出e</span></span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">      <span class="comment">// e的key失效</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 调用expungeStaleEntry，调整i之后的数据位置</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>); <span class="comment">// 要遍历一遍调整位置</span></span><br><span class="line">  <span class="comment">// 是否调整过数组，移除过无效value</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以它本质上就是遍历了</p><p>一遍数组，清理并调整了数组中的对象，将无效value清除，重新调整了其他有效数据的位置</p><p>再看replaceStaleEntry方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入key，value和位置i，这里的key==null，要将value存储进来</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;<span class="comment">//使用局部数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">  <span class="comment">// 往前遍历，找到第一个key失效的位置slotToExpunge</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从staleSlot位置往后遍历，如果找到key相等的地方，就覆盖处理</span></span><br><span class="line">  <span class="comment">// 没找到key相等的地方，就找到第一个为null的地方</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">      <span class="comment">// 覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 覆盖后，清除并调整其他元素</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在i位置指向的是null</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入新值</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次清除无效key，调整其他数据</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以replaceStaleEntry方法就是一个把value放入table，并且清理无效key调整元素位置的方法，但是这个方法只在插入时，走到了一个key为null但是有value的地方时才会调用</p><h4 id="3-get方法"><a href="#3-get方法" class="headerlink" title="3.get方法"></a>3.get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 查找</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 还未初始化，进行初始化</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何查询的呢？如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">  <span class="comment">// 直接找到，返回</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 未直接找到，向后找</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向后查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">          <span class="comment">// 找的时候发现失效key，进行清理</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><h4 id="3-1-应用"><a href="#3-1-应用" class="headerlink" title="3.1 应用"></a>3.1 应用</h4><p>ThreadLocal有哪些应用呢？</p><p>它的应用环境主要是线程私有一些数据的情况，如建立连接后保持连接信息—前后端，后端与数据库的连接都算，具体如下示例</p><ul><li>日期格式化工具：在多线程环境下，SimpleDateFormat 是非线程安全的，可以使用 ThreadLocal 存储每个线程的 SimpleDateFormat 实例</li><li>数据库连接管理：通过 ThreadLocal 可以为每个线程分配独立的数据库连接，确保线程之间的数据库连接独立性</li><li>Spring 中的事务管理：Spring 使用 ThreadLocal 来管理事务，在同一个线程中的方法调用之间共享事务状态</li><li>同一个线程中的业务处理需要共享数据：比如用户登录信息等</li></ul><h4 id="3-2-内存泄漏"><a href="#3-2-内存泄漏" class="headerlink" title="3.2 内存泄漏"></a>3.2 内存泄漏</h4><p>首先要明白，ThreadLocal为什么把key设置成弱引用类型？</p><p>因为实际上，key-value是存储在ThreadLocalMap中的，而每个线程都有一个ThreadLocalMap类型的参数threadLocals，如果key是强引用，那么基本上除非手动指定remove，不然这个key对应的位置永远会被占用，这就造成了所说的内存泄漏问题</p><p>那么key设置成弱引用，就一定能避免内存泄漏吗？</p><p>也不一定，因为key虽然会在gc时被回收掉，但是value还存在呀，如果只是gc了，那value没被清除掉，依然会造成内存泄漏</p><p>为什么value不会被gc回收掉？</p><p>因为它是强引用类型的，实际上是存储在Entry数组上的，数组有指向它的强引用</p><p>那么如何回收，保证不会内存泄漏呢？</p><p>为了防止内存泄漏，ThreadLocal在get和set方法都能够清除无效的key对应的无效value，但是如果一直没调用这些方法，也会导致value存储在table中无法清除，造成内存泄漏</p><p>因此使用threadLocal之后，要保留调用一下remove方法的习惯</p><h4 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h4><p>由上面的分析可知，threadLocal主要依赖ThreadLocalMap来实现各种功能，数据也是包装成Entry类型存储在数组之中</p><p>而ThreadLocalMap采用的是开放地址法解决哈希冲突，若是某位置key失效了，清除后可能会对其他Entry对象的查找造成问题，所以ThreadLocalMap提供了cleanSomeSlots和expungeStaleEntry方法配合使用，可以清除key失效的无效槽，并且能够调整剩余的Entry到正确的位置</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶之并发编程（五）ConcurrentHashMap</title>
      <link href="/2022/11/13/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2022/11/13/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><h4 id="1-随便说说"><a href="#1-随便说说" class="headerlink" title="1.随便说说"></a>1.随便说说</h4><p><code>ConcurrentHashMap</code>在jdk1.8之前，即1.7的时候，采用的是分段锁+数组+链表的技术</p><p>但是这样会存在一些问题，如下：</p><p>1.分段锁存在性能瓶颈，不能支持很高的并发量</p><p>2.链表解决冲突，在极端情况下会导致链表过长查询性能下降</p><p>3.死链问题，头插法可能会导致扩容时出现死链</p><p>因此，本文主要介绍jdk1.8实现的<code>ConcurrentHashMap</code>源码</p><blockquote><p>此外，像哈希表中的get，set，size等方法过于简单，此处不会进行分析</p><p>仅对put，扩容，计算元素数量做详细介绍</p></blockquote><h4 id="2-简单比较"><a href="#2-简单比较" class="headerlink" title="2.简单比较"></a>2.简单比较</h4><p>相比1.7版本的ConcurrentHashMap，1.8版本的ConcurrentHashMap进行了一次很好的优化，主要在以下方面：</p><p><strong>1.分段锁 -&gt; CAS</strong></p><p>不再采用分段锁技术，插入时仅锁某一个槽，并且使用CAS进行元素操作，极大的提升了并发性能</p><p><strong>2.数组+链表 -&gt; 数组+链表+红黑树</strong></p><p>引入红黑树解决哈希冲突，提升了插入和查询效率</p><p><strong>3.扩容机制改进</strong></p><p>由头插法改为尾插法，防止死链问题</p><h3 id="二、参数解析"><a href="#二、参数解析" class="headerlink" title="二、参数解析"></a>二、参数解析</h3><h4 id="1-容量相关参数"><a href="#1-容量相关参数" class="headerlink" title="1.容量相关参数"></a>1.容量相关参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容器最大容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组最大长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认并发级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负载因子，用于计算扩容阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表树化阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树退化为链表阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表树化时，数组最小长度阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure><h4 id="2-扩容相关参数"><a href="#2-扩容相关参数" class="headerlink" title="2.扩容相关参数"></a>2.扩容相关参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示resizeStamp中记录扩容状态和版本号信息所占用的位数</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_BITS</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 能帮助扩容的最大线程数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RESIZERS</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配合resizeStamp记录扩容状态和版本号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_SHIFT</span> <span class="operator">=</span> <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br></pre></td></tr></table></figure><h4 id="3-状态相关参数"><a href="#3-状态相关参数" class="headerlink" title="3.状态相关参数"></a>3.状态相关参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVED</span>     <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 表示该槽位元素已迁移</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEBIN</span>   <span class="operator">=</span> -<span class="number">2</span>; <span class="comment">// 表示该槽位元素已树化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESERVED</span>  <span class="operator">=</span> -<span class="number">3</span>; <span class="comment">// 槽位已占有，但未分配</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_BITS</span> <span class="operator">=</span> <span class="number">0x7fffffff</span>; <span class="comment">// 用于计算元素哈希槽位置</span></span><br></pre></td></tr></table></figure><h4 id="4-Node结构"><a href="#4-Node结构" class="headerlink" title="4.Node结构"></a>4.Node结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存在槽与链表中的节点数据结构</p><h4 id="5-工具方法"><a href="#5-工具方法" class="headerlink" title="5.工具方法"></a>5.工具方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换哈希码，使其尽量均匀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">spread</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">  <span class="comment">// 哈希码右移16位与自己异或散列后，再和HASH_BITS与运算再次散列</span></span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要作用是根据给定的初始容量，计算出一个大于等于该初始容量的2的整数次幂值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个元素大小关系</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span> <span class="comment">// for cast to Comparable</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="literal">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">            ((Comparable)k).compareTo(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-元素操作方法"><a href="#6-元素操作方法" class="headerlink" title="6.元素操作方法"></a>6.元素操作方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数组对应位置头元素</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// casTabAt方法的作用是将数组tab中下标为i的节点的值从c更新为v</span></span><br><span class="line"><span class="comment">// 但只有在节点值为c时才会更新成功</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setTabAt方法的作用是将数组tab中下标为i的节点的值直接设置为v</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-全局变量"><a href="#7-全局变量" class="headerlink" title="7.全局变量"></a>7.全局变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组，即数组+链表/红黑树中的数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时的新数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用cas修改指，统计元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态机，用于标识当前哈希表状态---十分重要</span></span><br><span class="line"><span class="comment">// sizeCtl == -N（N &gt; 1）表示正在扩容，已经有N个线程正在参与扩容操作</span></span><br><span class="line"><span class="comment">// sizeCtl == -1 表示正在初始化</span></span><br><span class="line"><span class="comment">// sizeCtl == 0  表示当前哈希表没有被初始化，初始化后为 初始容量 * 0.75</span></span><br><span class="line"><span class="comment">// sizeCtl &gt; 0 由上面可知，表示扩容阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定了当前线程在进行扩容操作时，需要转移元素的下标位置</span></span><br><span class="line"><span class="comment">// 由spread方法和当前线程的线程ID计算得出的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于标识当前是否有线程正在对ConcurrentHashMap进行扩容操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用该数组记录容器元素数，减少冲突</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><h3 id="三、put操作"><a href="#三、put操作" class="headerlink" title="三、put操作"></a>三、put操作</h3><h4 id="1-源码"><a href="#1-源码" class="headerlink" title="1.源码"></a>1.源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口方法，实际上是调用putVal实现的put操作</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">  <span class="comment">// ConcurrentHashMap不支持key和value为null的情况，防止出现二义性</span></span><br><span class="line">  <span class="comment">// 比如某个key本来不存在，get后是null</span></span><br><span class="line">  <span class="comment">// 但是使用containsKey判断时，另一个线程插入了key为null，就出现二义性</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  <span class="comment">// 获取散列后的hash值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">  <span class="comment">// 统计槽内元素数量，判断要不要树化</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 死循环，不搞进去不结束</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">      <span class="comment">// 发现还未初始化，进行数组初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">      <span class="comment">// 已初始化，对应槽是空的，直接放进去</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 已初始化，对应槽非空，但是正在进行扩容，于是线程也加入扩容大军</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">      <span class="comment">// 已初始化，对应槽非空，也没在扩容，那就进去扩容</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">          <span class="comment">// 锁住这个槽，插入后再释放</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">              <span class="comment">// 确认下f没被其他线程干掉，有点儿双重校验锁的味道～</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                  <span class="comment">// 节点哈希值为负数就不能用链表了，非负才走链表逻辑</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                          <span class="comment">// key相等，覆盖</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                          <span class="comment">// 走到尾部了，尾插放进去</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// 走树的插入逻辑</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 有插入成功元素</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 达到树化的链表阈值</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 统计哈希表元素数量，并且判断是否扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-小结"><a href="#2-小结" class="headerlink" title="2.小结"></a>2.小结</h4><p>通过上述流程，可以总结出来put流程大体如下</p><p>1.判空</p><p>2.启用一个死循环，直到binCount !&#x3D; 0为止，即插入成功</p><p>3.是否初始化，未初始化先调用初始化方法</p><p>4.判断槽是否空，空的直接放进去</p><p>5.槽不空，判断是否在扩容中，扩容中就加入扩容队伍</p><p>6.槽不空，未在扩容，那就锁住这个槽执行插入</p><p>7.判断槽中是链表还是树，执行向下走的流程</p><p>8.key是否存在？存在就覆盖</p><p>9.key不存在，那就插入，链表是尾插</p><p>10.如果key存在采用的覆盖，就返回旧值</p><p>11.元素统计加上</p><h3 id="四、初始化"><a href="#四、初始化" class="headerlink" title="四、初始化"></a>四、初始化</h3><h4 id="1-源码-1"><a href="#1-源码-1" class="headerlink" title="1.源码"></a>1.源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">  <span class="comment">// 未被初始化</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 已有其他线程扩容中，先尝试放弃cpu给其他线程用</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">      <span class="comment">// 尝试将SIZECTL的值从sc修改为-1，一般是0到-1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 再判断一次，tab还没被其他线程初始化，就进行初始化</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="comment">// 初始化后，sizeCtl设置为扩容阈值</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-小结-1"><a href="#2-小结-1" class="headerlink" title="2.小结"></a>2.小结</h4><p>1.启动一个循环进行初始化</p><p>2.使用sizeCtl控制初始化状态</p><p>3.如果sizeCtl为负值，就是在初始化&#x2F;扩容中，当前线程临时歇着就行</p><p>4.sizeCtl大于等于0，尝试将sizeCtl设置为-1，表示初始化中</p><p>5.再判断一次tab是否为空，防止其他线程已经初始化</p><p>6.初始化，将sizeCtl设置为扩容阈值</p><h3 id="三、扩容流程"><a href="#三、扩容流程" class="headerlink" title="三、扩容流程"></a>三、扩容流程</h3><h4 id="1-源码-2"><a href="#1-源码-2" class="headerlink" title="1.源码"></a>1.源码</h4><p>helpTransfer线程入场，加入扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="type">int</span> sc;</span><br><span class="line">  <span class="comment">// tab != null表示旧数组不为null，还在扩容中</span></span><br><span class="line">    <span class="comment">// ForwardingNode类型表示当前节点正在进行扩容操作</span></span><br><span class="line">  <span class="comment">// nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable取出新数组，且不为空</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 扩容戳，高16位表示扩容次数，低16位表示线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line">      <span class="comment">// 新旧数组都对应的上，sizeCtl小于0表示在扩容中</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 判断是否还需要帮助扩容</span></span><br><span class="line">          <span class="comment">// (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs扩容戳变化</span></span><br><span class="line">          <span class="comment">// 表示当前有其他线程正在进行扩容操作，当前线程无法参与扩容操作</span></span><br><span class="line">          <span class="comment">// 表示扩容操作已经有足够的线程参与，当前线程无需参与扩容操作</span></span><br><span class="line">          <span class="comment">// 表示当前线程已经没有数据需要移动</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 使用cas设置sc的值，表示参入扩容线程数+1，注意sc在上一个if中被修改了</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resizeStamp获得扩容戳</p><p><code>n</code> 是当前哈希表的容量，<code>RESIZE_STAMP_BITS</code> 是一个常量，表示扩容戳的长度。该方法首先通过 <code>Integer.numberOfLeadingZeros(n)</code> 方法计算出哈希表容量的前导 0 的个数，然后将该值左移 <code>RESIZE_STAMP_BITS - 1</code> 位，最后通过按位或操作将扩容戳的高位设置为 1。这样就可以得到一个长度为 <code>RESIZE_STAMP_BITS</code> 的扩容戳，其中高位为 1，低位为当前哈希表的容量的前导 0 的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">resizeStamp</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容的灵魂—transfer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">  <span class="comment">// 计算每个线程处理的数据的区间大小，最小是16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">  <span class="comment">// 新数组为空，还未创建，进行初始化，在原来的基础上扩大两倍</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">  <span class="comment">// 用来表示已经迁移完的状态，也就是说</span></span><br><span class="line">  <span class="comment">// 如果某个old数组的节点完成了迁移，则需要更改成fwd</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">      <span class="comment">// 计算负责迁移的区间范围，从后往前数</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 假设数组长度是32</span></span><br><span class="line"><span class="comment">// 第一次 [16(nextBound),31(i)] </span></span><br><span class="line">          <span class="comment">// 第二次 [0,15]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 扩容是否结束</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="type">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="literal">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 得到数组下标为31的位置的值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>) <span class="comment">// 说明当前数组位置为空</span></span><br><span class="line">          <span class="comment">// 直接改成fwd -&gt; 表示迁移完成</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="literal">null</span>, fwd); </span><br><span class="line">      <span class="comment">// 判断是否已经被处理过了，如果是，则进入下一次区间遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 加锁-&gt;针对当前要去迁移的节点</span></span><br><span class="line">          <span class="comment">// 保证迁移过程中，其他线程调用put()方法时，必须要等待</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                  <span class="comment">// 链表与树分开处理</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                      <span class="comment">// 高低位分开迁移</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        <span class="comment">// 高低位分开迁移</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-小结-2"><a href="#2-小结-2" class="headerlink" title="2.小结"></a>2.小结</h4><h5 id="2-1首先解决一些疑问"><a href="#2-1首先解决一些疑问" class="headerlink" title="2.1首先解决一些疑问"></a>2.1首先解决一些疑问</h5><p><strong>1）线程可以辅助扩容，有数量上限吗？扔进helpTransfer就会进行辅助扩容吗？</strong></p><p>答：在helpTransfer中，会判断当前线程是否能够加入扩容操作</p><p>这里会有一系列判断</p><p>判断当前是否处于扩容状态中</p><p>判断当前是否还需要辅助扩容</p><p>判断当前参与扩容的线程数量是否达到了上限等</p><p>全部校验通过，才会调用transfer方法进行实际上的扩容操作</p><p><strong>2）多个线程同时扩容，如何保证扩容过程中，数据迁移不重复，不迁移漏的？</strong></p><p>答：</p><p>在transfer方法中，线程进入该方法后会通过计算得出一个transferIndex值，这个值指向自己负责扩容的数组数据结束位置，从后往前进行迁移；</p><p>而这个线程也只负责一段连续区域内的数据迁移任务而已，它只会执行自己负责区域内的数据迁移任务，迁移完成之后把transferIndex设置成一个负数，表示迁移完成；</p><p>如果没有其他线程进入，这个线程会再获得一个迁移范围，从而进行迁移，直到全部迁移完毕；</p><p>即使用分块的模式，让不同的线程负责不同的块，从而避免了扩容区间重叠，遗漏等问题</p><p><strong>3）在扩容时，有其他线程执行插入&#x2F;删除&#x2F;修改&#x2F;查询等操作怎么办？</strong></p><p>答：在原数组中，迁移过程中，槽都会被锁住，其他线程无法操作，只能阻塞在那里，等待释放锁后再操作</p><p>而当一个线程迁移完一段区域内的数据之后，迁移完成的槽，首位置节点都会设置成fwd，这个节点的hash值被设置成了MOVED，即-1</p><p>因此如果有put进来，根据前面分析，会直接把线程扔给辅助扩容数组，无法put成功，只能等待所有数据都迁移完毕</p><p>而如果调用了get方法呢？由于此时hash值小于0，会进入节点的find方法内部</p><p>此时，由于节点类型为fwd，所以进入的find方法会进入新建立的nextTable中找数据</p><p><em><strong>因此扩容中，槽上锁，get和put操作都不行</strong></em></p><p><em><strong>但是某一个槽迁移完毕后，可以get，不可以put</strong></em></p><p><strong>4）如何判断是在扩容状态还是扩容完毕状态的？</strong></p><p>由上面可知，迁移部分时，迁移完毕的槽会放进去一个fwd节点</p><p>全部迁移完毕后就是一个新的数组了，和之前操作没区别，不用判断状态</p><h5 id="2-2总结下迁移流程"><a href="#2-2总结下迁移流程" class="headerlink" title="2.2总结下迁移流程"></a>2.2总结下迁移流程</h5><ul><li>进入helpTransfer方法，判断当前线程是否能够进入搬迁大军当中</li><li>符合条件的线程，会调用transfer方法进行扩容</li><li>扩容时，会为每个线程分配一块儿区域，这个区域就是线程要进行迁移的范围</li><li>然后就是加锁搬迁</li><li>迁移完毕之后，原数组槽位置放进去一个fwd</li></ul><h3 id="四、元素数量统计"><a href="#四、元素数量统计" class="headerlink" title="四、元素数量统计"></a>四、元素数量统计</h3><h4 id="1-源码-3"><a href="#1-源码-3" class="headerlink" title="1.源码"></a>1.源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">  <span class="comment">// 统计元素个数</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">          <span class="comment">// 会完成CounterCell的初始化以及元素的累加</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 是否要做扩容</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">      <span class="comment">// helpTransfer -&gt; 第一次扩容的场景</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">fullAddCount</span><span class="params">(<span class="type">long</span> x, <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        CounterCell[] as; CounterCell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    <span class="type">CounterCell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterCell</span>(x); <span class="comment">// Optimistic create</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                          <span class="comment">// 针对已经初始化的数组的某个位置</span></span><br><span class="line">                          <span class="comment">// 去添加一个CounterCell</span></span><br><span class="line">                            CounterCell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="literal">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                collide = <span class="literal">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 扩容部分</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line">                      <span class="comment">// 一倍扩容</span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> <span class="title class_">CounterCell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                      <span class="comment">// 遍历加入新数组</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 如果CounterCell为空, 保证在初始化过程的线程安全性</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">          <span class="comment">//一旦cas成功，说明当前线程抢到了锁</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">                  <span class="comment">// 初始化长度为2的数组</span></span><br><span class="line">                    CounterCell[] rs = <span class="keyword">new</span> <span class="title class_">CounterCell</span>[<span class="number">2</span>];</span><br><span class="line">                  <span class="comment">// 把x保存到某个位置</span></span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">CounterCell</span>(x);</span><br><span class="line">                  <span class="comment">// 复制给成员变量counterCells</span></span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                    init = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="comment">// 释放锁</span></span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 最终的情况，直接修改baseCount</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-小结-3"><a href="#2-小结-3" class="headerlink" title="2.小结"></a>2.小结</h4><p>在jdk1.8中，由于存在多线程操作的情况，因此不再使用一个单独的变量来计算map中的元素数量，而是使用了一个数组CounterCell来进行统计</p><p>当put进一个元素后，会调用addCount方法来进行元素数量的增加</p><ul><li>首先会尝试对baseCount进行自增，当新增失败后表示竞争激烈</li><li>此时会使用CounterCell来进行元素统计，进入fullAddCount</li><li>如果CounterCell未初始化，则进行初始化为2，并把新增元素数量x随机放到一个位置</li><li>如果此时还无法放进去，即没有空闲的CounterCell，那么就会新建一个CounterCell，容量是2倍</li><li>然后将旧的都迁移过去，再尝试把x放进去</li></ul><p>大致流程如上</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ConcurrentHashMap使用了大量的CAS锁来保证并发安全，主要是扩容与元素统计略显复杂，putVal的主流程还是十分清晰的</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶之并发编程（四）Condition</title>
      <link href="/2022/11/02/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2022/11/02/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、线程的通信"><a href="#一、线程的通信" class="headerlink" title="一、线程的通信"></a>一、线程的通信</h3><h4 id="1-通信方式"><a href="#1-通信方式" class="headerlink" title="1.通信方式"></a>1.通信方式</h4><ol><li><strong>共享内存</strong>：多个线程共享同一块内存空间，可以直接在内存中读写数据进行通信。</li><li><strong>互斥锁</strong>：使用互斥锁来实现对共享资源的访问控制，确保同一时间只有一个线程能够访问共享资源，从而避免多个线程同时对资源进行读写而导致数据不一致的问题。</li><li><strong>条件变量</strong>：条件变量通常和互斥锁一起使用，用于线程之间的信号传递。一个线程可以等待某个条件变量被触发，另一个线程可以通过发送信号来触发条件变量，从而唤醒等待该条件变量的线程。</li><li><strong>信号量</strong>：信号量是一种用于线程间同步和互斥的机制。它可以用于多个线程之间的同步，以确保它们在互斥资源上的访问顺序正确。</li><li><strong>管道</strong>：管道是一种用于进程间通信的机制，但也可以用于线程之间的通信。一个线程可以将数据写入管道，另一个线程可以从管道中读取数据，从而实现线程之间的数据传输。</li><li><strong>消息队列</strong>：消息队列是一种用于进程间通信的机制，但也可以用于线程之间的通信。一个线程可以向消息队列发送消息，另一个线程可以从消息队列中读取消息，从而实现线程之间的数据传输。</li></ol><blockquote><p>线程间经常使用wait&#x2F;notify&#x2F;notifyAll进行通信，这种方式属于条件变量通信</p><p>wait&#x2F;notify关键字来源于Object类，属于native标注的Java内置方法，底层由C++来实现</p></blockquote><h4 id="2-同步队列与阻塞队列"><a href="#2-同步队列与阻塞队列" class="headerlink" title="2.同步队列与阻塞队列"></a>2.同步队列与阻塞队列</h4><p><strong>1）同步队列</strong></p><p>同步队列是Java中用于实现线程同步的一种数据结构，通常是一个先进先出（FIFO）的队列。它通常是指一个队列，其中的线程已经持有了锁&#x2F;或者尝试获取锁，但是由于某些原因（例如等待某些资源）无法执行，于是它们在队列中等待锁释放。</p><p>同步队列是通过Java内置的锁机制实现的，当一个线程在获取锁时，如果锁被其他线程持有，则该线程会进入同步队列中排队等待获取锁。当锁被释放时，队列中的线程会按照先进先出的顺序依次尝试获取锁并执行任务。</p><p>同步队列中的线程状态为<strong>BLOCKED</strong>或者<strong>RUNNABLE</strong></p><p><strong>说人话就是，同步队列当中放着持有锁或者正在等待拿锁的线程</strong></p><p><strong>2）等待队列&#x2F;阻塞队列</strong></p><p>一般来说，线程的等待队列是指线程在调用<strong>wait</strong>()方法时进入的一个队列，用于等待条件满足。当一个线程调用了对象的<strong>wait</strong>()方法后，该线程会释放占有的锁，并进入该对象的等待队列中等待被唤醒。线程在等待队列中会处于<strong>WAITING</strong>或<strong>TIMED_WAITING</strong>状态，等待其他线程通过<strong>notify</strong>()或<strong>notifyAll</strong>()方法将其唤醒。</p><h4 id="3-wait-x2F-notify"><a href="#3-wait-x2F-notify" class="headerlink" title="3.wait()&#x2F;notify()"></a>3.wait()&#x2F;notify()</h4><p>通过一个<strong>生产者-消费者</strong>模型来讲解下这两者的作用与关系</p><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; bags;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Queue&lt;String&gt; bags, <span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bags = bags;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    i++;</span><br><span class="line"><span class="keyword">synchronized</span> (bags)&#123; <span class="comment">//抢占锁 </span></span><br><span class="line">              <span class="keyword">if</span>(bags.size()==maxSize)&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;bags 满了&quot;</span>); </span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">//park(); -&gt;JVM -&gt;Native</span></span><br><span class="line">                      bags.wait(); <span class="comment">//满了，阻塞当前线程并且释放Producer抢到的锁 </span></span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">&#125; </span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产者生产:bag&quot;</span>+i); </span><br><span class="line">              bags.add(<span class="string">&quot;bag&quot;</span>+i); <span class="comment">//生产bag</span></span><br><span class="line">        bags.notify(); <span class="comment">//表示当前已经生产了数据，提示消费者可以消费了</span></span><br><span class="line">        &#125; <span class="comment">//同步代码快执行结束 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Queue&lt;String&gt; bags;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Queue&lt;String&gt; bags, <span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.bags = bags;</span><br><span class="line">       <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (bags)&#123;</span><br><span class="line">               <span class="keyword">if</span>(bags.isEmpty())&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;bags为空&quot;</span>); </span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                       bags.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">&#125; </span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">String bag=bags.remove(); </span><br><span class="line">             System.out.println(<span class="string">&quot;消费者消费:&quot;</span>+bag);</span><br><span class="line">bags.notify(); <span class="comment">//这里只是唤醒Producer线程，但是Producer线程并不能马上执行。</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，当生产者发现队列已满时，会调用wait()进行阻塞；当生产了资源之后，可以调用notify()通知消费者可以开始消费了；同理，消费者发现队列为空会陷入阻塞等待唤醒，消费后会尝试唤醒生产者</p><blockquote><p>这里要注意，只有持有锁的对象才可以调用wait()方法，不然会抛出异常</p></blockquote><h4 id="4-join"><a href="#4-join" class="headerlink" title="4.join"></a>4.join</h4><p>join也是基于wait&#x2F;notify来实现，notify是在线程销毁之后调用的</p><p><code>join()</code> 是 Java 中 Thread 类提供的一个方法，可以让一个线程等待另一个线程的结束，直到被等待的线程执行完毕，或者等待一定的时间，或者被中断。</p><p>具体来说，调用 <code>t.join()</code> 方法会让当前线程（通常是主线程）等待线程 <code>t</code> 执行完毕，也就是线程 <code>t</code> 终止之前，当前线程都会处于阻塞状态，等待线程 <code>t</code> 终止后才能继续执行。如果 <code>t</code> 在当前线程调用 <code>join()</code> 方法之前已经终止，那么 <code>join()</code> 方法会立即返回。</p><h4 id="5-Condition"><a href="#5-Condition" class="headerlink" title="5.Condition"></a>5.Condition</h4><p>Condition实际上就是J.U.C版本的wait&#x2F;notify。可以让线程基于某个条件去等待和唤醒</p><p>那么为什么有了wait&#x2F;notify的情况下，还要再去实现一个Condition呢？</p><p>Condition 的出现主要是为了解决 Object 中的 wait() 和 notify() 在多个线程等待同一个锁时的局限性。</p><p>Condition 提供了三个基本操作：</p><ol><li>await(): 使当前线程等待直到其他线程唤醒它。</li><li>signal(): 唤醒一个等待在 Condition 上的线程。</li><li>signalAll(): 唤醒所有等待在 Condition 上的线程。</li></ol><p>与 Object 的 wait() 和 notify() 方法相比，Condition 提供的操作更加灵活。它可以允许多个等待线程同时等待同一个锁，并且可以按照需要唤醒指定的线程或者所有线程。</p><p>另外，Condition 对象必须和一个 Lock 对象绑定使用，因为 Condition 需要依赖于锁来实现等待和唤醒操作</p><p><strong>Condition设计猜想</strong></p><ul><li><strong>作用</strong>: 实现线程的阻塞和唤醒 </li><li><strong>前提条件</strong>: 必须先要获得锁 await&#x2F;signal&#x2F;signalAll<ul><li>await -&gt; 让线程阻塞， 并且释放锁 </li><li>signal -&gt; 唤醒阻塞的线程</li></ul></li><li>加锁的操作，必然会涉及到AQS的阻塞队列</li><li>await 释放锁的时候，-&gt; AQS队列中不存在已经释放锁的线程 -&gt; 这个被释放的线程去了哪里? </li><li>signal 唤醒被阻塞的线程 -&gt; 从哪里唤醒?</li></ul><blockquote><p>通过await方法释放的线程，必须要有一个地方来存储，并且还需要被阻塞—–因此需要有一个等待队列</p><p>signal——从上面猜想到的等待队列中，唤醒一个线程——唤醒后放哪里去? 是不是应该再放到AQS队列?</p></blockquote><h3 id="二、Condition"><a href="#二、Condition" class="headerlink" title="二、Condition"></a>二、Condition</h3><h4 id="1-接口介绍"><a href="#1-接口介绍" class="headerlink" title="1.接口介绍"></a><strong>1.接口介绍</strong></h4><p>先来看看Condition接口定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Condition 对象必须和一个 Lock 对象绑定使用，因为 Condition 需要依赖于锁来实现等待和唤醒操作。例如，可以通过调用 Lock 的 newCondition() 方法来创建一个 Condition 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure><p>在使用 Condition 时，通常的流程是：</p><ol><li>获得锁。</li><li>判断条件是否满足，如果满足则执行相应的操作，否则执行 await() 方法将线程加入到等待队列中。</li><li>等待其他线程唤醒自己。</li><li>被唤醒后再次获得锁。</li><li>执行相应的操作并释放锁。</li></ol><h4 id="2-await方法"><a href="#2-await方法" class="headerlink" title="2.await方法"></a>2.await方法</h4><p>Condition是一个接口，本身是不包含方法的实现的，它在并发编程工具类之中，主要在两个类之中被使用，分别是<code>AbstractQueuedLongSynchronizer</code>与<code>AbstractQueuedSynchronizer</code>，后者正是前文提到过的AQS框架</p><blockquote><p>下面分析主要依据AQS框架之中实现Condition接口的内部类ConditionObject来分析</p></blockquote><p>在AQS框架之中，ConditionObject属于内部类，实现了Condition接口定义的诸多方法，其中await方法的实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">  <span class="comment">// 添加到等待队列</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter(); <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 完整的释放锁(考虑重入问题)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node); <span class="comment">// 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;  <span class="comment">// 3</span></span><br><span class="line">      <span class="comment">// 上下文切换(程序计数器、寄存器) 用户态-内核态的转化(上下文切换)</span></span><br><span class="line">      <span class="comment">// 阻塞当前线程(当其他线程调用signal()方法时，该线程会从这个位置去执行)</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">      <span class="comment">// 要判断当前被阻塞的线程是否是因为interrupt()唤醒</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>) <span class="comment">// 4</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 重新竞争锁，savedState表示的是被释放的锁的重入次数.</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)  <span class="comment">// 5</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 用于判断线程在等待过程中是否被中断，如果被中断，会设置线程的中断状态。</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意<code>LockSupport.park(this);</code>将线程阻塞在了这里</p></blockquote><p>概述上述方法执行步骤如下：</p><ol><li>获取当前线程的独占锁，并将状态设置为等待状态；</li><li>将当前线程加入等待队列中，等待唤醒；</li><li>释放独占锁，允许其他线程访问；</li><li>等待被唤醒，被唤醒后重新尝试获取独占锁；</li><li>获取到锁后，将等待状态清除。</li></ol><p>具体的，代码分析如下：</p><p>1.首先，调用了addConditionWaiter获得封装的节点，方法具体实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter; <span class="comment">// 最后一个等待节点</span></span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters(); <span class="comment">// 从头开始，清除所有CANCELLED状态的节点</span></span><br><span class="line">        t = lastWaiter; <span class="comment">// t始终指向最后一个等待队列的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 封装node为当前线程 设置为等待状态</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.用于完全释放独占锁或者共享锁，即如果node当前持有锁，则释放之；就是将持有锁的<strong>state</strong>值恢复为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;  <span class="comment">// 释放锁</span></span><br><span class="line">            failed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.用于判断指定的线程是否在 AQS 同步队列中，如果是，则需要将其从同步队列中移除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.其作用是在当前线程等待过程中检查中断状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// REINTERRUPT表示重置线程的中断状态，即线程在等待时被中断，</span></span><br><span class="line"><span class="comment">// 但是不能抛出异常，需要重置中断状态，让线程继续执行。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REINTERRUPT</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line"><span class="comment">// THROW_IE表示抛出InterruptedException异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROW_IE</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* transferAfterCancelledWait 方法的作用就是当一个线程被意外唤醒后，将该线程重新加入到等待队列中。</span></span><br><span class="line"><span class="comment">* 具体来说，该方法会将该线程从同步队列中删除，并重新将该线程加入到等待队列中，然后会对该线程进行自旋，等待被唤醒。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>5.<code>acquireQueued</code>是AQS中的一个核心方法，主要用于实现独占模式下的获取锁操作。该方法会在一个循环中不断尝试获取锁，如果获取不到，则会将当前线程包装成一个Node节点，并将其加入等待队列中，最后通过调用<code>parkAndCheckInterrupt</code>方法使线程阻塞等待唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-signal方法"><a href="#3-signal方法" class="headerlink" title="3.signal方法"></a>3.signal方法</h4><ul><li><p>要把被阻塞的线程，先唤醒(signal、signalAll) </p></li><li><p>把等待队列中被唤醒的线程转移到AQS队列中</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;<span class="comment">// 得到当前等待队列</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 唤醒等待队列中的一个线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唤醒操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">  <span class="comment">// 被取消，不能唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 这里是把当前等待队列中头部节点---&gt;保存到AQS队列</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唤醒之后，还记得上await方法中的<code>LockSupport.park(this);</code>吗？当时阻塞在这里，现在唤醒之后会继续往下执行</p><h4 id="4-Condition的实际应用"><a href="#4-Condition的实际应用" class="headerlink" title="4.Condition的实际应用"></a>4.Condition的实际应用</h4><p>-&gt;实现阻塞队列(业务组件) </p><p>-&gt; 在线程池中会用到阻塞队列 </p><p>-&gt; 生产者消费者</p><p>-&gt; 流量缓冲</p><h3 id="三、阻塞队列"><a href="#三、阻塞队列" class="headerlink" title="三、阻塞队列"></a>三、阻塞队列</h3><h4 id="1-什么叫阻塞队列"><a href="#1-什么叫阻塞队列" class="headerlink" title="1.什么叫阻塞队列?"></a>1.什么叫阻塞队列?</h4><p>队列是一种只允许在一端进行删除操作，在另一端进行插入操作的线性表，允许插入的一端称为队尾、<br>允许删除的一端称为队头。<br>那么阻塞队列，实际上是在队列的基础上增加了两个操作。</p><ul><li>支持阻塞插入:队列满了的情况下，会阻塞继续往队列中添加数据的线程，直到队列元素被释放。</li><li>只是阻塞移除:队列为空的情况下，会阻塞从队列中获取元素的线程，直到队列添加了新的元素。</li></ul><h4 id="2-阻塞队列中的方法"><a href="#2-阻塞队列中的方法" class="headerlink" title="2.阻塞队列中的方法"></a>2.阻塞队列中的方法</h4><p>添加元素</p><blockquote><p>针对队列满了之后的不同的处理策略</p></blockquote><ul><li>add -&gt; 如果队列满了，抛出异常</li><li>offer -&gt; true&#x2F;false ， 添加成功返回true，否则返回false</li><li>put -&gt; 如果队列满了，则一直阻塞</li><li>offer(timeout) , 带了一个超时时间。如果添加一个元素，队列满了，此时会阻塞timeout 时长，超过阻塞时长，返回false。</li></ul><p>移除元素</p><ul><li>element-&gt; 队列为空，抛异常</li><li>peek -&gt; true&#x2F;false ， 移除成功返回true，否则返回false take -&gt; 一直阻塞</li><li>poll(timeout) -&gt; 如果超时了，还没有元素，则返回null</li></ul><p>dequeue -&gt; LIFO , FIFO的队列.</p><h4 id="3-JUC中的阻塞队列"><a href="#3-JUC中的阻塞队列" class="headerlink" title="3.JUC中的阻塞队列"></a>3.JUC中的阻塞队列</h4><ul><li>ArrayBlockingQueue 基于数组结构 </li><li>LinkedBlockingQueue 基于链表结构 </li><li>PriorityBlcokingQueue 基于优先级队列 </li><li>DelayQueue 允许延时执行的队列 </li><li>SynchronousQueue 没有任何存储结构的的队列</li></ul><h4 id="4-ArrayBlockingQueue"><a href="#4-ArrayBlockingQueue" class="headerlink" title="4.ArrayBlockingQueue"></a>4.ArrayBlockingQueue</h4><p>变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The queued items */</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** items index for next take, poll, peek or remove */</span></span><br><span class="line"><span class="type">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** items index for next put, offer, or add */</span></span><br><span class="line"><span class="type">int</span> putIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of elements in the queue */</span></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Concurrency control uses the classic two-condition algorithm</span></span><br><span class="line"><span class="comment"> * found in any textbook.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Main lock guarding all access */</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><p>最终的入队方法，本质就是一个数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    items[putInd、ex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-LinkedBlockingQueue"><a href="#5-LinkedBlockingQueue" class="headerlink" title="5.LinkedBlockingQueue"></a>5.LinkedBlockingQueue</h4><p>本质就是一个单向链表，因此是无界阻塞队列</p><h4 id="6-PriorityBlcokingQueue"><a href="#6-PriorityBlcokingQueue" class="headerlink" title="6.PriorityBlcokingQueue"></a>6.PriorityBlcokingQueue</h4><p>双向链表组成的队列.</p><p>支持双向插入和移除. </p><p>在一定程度上能够解决多线程的竞争问题</p><h4 id="7-SynchronousQueue"><a href="#7-SynchronousQueue" class="headerlink" title="7.SynchronousQueue"></a>7.SynchronousQueue</h4><p>SynchronousQueue 是 Java 并发包中的一个特殊的 BlockingQueue 实现。它在一定程度上类似于管道，允许线程在管道两端之间进行信息传递，但它具有阻塞和同步的特性。</p><p>SynchronousQueue 的特点是容量为 0，也就是说在一个线程放入元素之前必须有另一个线程等待从队列中取走该元素。如果没有线程等待取元素，那么就无法插入元素，因此 put 操作将会一直阻塞，直到有另一个线程取走该元素。</p><p>SynchronousQueue 的主要用途是让一个线程等待另一个线程的结果，例如一个生产者线程等待一个消费者线程处理完数据。它可以用于生产者消费者模式、任务提交和任务执行的协调等场景，也可以用于一些特殊的任务调度场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SynchronousQueue</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> <span class="title class_">TransferQueue</span>&lt;E&gt;() : <span class="keyword">new</span> <span class="title class_">TransferStack</span>&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newCachedThreadPool线程池的实现队列，由于其容量为0，最大线程数基本处于最大，这种情况下可以创建大量线程，快速响应操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、阻塞队列的使用"><a href="#四、阻塞队列的使用" class="headerlink" title="四、阻塞队列的使用"></a>四、阻塞队列的使用</h3><h4 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1.CountDownLatch"></a>1.CountDownLatch</h4><blockquote><p>实现原理</p><ul><li>它可以让一个线程阻塞</li><li>也可以让多个线程阻塞</li></ul><p>共享锁的实现</p><p>可以允许多个线程同时抢占到锁，然后等到计数器归零的时候，同时唤醒. state记录计数器.</p><p>countDown的时候，实际上就是 state–</p></blockquote><p>CountDownLatch可以让许多线程阻塞，调用countDown直到计数器state为0后同时释放</p><p>因此它有两种使用方法</p><p>1.初始时设置state的值，在某一公共处调用await方法，所有操作都会阻塞在那里，在某些线程内调用countDown不断减小计数器，直到某一状态时统一放行；比如多线程处理某任务，阻塞主线程，等多线程任务处理完毕再统一放行；</p><p>2.在多线程内部调用await阻塞，将每个线程都拦在指定位置，然后调用一次countDown即可为所有线程放行</p><p>CountDownLatch用到的是AQS的共享锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS内方法，尝试获取共享锁，获取不到就封装入队，先自旋再次尝试获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Semaphore"><a href="#2-Semaphore" class="headerlink" title="2.Semaphore"></a>2.Semaphore</h4><p>信号灯.</p><p>限流器,限制资源的访问.</p><p>本质上: 抢占一个令牌. -&gt; 如果抢占到令牌，就通行， 否则，就阻塞!</p><ul><li>acquire() 抢占一个令牌 </li><li>release() 释放一个令牌.</li></ul><h4 id="3-CyclicBarrier"><a href="#3-CyclicBarrier" class="headerlink" title="3.CyclicBarrier"></a>3.<strong>CyclicBarrier</strong></h4><p>可重复的栅栏</p><p>相当于，多个线程通过CountDownLatch的await</p><p>然后另外一个线程使用countDown方法来唤醒</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶之并发编程（三）AQS详解</title>
      <link href="/2022/10/27/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2022/10/27/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是JUC"><a href="#一、什么是JUC" class="headerlink" title="一、什么是JUC"></a>一、什么是JUC</h3><p>JUC指的是Java并发编程工具包（Java Concurrency Utilities），它提供了一系列的工具类和接口，用于简化并发编程的开发。虽然Java语言中已经提供了synchronized关键字来支持多线程并发编程，但是JUC提供了更加灵活和高效的实现方式，以满足更加复杂的并发编程需求。</p><p>具体来说，JUC提供了以下几个重要的类和接口：</p><ol><li>Lock和Condition：Lock和Condition是替代synchronized关键字的工具，它们提供了更加灵活和可控的线程同步机制，使得在高并发情况下能够更加高效地协调线程之间的交互。</li><li>Semaphore：Semaphore是一种计数信号量，它可以用来控制同时访问某个资源的线程数量。</li><li>CountDownLatch：CountDownLatch是一种倒计数器，它可以让一个线程等待多个其他线程执行完毕后再继续执行。</li><li>CyclicBarrier：CyclicBarrier也是一种倒计数器，它可以让多个线程相互等待，直到所有线程都到达某个屏障点后再一起继续执行。</li><li>Executor和ExecutorService：Executor和ExecutorService是线程池的实现，它们可以有效地管理和控制线程的数量，从而避免创建过多的线程导致系统资源浪费和性能下降。</li></ol><p>综上所述，虽然synchronized关键字可以实现基本的线程同步和互斥，但在高并发情况下，JUC提供的工具类和接口能够更加灵活和高效地协调线程之间的交互，从而提高程序的性能和可靠性。</p><p>在正式介绍JUC之前，先思考一个问题，那就是如果让我们自己实现一个类似sychronized的锁机制，我们要如何去设计呢？</p><p><strong>锁设计猜想</strong></p><ul><li><p>一定会设计到锁的抢占 ， 需要有一个标记来实现互斥。 全局变量(0，1)</p></li><li><p>抢占到了锁，怎么处理(不需要处理.)</p></li><li><p>没抢占到锁，怎么处理</p><ul><li>需要等待(让处于排队中的线程，如果没有抢占到锁，则直接先阻塞-&gt;释放CPU资源)。 <ul><li>如何让线程等待?<ul><li>wait&#x2F;notify(线程通信的机制，<strong>无法指定唤醒某个线</strong>程)</li><li><strong>LockSupport.park&#x2F;unpark</strong>(阻塞一个指定的线程，唤醒一个指定的线程) Condition</li></ul></li></ul></li><li>需要排队(允许有N个线程被阻塞，此时线程处于活跃状态)。 <ul><li>通过一个数据结构，把这N个排队的线程存储起来。</li></ul></li></ul></li><li><p>抢占到锁的释放过程，如何处理</p><ul><li>LockSupport.unpark() -&gt; 唤醒处于队列中的指定线程.</li></ul></li><li><p>锁抢占的公平性(是否允许插队)</p></li><li><p>公平 </p></li><li><p>非公平</p></li></ul><p>在JUC中，AQS（AbstractQueuedSynchronizer）即是实现上述过程的一个框架类</p><h3 id="二、AQS"><a href="#二、AQS" class="headerlink" title="二、AQS"></a>二、AQS</h3><p>AQS（AbstractQueuedSynchronizer）是一个用于构建锁、同步器等并发组件的框架<br>它是Java并发包（java.util.concurrent）的核心组件之一。</p><p>首先介绍一下AQS中用到的一些类与变量</p><h4 id="1-内部类—Node"><a href="#1-内部类—Node" class="headerlink" title="1.内部类—Node"></a>1.内部类—Node</h4><p>Node作为等待队列节点类，在线程竞争锁失败后，AQS会将线程封装成一个Node节点，放入等待队列当中，自旋等待，自旋竞争再次失败后就会进入等待状态，等待被唤醒再次竞争锁</p><p>Node类包含以下主要字段：</p><ol><li>prev：指向前一个节点的指针。</li><li>next：指向后一个节点的指针。</li><li>thread：持有该节点的线程对象。</li><li>waitStatus：用于表示线程的状态，包括取消、阻塞、等待等。</li><li>nextWaiter：用于在等待队列中链接不同条件的线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     +------+  prev +-----+       +-----+</span><br><span class="line">head |      | &lt;---- |     | &lt;---- |     |  tail</span><br><span class="line">     +------+       +-----+       +-----+</span><br></pre></td></tr></table></figure><p>Node类源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">/** 标识共享模式的静态常量，它被用于表示线程等待的条件是共享的，而不是独占的 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="comment">/** 标识独占模式的静态常量，它被用于表示线程等待的条件是独占的，而不是共享的 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 用于标记一个节点已经被取消，不再参与同步操作 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** 用于表示一个节点已经被唤醒，并且可以尝试竞争同步资源 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">  *是一个表示节点所属的条件队列的静态常量。它被用于区分节点所属的等待队列和条件队列</span></span><br><span class="line"><span class="comment">  * 每个节点在创建时，都会与一个特定的条件队列相关联。</span></span><br><span class="line"><span class="comment">* 当节点被添加到等待队列中时，它的CONDITION字段会被设置为与它相关联的条件队列。</span></span><br><span class="line"><span class="comment">* 在等待队列中，节点的状态为WAITING或SIGNAL；而在条件队列中，节点的状态为CONDITION。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/** 标志表示当前节点需要向后传播唤醒信号，通知后继节点可以尝试获取锁 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"><span class="comment">/** 表示持有锁或正在等待锁的线程 */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 指向同步队列头</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指向同步队列尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure><p>同步队列是AQS中一个重要的概念，用于实现线程的阻塞和唤醒，以及线程的竞争获取同步状态。</p><p>AQS中包含了三种队列概念：等待队列、条件队列和同步队列。</p><ol><li><strong>等待队列</strong>（Wait Queue）：等待队列是AQS中用于存放<strong>被阻塞</strong>的线程的数据结构。当一个线程需要获取同步状态，但是当前同步状态已经被其他线程占用时，该线程会被封装成一个Node节点并加入到等待队列中。等待队列是一个FIFO队列，可以保证等待时间最长的线程先被唤醒。</li><li><strong>条件队列</strong>（Condition Queue）：条件队列是<strong>基于等待队列</strong>实现的，用于支持条件变量的功能。当一个线程需要等待一个条件变量时，它会被封装成一个Node节点并加入到条件队列中，而不是等待队列中。当满足条件时，条件队列中的线程会被转移至等待队列中等待获取同步状态。</li><li><strong>同步队列</strong>（Sync Queue）：同步队列是AQS中存放<strong>已经获取到同步状态的线程（即通过acquire获取成功）</strong>的数据结构。当一个线程获取到同步状态后，它会从等待队列中转移到同步队列中，并且会释放之前占有的同步状态。同步队列的管理是通过head和tail指针实现的，head指向同步队列的第一个节点，tail指向同步队列的最后一个节点。</li></ol><blockquote><p>此外，还需要注意<code>exclusiveOwnerThread</code>这个变量，它来自于AQS的抽象父类<code>AbstractOwnableSynchronizer</code>，该类就两个方法，分别是设置和获取该变量<code>exclusiveOwnerThread</code></p></blockquote><h4 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a>3.方法</h4><p>AQS中的几个重要方法如下：</p><ol><li>acquire(int arg)：尝试获取独占锁，如果获取失败，则将当前线程加入同步队列并进行自旋或者阻塞，直到获取成功或者被中断。</li><li>acquireShared(int arg)：尝试获取共享锁，如果获取失败，则将当前线程加入同步队列并进行自旋或者阻塞，直到获取成功或者被中断。</li><li>release(int arg)：释放独占锁。</li><li>releaseShared(int arg)：释放共享锁。</li><li>tryAcquire(int arg)：尝试获取独占锁，如果获取成功，则返回true，否则返回false。</li><li>tryAcquireShared(int arg)：尝试获取共享锁，如果获取成功，则返回一个大于等于0的值，表示获取共享锁的线程数，否则返回负数。</li><li>tryRelease(int arg)：尝试释放独占锁，如果成功则返回true，否则返回false。</li><li>tryReleaseShared(int arg)：尝试释放共享锁，如果成功则返回true，否则返回false。</li><li>acquireInterruptibly(int arg)：尝试获取独占锁，如果获取失败，则将当前线程加入同步队列并进行自旋或者阻塞，直到获取成功或者被中断。</li></ol><p>这些方法是AQS中的核心方法，用于实现同步和互斥。</p><ul><li><p>acquire()、acquireShared()、release()、releaseShared() 是AQS中最常用的同步方法</p></li><li><p>tryAcquire()、tryAcquireShared()、tryRelease()、tryReleaseShared() 则是尝试获取&#x2F;释放同步状态，这些方法一般是被重载后使用。</p></li><li><p>acquireInterruptibly() 方法也是尝试获取独占锁，不过它会响应中断。</p></li></ul><h5 id="1）compareAndSetState"><a href="#1）compareAndSetState" class="headerlink" title="1）compareAndSetState"></a><strong>1）compareAndSetState</strong></h5><p>AQS中通过state变量来标识同步状态，为了保证state参数修改的可见性、原子性，在AQS当中使用CAS机制来进行state的修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）acquire"><a href="#2）acquire" class="headerlink" title="2）acquire"></a><strong>2）acquire</strong></h5><p>尝试获取独占锁，如果获取失败，则将当前线程加入同步队列并进行自旋或者阻塞，直到获取成功或者被中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>tryAcquire</code> 是 AQS 中一个抽象方法，需要用户自定义实现。在 AQS 中，同步状态的获取和释放都是通过 <code>tryAcquire</code> 和 <code>tryRelease</code> 方法实现的，因此用户可以根据自己的需求来定义同步状态的获取和释放逻辑。</p><p><code>addWaiter</code> 方法是 AQS 中的一个辅助方法，用于将一个新的 <code>Node</code> 节点加入到等待队列中，并返回这个新节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，AQS中的<code>enq</code>方法用于将线程加入到等待队列中，实现方式是通过CAS（compare-and-swap）操作将节点插入到队尾，保证线程的插入是原子性的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquireQueued传入<code>addWaiter</code> 方法返回的节点，一丝是在线程被包装成节点入队之后，还会尝试调用自旋来获取锁，步骤如下：</p><ol><li>尝试获取锁，如果成功则直接返回。</li><li>如果获取锁失败，则线程会进入自旋状态，不断地检查前驱节点的状态是否为 SIGNAL。</li><li>如果前驱节点状态为 SIGNAL，说明当前线程可以尝试获取同步状态了，于是调用tryAcquire方法再次尝试获取锁。</li><li>如果获取锁成功，则当前线程会从等待队列中移除，并返回。</li><li>如果tryAcquire方法返回false，则当前线程会继续自旋等待前驱节点唤醒自己。</li></ol><blockquote><p>acquireQueued方法中的自旋是在等待前驱节点释放锁的过程中进行的，如果等待时间过长，一般是由于前驱节点无法释放锁，这时会进入阻塞状态。在进入阻塞状态前，会将自己的节点状态设置为WAITING，并通过LockSupport.park()方法挂起线程，等待前驱节点的唤醒。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node表示当前来抢占锁的线程</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 自旋</span></span><br><span class="line">          <span class="comment">// 尝试去获得锁</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 返回true，不需要等待直接返回</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 否则让线程去阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于在当前线程上阻塞，直到被其他线程唤醒或中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>); <span class="comment">// 使当前线程阻塞</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 返回当前线程中断状态，即是否被中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3）acquireShared"><a href="#3）acquireShared" class="headerlink" title="3）acquireShared"></a><strong>3）acquireShared</strong></h5><p>尝试获取共享锁，如果获取失败，则将当前线程加入同步队列并进行自旋或者阻塞，直到获取成功或者被中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4）release"><a href="#4）release" class="headerlink" title="4）release"></a><strong>4）release</strong></h5><p>释放独占锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，tryRelease交给子类实现</p><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h4><p>AQS是一个用于构建同步器的框架，它为子类提供了许多方法，使得子类仅需要重写部分方法就可以方便的实现同步功能，下面是AQS为子类提供的一些公共功能</p><ol><li>获取&#x2F;释放锁：AQS提供了acquire()和release()两个方法，这两个方法是获取锁和释放锁的基础。</li><li>等待队列的操作：AQS提供了许多操作等待队列的方法，例如enq()、deq()、transferForSignal()等等。这些方法让子类能够方便地实现等待队列的管理。</li><li>条件队列的操作：AQS还提供了一些操作条件队列的方法，例如addConditionWaiter()、transferAfterCancelledWait()等等。这些方法可以让子类方便地实现条件队列的管理。</li><li>重入锁的实现：AQS还提供了一些方法，可以方便地实现重入锁。例如tryAcquire()、tryRelease()等等。</li><li>共享锁的实现：AQS提供了一些方法，可以方便地实现共享锁。例如tryAcquireShared()、tryReleaseShared()等等。</li><li>线程的中断处理：AQS提供了interruptMode()和clearInterruptsForReentry()两个方法，可以方便地处理线程中断的情况。</li></ol><p>总的来说，AQS并没有定义具体的加锁和释放锁的逻辑，而是通过子类来实现这些逻辑，同时提供了一些钩子方法，使得子类可以在特定的时间点进行扩展和定制。这种设计能够提高复用性和灵活性，使得开发者可以快速地构建出各种同步器，以满足不同的需求。</p><p>其中，子类至少需要重写以下方法：</p><ol><li><strong>tryAcquire</strong>(int)：尝试以独占模式获取同步状态，如果获取成功，返回true，否则返回false。</li><li><strong>tryRelease</strong>(int)：尝试以独占模式释放同步状态，如果释放成功，返回true，否则返回false。</li><li><strong>tryAcquireShared</strong>(int)：尝试以共享模式获取同步状态，如果获取成功，返回大于等于0的值，否则返回小于0的值。</li><li><strong>tryReleaseShared</strong>(int)：尝试以共享模式释放同步状态，如果释放成功，返回true，否则返回false。</li></ol><h3 id="三、ReentrantLock类"><a href="#三、ReentrantLock类" class="headerlink" title="三、ReentrantLock类"></a>三、ReentrantLock类</h3><h4 id="1-基础分析"><a href="#1-基础分析" class="headerlink" title="1.基础分析"></a>1.基础分析</h4><p>ReentrantLock并不是直接继承了AQS抽象类，而是定义了一个内部类来继承AQS，并在此基础上分别实现了公平锁与非公平锁两种同步类型，宏观上看代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 默认实现非公平锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在不指定锁类型时，声明的就是非公平锁，如果传入了boolean值，则判断后生成公平或者非公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-非公平锁-加锁"><a href="#2-非公平锁-加锁" class="headerlink" title="2.非公平锁-加锁"></a>2.非公平锁-加锁</h4><p>首先看加锁过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 无论AQS中是否有排队情况，都会尝试插队抢占锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 插队失败后执行AQS中的acquire方法</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面已经分析过acquire方法，这里不再赘述，简单来说就是一个封装线程为节点入队，并在入队后自旋尝试继续获取锁的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由ReentrantLock实现的非公平锁加锁过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 无锁状态</span></span><br><span class="line">      <span class="comment">// 不管队列情况，直接抢锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//CAS(#Lock) -&gt; 原子操作| 实现互斥的判断</span></span><br><span class="line">            setExclusiveOwnerThread(current); <span class="comment">//把获得锁的线程保存到exclusiveOwnerThread中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//如果当前获得锁的线程和当前抢占锁的线程是同一个，表示重入</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires; <span class="comment">// 增加重入次数</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc); <span class="comment">// 保存state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-公平锁-加锁"><a href="#3-公平锁-加锁" class="headerlink" title="3.公平锁-加锁"></a>3.公平锁-加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试抢占一把锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS中定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试获取锁</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 注意与非公平锁的tryAcquire方法区别在这里</span></span><br><span class="line">      <span class="comment">// hasQueuedPredecessors用来判断当前线程是否有前驱节点，如果有就不能抢占</span></span><br><span class="line">      <span class="comment">// 即需要按照入队顺序依次获取锁，如果当前线程前面有线程未获得锁，当前线程也不能抢占</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-解锁"><a href="#4-解锁" class="headerlink" title="4.解锁"></a>4.解锁</h4><p>ReentrantLock类内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AQS中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 判断是否完全释放了锁，即state为0</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 队列不为空，尝试唤醒</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases; <span class="comment">// state新值</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">//判断释放锁的线程是否持有锁</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">//完全释放了锁</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>); <span class="comment">// 释放独占标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) <span class="comment">// 表示可以唤醒状态</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>); <span class="comment">// 恢复状态值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">// 说明这个线程已经被销毁，或者存在异常</span></span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 从tail往head进行遍历</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 查找状态小于等于0，表示需要被唤醒</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 最后找到的是head后面第一个能唤醒的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);<span class="comment">// 唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是waitStatus的取值与代表意义</p><ul><li>SIGNAL(-1)：表示当前节点的后继节点需要被唤醒。</li><li>CANCELLED(1)：表示当前节点已经取消等待。</li><li>CONDITION(2)：表示当前节点在条件队列中等待。</li><li>PROPAGATE(-3)：用于共享模式下，表示后继节点需要向前传播唤醒信号。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶之并发编程（二）volatile关键字</title>
      <link href="/2022/10/05/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/10/05/Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是线程安全的可见性与有序性"><a href="#一、什么是线程安全的可见性与有序性" class="headerlink" title="一、什么是线程安全的可见性与有序性"></a>一、什么是线程安全的可见性与有序性</h3><p>先看如下案例，在该样例中，线程外将stop改为true之后，理论上线程会跳出while循环进而终止，但是实际运行会发现线程依然继续运行，为什么会出现这种情况呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> stop=<span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">               i++;</span><br><span class="line">&#125; </span><br><span class="line">       &#125;);</span><br><span class="line">       t1.start();</span><br><span class="line">       System.out.println(<span class="string">&quot;begin start thread&quot;</span>);</span><br><span class="line">       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       stop=<span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为现代JVM实现（如HotSpot JVM）中的即时编译器会对程序进行代码优化，从而导致对<code>stop</code>变量的读取在循环中只被执行一次，即初始状态下读取到的true，而外部对<code>stop</code>的修改并不能被线程内部的<code>stop</code>所获取到，这就是所谓的<strong>可见性</strong>问题</p><p>想解决上述代码可见性问题，只需要增加一个<code>volatile</code>关键字即可，该关键字可以保证代码的可见性</p><p>那什么是有序性问题呢？看如下案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderingDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        x = <span class="number">42</span>;  <span class="comment">// 写操作</span></span><br><span class="line">        flag = <span class="literal">true</span>;  <span class="comment">// 写操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;  <span class="comment">// 读操作</span></span><br><span class="line">            System.out.println(x);  <span class="comment">// 读操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ReorderingDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReorderingDemo</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        demo.writer();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        demo.reader();</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上述代码中，线程1调用了<code>writer</code>方法，而线程2调用了<code>reader</code>方法。由于没有使用同步机制或者<code>volatile</code>关键字，线程2可能会看到变量<code>flag</code>为<code>true</code>，但是变量<code>x</code>的值还没有被写入，从而导致输出的x值为0</p><p>这是因为在java当中，如果一段代码没有强依赖关系，那么在多线程条件下这些代码可能会被重排序，从而导致并发顺序问题；此外，<code>x = 42</code>并不是一个原子性操作，而是由初始化x为0和将42赋值给x两步组成的，因此多线程条件下可能会先拿到为0的x值，这就是线程的有序性问题</p><h3 id="二、为什么会出现可见性问题"><a href="#二、为什么会出现可见性问题" class="headerlink" title="二、为什么会出现可见性问题"></a>二、为什么会出现可见性问题</h3><h4 id="1-为了性能处理所做的优化"><a href="#1-为了性能处理所做的优化" class="headerlink" title="1.为了性能处理所做的优化"></a>1.为了性能处理所做的优化</h4><p>在整个计算机的发展历程中，除了CPU、内存以及I&#x2F;O设备不断迭代升级来提升计算机处理性能之外， 还有一个非常核心的矛盾点，就是这三者在处理速度的差异。CPU的计算速度是非常快的，其次是内存、最后是IO设备(比如磁盘)，也就是CPU的计算速度远远高于内存以及磁盘设备的I&#x2F;O速度。</p><p>为了平衡这三者之间的速度差异，最大化的利用CPU。所以在硬件层面、操作系统层面、编译器层面做出了很多的优化</p><ul><li>CPU增加了高速缓存</li><li>操作系统增加了进程、线程。通过CPU的时间片切换最大化的提升CPU的使用率 </li><li>编译器的指令优化，更合理的去利用好CPU的高速缓存</li></ul><p>每一种优化，都会带来相应的问题，而这些问题是导致线程安全性问题的根源，那接下来我们逐步去了解这些优化的本质和带来的问题</p><h4 id="2-CPU层面的缓存"><a href="#2-CPU层面的缓存" class="headerlink" title="2.CPU层面的缓存"></a>2.CPU层面的缓存</h4><p>CPU在做计算时，和内存的IO操作是无法避免的，而这个IO过程相对于CPU的计算速度来说是非常耗时，基于这样一个问题，所以在CPU层面设计了高速缓存，这个缓存行可以缓存存储在内存中的数据，CPU每次会先从缓存行中读取需要运算的数据，如果缓存行中不存在该数据，才会从内存中加载，通过这样一个机制可以减少CPU和内存的交互开销从而提升CPU的利用率。</p><p>对于主流的x86平台，cpu的缓存行(cache)分为L1、L2、L3总共3级。</p><p><img src="https://static-2w2.pages.dev/post/levelCache.png" alt="image-20230327011219482"></p><p><strong>1）缓存一致性问题</strong></p><p>CPU高速缓存的出现，虽然提升了CPU的利用率，但是同时也带来了另外一个问题—缓存一致性问题， 这个一致性问题体现在。</p><p>在多线程环境中，当多个线程并行执行加载同一块内存数据时，由于每个CPU都有自己独立的L1、L2缓存，所以每个CPU的这部分缓存空间都会缓存到相同的数据，并且每个CPU执行相关指令时，彼此之间不可见，就会导致缓存的一致性问题。</p><p><strong>2）缓存一致性协议</strong></p><p>为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，常 见的协议有MSI，MESI，MOSI等。最常见的就是MESI协议。接下来简单讲解一下MESI。</p><p><strong>MESI表示缓存行的四种状态，分别是</strong></p><ul><li>M(Modify) 表示共享数据只缓存在当前CPU缓存中，并且是被修改状态，也就是缓存的 数据和主内存中的数据不一致</li><li>E(Exclusive) 表示缓存的独占状态，数据只缓存在当前CPU缓存中，并且没有被修改</li><li>S(Shared) 表示数据可能被多个CPU缓存，并且各个缓存中的数据和主内存数据一致</li><li>I(Invalid) 表示缓存已经失效</li></ul><p>在CPU的缓存行中，每一个Cache一定会处于以下三种状态之一</p><ol><li><strong>Shared状态</strong>：表示该缓存块正在被多个处理器共享。在该状态下，缓存块的副本位于多个处理器的缓存中，这些副本之间的数据应该是相同的，因此任何一个处理器的缓存更改都必须与其他处理器的缓存同步。</li><li><strong>Exclusive状态</strong>：表示该缓存块只存在于当前处理器的缓存中。在这种情况下，当前处理器是唯一可以访问该缓存块的处理器，并且其他处理器无法访问该缓存块。如果其他处理器需要访问该缓存块，则必须先使其从Exclusive状态转换为Shared状态。</li><li><strong>Invalid状态</strong>：表示该缓存块无效或者已经过期，不能被任何处理器使用。当某个处理器修改了一个缓存块的数据时，该缓存块的状态会变为Invalid状态，此时其他处理器需要刷新其缓存中的数据，以确保其缓存中的数据与内存中的数据一致。</li></ol><blockquote><p>即共享，独占和无效</p></blockquote><p>但是，缓存一致性协议情况下依然可能会存在<strong>指令重排序</strong>问题，一般采用<strong>内存屏障</strong>来处理，保证指令有序性与可见性</p><p>也可以使用<strong>缓存锁&#x2F;总线锁</strong>等机制解决</p><h4 id="3-指令重排序问题"><a href="#3-指令重排序问题" class="headerlink" title="3.指令重排序问题"></a>3.指令重排序问题</h4><p><strong>CPU层面</strong>的指令重排序问题是指在现代处理器中，为了提高指令执行效率，处理器内部可能会对指令进行重排序，从而可能导致指令的执行顺序发生变化。这种重排序通常不会影响程序的语义，但是在多线程环境下，如果不加以控制，就可能会导致线程之间的数据竞争和有序性问题。</p><p>比如存在a和b两个普通共享变量，a变量被一个线程修改后，有缓存还没有更新a值，这时候b变量用到了a变量的值，但是读取到了修改前的值，从而导致线程安全问题</p><p><strong>Java层面</strong>的指令重排序问题是指在Java程序中，由于JVM的优化机制和编译器的优化策略，可能会导致程序中的指令执行顺序发生变化。这种重排序通常不会影响单线程程序的语义，但是在多线程环境下，如果不加以控制，就可能会导致线程之间的数据竞争和有序性问题。</p><p>java层面，最常见解决可见性与有序性问题的手段是使用<code>volatile</code>关键字或者加锁</p><p>本质是采用了内存屏障的技术</p><h4 id="4-内存屏障"><a href="#4-内存屏障" class="headerlink" title="4.内存屏障"></a>4.内存屏障</h4><p>内存屏障（Memory Barrier），也叫内存栅栏，是一种CPU硬件提供的指令，用于限制处理器和内存的乱序执行和重排序。内存屏障可以被用来保证指令的执行顺序、控制CPU和内存之间的同步、保证内存可见性等。内存屏障通常分为以下几种：</p><ol><li><strong>Load Barrier</strong>（读屏障）：它保证在读取某个变量的值之前，其它变量的值已经被加载到处理器的缓存中。读屏障确保了程序的有序性和可见性，避免了程序中出现未初始化的变量或无效的数据。</li><li><strong>Store Barrier</strong>（写屏障）：它保证在修改某个变量的值之后，其它变量的值被刷新到内存中。写屏障确保了程序的有序性和可见性，避免了出现脏数据或不一致的数据。</li><li><strong>Full Barrier</strong>（全屏障）：它同时包括了读屏障和写屏障的功能，保证了程序的所有操作都是有序的。全屏障一般比较耗费资源，只在特定情况下使用。</li></ol><p>在Java中，<code>volatile</code>关键字使用的内存屏障主要包括<code>store-store</code>屏障、<code>load-load</code>屏障和<code>store-load</code>屏障，它们合起来构成了一种全屏障的机制。</p><ul><li><code>store-store</code>屏障会保证在该屏障之前的所有<code>store</code>指令都已经完成，确保该屏障之前的所有修改对其他线程可见；</li><li><code>load-load</code>屏障会保证在该屏障之后的所有<code>load</code>指令都能够读取到最新的值，确保该屏障之后的所有读操作都是有效的；</li><li><code>store-load</code>屏障会保证在该屏障之前的所有<code>store</code>指令都已经完成，确保该屏障之前的所有修改对其他线程可见，同时会强制所有之后的<code>load</code>指令重新从内存中读取数据，而不是使用之前的缓存数据，确保该屏障之后的所有读操作都能够读取到最新的值。</li></ul><h3 id="三、JMM模型"><a href="#三、JMM模型" class="headerlink" title="三、JMM模型"></a>三、JMM模型</h3><p>简单来说，<strong>Java内存模型（JMM）定义了多线程程序中，线程之间通过内存进行通信的规则和限制。</strong></p><p>具体的，Java内存模型规定了所有的变量都存储在<strong>主内存</strong>中，每条线程还有自己的<strong>工作内存</strong>，线程的工作内存中保存了这个线程中用到的变量的<strong>主内存副本拷贝</strong>，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。</p><p>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行，流程图如下:</p><img src="https://static-2w2.pages.dev/post/jmm.jpeg" alt="image-20230327011219482" style="zoom: 67%;" /><p>目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题</p><blockquote><p>本地内存是JMM的一个抽象概念，并不真实存在。</p><p>它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p></blockquote><p>上面的可见性与有序性问题主要是通过volatile关键字来解决的，那有哪些情况是，不需要通过增加volatile关键字，也能保证在多线程环境下的可见性和有序性的呢?</p><p>从JDK1.5开始，引入了一个<strong>happens-before</strong>的概念来阐述多个线程操作共享变量的可见性问题。所以我们可以认为在JMM中，如果一个操作执行的结果需要对另一个操作课件，那么这两个操作必须要存在 happens-before关系。这两个操作可以是同一个线程，也可以是不同的线程。</p><h4 id="1-happens-before-规则"><a href="#1-happens-before-规则" class="headerlink" title="1.happens-before 规则"></a>1.happens-before 规则</h4><p>“<strong>happens-before</strong>“ 是 Java 内存模型（JMM）中的一个概念，用来描述多线程程序中各个线程之间操作的先后顺序。</p><p>具体来说，如果操作 A happens-before 操作 B，那么 A 一定在 B 之前执行，且 B 可以看到 A 执行的结果。happens-before 规则定义了一组顺序关系，用来保证多线程程序中的操作顺序，从而确保程序的正确性和可移植性。</p><p>happens-before 规则包括以下几个方面：</p><ol><li><strong>传递性</strong>（Transitivity）规则：如果事件 A 在事件 B 之前发生，事件 B 在事件 C 之前发生，那么事件 A 必须在事件 C 之前发生。</li><li><strong>volatile</strong> 变量规则：如果一个线程先写一个 volatile 变量，然后另一个线程读取该变量，那么这个写操作将 happen-before 于这个读操作。</li><li><strong>监视器锁</strong>规则：如果一个线程获得了一个监视器锁并释放了它，那么这个获得操作将 happen-before 于这个释放操作。</li><li><strong>start</strong> 规则：如果线程 A 启动线程 B，那么线程 A 的 start 操作将 happen-before 于线程 B 的任意操作。</li><li><strong>join</strong> 规则：如果线程 A 等待线程 B 结束，那么线程 B 的任意操作都将 happen-before 于线程 A 的 join 操作返回。</li></ol><h4 id="2-as-if-serial"><a href="#2-as-if-serial" class="headerlink" title="2.as-if-serial"></a>2.as-if-serial</h4><p>“as-if-serial” 是指，虚拟机可以对指令进行重排序，只要重排序后的执行结果与原来的执行结果一致，就可以保证程序的正确性。换句话说，虚拟机可以将指令序列中无关联的操作进行并行执行，只要保证最终的结果与串行执行的结果一致即可。</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶之设计模式</title>
      <link href="/2022/10/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/10/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="一、设计原则"><a href="#一、设计原则" class="headerlink" title="一、设计原则"></a>一、设计原则</h3><h4 id="1-接口隔离原则"><a href="#1-接口隔离原则" class="headerlink" title="1.接口隔离原则"></a>1.接口隔离原则</h4><p><strong>核心思想：</strong>将接口拆分成多个小的、专门的接口，避免大而全的接口导致实现类必须实现无用的方法，从而提高代码的灵活性、可扩展性和可维护性。</p><p>解析：即接口要分割的足够小，功能尽量高内聚，不要太多冗余方法</p><p>以下是一个满足接口隔离原则的<strong>正例</strong>。假设我们有一个图形类<code>Shape</code>，它有一个计算面积的方法<code>calculateArea()</code>和一个计算周长的方法<code>calculatePerimeter()</code>。我们可以将这两个方法拆分成两个接口<code>AreaCalculatable</code>和<code>PerimeterCalculatable</code>，然后让实现<code>Shape</code>类的类只实现它们需要的接口。这个设计可以避免实现一个不需要的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AreaCalculatable</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PerimeterCalculatable</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculatePerimeter</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">AreaCalculatable</span>, PerimeterCalculatable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">double</span> width, <span class="type">double</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculatePerimeter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (width + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>反例</strong>，假设有一个动物接口，它定义了一系列方法，包括吃、喝、跑和飞等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drink</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而实际上，一个动物很可能并不具有所有的这些能力，比如企鹅不会飞，老鹰也不一定会游泳，这里违背了接口隔离原则，需要接口功能更加细化</p><h4 id="2-迪米特法则"><a href="#2-迪米特法则" class="headerlink" title="2.迪米特法则"></a>2.迪米特法则</h4><p><strong>核心思想：</strong>也叫作最少知识原则（Least Knowledge Principle，LKP），是一种面向对象设计原则，它要求一个对象应当对其他对象有<strong>尽可能少</strong>的了解，也就是说一个对象应当尽可能少地与其他对象发生相互作用。迪米特法则的核心思想是“不和陌生人说话”，它的目的是降低类之间的耦合度，从而提高系统的灵活性和可维护性。</p><p><strong>解析：</strong>主要是为了降低类之间的耦合度，便于后期维护与阅读，同时满足高内聚低耦合的设计思想，具体优点如下</p><ul><li>降低耦合度：迪米特法则可以降低类之间的耦合度，避免不必要的依赖关系，从而提高系统的灵活性和可维护性。</li><li>提高可重用性：迪米特法则可以将类的内部实现和外部接口进行分离，使得类的实现更加独立和可重用。</li><li>易于测试：迪米特法则可以降低类之间的依赖关系，使得单元测试更加容易进行。</li><li>易于扩展：迪米特法则可以降低类之间的耦合度，使得系统更加容易扩展和维护。</li></ul><p>下面是一个违反迪米特法则的反例。假设有一个电视类，它需要调用遥控器类的turnOn和turnOff方法来控制电视的开关状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RemoteControl remoteControl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TV</span><span class="params">(RemoteControl remoteControl)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.remoteControl = remoteControl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOn</span><span class="params">()</span> &#123;</span><br><span class="line">        remoteControl.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOff</span><span class="params">()</span> &#123;</span><br><span class="line">        remoteControl.turnOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Remote control is turning on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Remote control is turning off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个设计看起来很简单，但是如果在实际应用中，遥控器类还包含其他方法，比如换台、调音量等，而电视类只需要控制开关状态，这时候就违反了迪米特法则。因为电视类并不需要知道遥控器类的所有方法，但是它的构造函数却依赖于遥控器类的实例，这就增加了类之间的耦合度，使得系统更加脆弱和难以维护。</p><p>一个更好的设计是将电视类与遥控器类解耦，电视类只需要定义自己的方法，而遥控器类也只需要定义自己的方法，两者之间通过一个控制器类来进行连接</p><h4 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="3.里氏替换原则"></a>3.里氏替换原则</h4><p><strong>核心思想：</strong>是面向对象设计的一个重要原则，由Barbara Liskov和Jeannette Wing提出。该原则指出，任何基类可以出现的地方，子类一定可以出现，且替换后程序不会出错。</p><p><strong>解析：</strong>里氏替换原则的使用场景包括</p><ul><li>多态场景：在多态场景中，一个方法可以接受基类的实例，但实际上会传入子类的实例，这时就需要保证子类能够替换基类，不影响程序的正确性。</li><li>继承场景：在继承场景中，子类继承了父类的属性和方法，但子类还可以增加自己的属性和方法，这时需要保证子类与父类的替换性，不破坏原有的逻辑。</li><li>接口场景：在接口场景中，一个类实现了一个接口，就需要保证它的子类也能够实现这个接口，保证替换性和扩展性。</li></ul><p>实际的使用案例，如集合框架中，List是一个接口，ArrayList和LinkedList是它的两个实现类。由于它们都实现了List接口，所以在使用List的地方，可以用ArrayList或者LinkedList来代替。这里就保证了子类的替换性。</p><p>在Spring框架的AOP（面向切面编程）中，切面（Aspect）需要实现Advice接口，Spring提供了很多Advice的实现类，例如BeforeAdvice、AfterAdvice、AroundAdvice等等。用户可以根据自己的需要来选择实现哪个Advice接口，然后把它作为切面的一部分来使用，这里也保证了子类的替换性和扩展性。</p><h4 id="4-合成复用原则"><a href="#4-合成复用原则" class="headerlink" title="4.合成复用原则"></a>4.合成复用原则</h4><p><strong>核心思想：</strong>是面向对象设计的一个重要原则，它强调要优先使用对象组合（Composition）和聚合（Aggregation）关系来复用代码，而不是通过继承关系来复用代码。</p><p><strong>解析：</strong>该原则的基本思想是，在设计时要优先考虑对象的<strong>组合关系</strong>，<strong>而不是继承关系</strong>，通过将多个对象组合在一起来实现功能的复用。这种方法比继承更加灵活、可靠，同时也减少了代码的耦合度，提高了代码的可维护性和可扩展性。</p><p>假设有一个汽车类（Car），它有多个组成部分，例如引擎（Engine）、车轮（Wheel）等等。我们可以使用合成复用原则来实现汽车类的设计，将组成部分作为汽车的属性来组合起来，而不是通过继承来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line">    <span class="keyword">private</span> Wheel[] wheels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;</span><br><span class="line">        engine = <span class="keyword">new</span> <span class="title class_">Engine</span>();</span><br><span class="line">        wheels = <span class="keyword">new</span> <span class="title class_">Wheel</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            wheels[i] = <span class="keyword">new</span> <span class="title class_">Wheel</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Wheel wheel : wheels) &#123;</span><br><span class="line">            wheel.rotate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Engine start.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Engine stop.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wheel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Wheel rotate.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-开闭原则"><a href="#5-开闭原则" class="headerlink" title="5.开闭原则"></a>5.开闭原则</h4><p><strong>核心思想：</strong>一个软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着，当需要对一个软件实体进行改动时，应该尽量通过扩展来实现新功能，而不是通过修改已有的代码来实现。</p><p><strong>解析：</strong>开闭原则是java里面经常提到的设计原则，简单来说就是对扩展开放，对修改关闭。当我们需要新增或者修改功能时，尽量使用新的类或方法去实现新功能，而不是在已存在的类上去修改，因为这样会导致系统稳定性变差，并且容易造成功能冗余，新的修改也不确定会不会造成新的问题，降低软件风险。</p><p>策略模式就是符合开闭原则的很好实现，它是一种行为型设计模式，它定义了一系列算法，将每个算法都封装起来，并且使它们之间可以互换。通过使用策略模式，可以在运行时动态地选择算法，而不需要在代码中显式地指定。这样，当需要添加新的算法时，只需要编写新的策略类并且注册到上下文中即可，而不需要修改原有的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> <span class="keyword">implements</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 冒泡排序算法的具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> <span class="keyword">implements</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 快速排序算法的具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SortStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(SortStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        strategy.sort(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-依赖倒置原则"><a href="#6-依赖倒置原则" class="headerlink" title="6..依赖倒置原则"></a>6..依赖倒置原则</h4><p><strong>核心思想：</strong>依赖倒置原则（Dependency Inversion Principle，DIP）是面向对象设计中的一个重要原则，它提倡高层模块不应该依赖低层模块，二者都应该依赖于抽象接口。同时，抽象接口不应该依赖于具体实现，具体实现应该依赖于抽象接口。这个原则可以简单地表述为“依赖于抽象而不是具体实现”。</p><p><strong>解析：</strong>依赖倒置原则核心就在“<strong>依赖于抽象而不是具体实现</strong>”这句话上，依赖于抽象的设计有助于简历松耦合的模块关系，从而使系统更容易扩展、修改和维护。同时，在使用依赖倒置原则的时候，我们可以更容易地进行模块的替换，例如我们可以通过更换实现某个接口的具体类来实现模块的替换，而不需要修改其他模块的代码。</p><p>下面来看一下不使用依赖倒置原则和使用依赖倒置原则来优化的案例，假设我们有一个图形库，其中包括三个类：Circle、Rectangle和Graphics，它们的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a rectangle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graphics</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        circle.draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个图形库中，我们有两个具体的形状类：Circle和Rectangle，它们都有一个draw()方法来绘制它们的形状。我们还有一个Graphics类，它负责绘制图形。</p><p>Graphics类直接依赖于Circle和Rectangle类，因为它在它的方法中创建了一个Circle和Rectangle对象来进行绘制。</p><p>现在，我们将应用依赖倒置原则，通过引入抽象接口来解耦Graphics类和具体形状类之间的依赖关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Darw</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Darw</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a rectangle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graphics</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Draw</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        circle.draw();</span><br><span class="line">    </span><br><span class="line">        <span class="type">Draw</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-单一职责原则"><a href="#7-单一职责原则" class="headerlink" title="7.单一职责原则"></a>7.单一职责原则</h4><p><strong>核心思想：</strong>单一职责原则是一种设计模式，它建议将一个类或者函数的职责限制在一个单一的领域或者任务上。简而言之，一个类或者函数只应该有一个改变的理由。</p><p><strong>解析：</strong>单一职责原则猛一看和接口隔离原则有些相似，下面对比下两种原则的相似与不同之处</p><p>相似之处：</p><ul><li>都是为了提高代码的可维护性、可读性和可扩展性。</li><li>都要求将职责限制在一个单一的领域或者任务上。</li></ul><p>不同之处：</p><ul><li>单一职责原则注重的是职责的单一性，即一个类或者函数只应该有一个职责，而接口隔离原则注重的是接口的独立性，即接口应该只包含客户端所需的方法。</li><li>单一职责原则针对的是<strong>类或者函数</strong>的设计，而接口隔离原则针对的是<strong>接口</strong>的设计。</li><li>单一职责原则更多地<strong>关注代码内部</strong>的组织和设计，而接口隔离原则更多地<strong>关注代码之间</strong>的交互和通信。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRadius</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCircumference</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * Math.PI * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码示例中，<code>Circle</code> 类只有一个职责，即表示一个圆形，提供圆形半径、圆形面积和周长的获取方法。该类的职责是单一的，没有包含其他不相关的逻辑或功能。</p><h4 id="设计原则小结"><a href="#设计原则小结" class="headerlink" title="设计原则小结"></a>设计原则小结</h4><p>通过上面的详解，可以发现这些设计模式原则，核心思想就是为了使得系统实现高内聚、低耦合的状态，尽量减少各模块之间耦合的同时提高系统的可维护性，可扩展性；</p><p>设计模式只是一种思想，并不是说在写代码时要完全符合设计模式原则去做才行，很多情况下我们写出来的代码并不是那么符合设计模式原则，这就是在业务实现上的一种取舍，就像mysql数据库表设计的时候经常会出现一些反范式设计的情况，具体如何去做还要看实际情况。</p><p>设计模式（原则）只是帮助我们将代码写的更加灵活规范，但是过于追求符合设计模式也会导致出现新的问题，比如适配器模式过渡使用，就会导致出现大量类，使得代码可读性变差，类关系也变得更加复杂，系统性能也有可能会被影响，因此设计模式要在实际项目中灵活使用。</p><h3 id="二、设计模式"><a href="#二、设计模式" class="headerlink" title="二、设计模式"></a>二、设计模式</h3><h4 id="1-简单工厂类（不属于23种设计模式之一）"><a href="#1-简单工厂类（不属于23种设计模式之一）" class="headerlink" title="1.简单工厂类（不属于23种设计模式之一）"></a>1.简单工厂类（不属于23种设计模式之一）</h4><p><strong>适用场景：</strong>工厂类负责创建的对象较少</p><blockquote><p>客户端只需要传入工厂类的参数对于如何创建对象的逻辑不需要关心</p></blockquote><p><strong>缺点：</strong>工厂类的职责相对过重，增加新的产品时需要修改工厂类的判断逻辑，违背开闭原则。不易于扩展过于复杂的产品结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">createCar</span><span class="params">(String carType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (carType.equalsIgnoreCase(<span class="string">&quot;Sedan&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SedanCar</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (carType.equalsIgnoreCase(<span class="string">&quot;SUV&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SUVCar</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid car type: &quot;</span> + carType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SedanCar</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Driving a sedan car...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SUVCar</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Driving an SUV car...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2.工厂方法模式"></a>2.工厂方法模式</h4><p><strong>定义：</strong>是指定义一个创建对象的接口，反让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类种进行，属于创建型设计模式。</p><blockquote><p>主要解决扩展问题</p></blockquote><p><strong>缺点：</strong>子类过多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">implements</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging message to file: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsoleLogger</span> <span class="keyword">implements</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging message to console: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    Logger <span class="title function_">createLogger</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLoggerFactory</span> <span class="keyword">implements</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileLogger</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsoleLoggerFactory</span> <span class="keyword">implements</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConsoleLogger</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心思想就是不同的类使用不同的工厂来创建，需要的工厂较多时就会导致出现大量子类</p><h4 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3.抽象工厂模式"></a>3.抽象工厂模式</h4><p><strong>定义：</strong>是指提供一个创建一系列相关或者相互依赖对象的接口，无需指定他们具体的类</p><p><strong>缺点：</strong>规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口，增加了系统的抽象性和理解难度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂接口，定义了创建产品的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    Button <span class="title function_">createButton</span><span class="params">()</span>;</span><br><span class="line">    TextField <span class="title function_">createTextField</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂实现类1，用于创建Windows风格的控件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsTextField</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂实现类2，用于创建Mac风格的控件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacTextField</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品接口，定义了产品的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">click</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品实现类1，用于创建Windows风格的按钮</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">click</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Windows Button Clicked.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品实现类2，用于创建Mac风格的按钮</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">click</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mac Button Clicked.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品接口，定义了产品的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">input</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品实现类1，用于创建Windows风格的文本框</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">input</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Windows TextField Input.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品实现类2，用于创建Mac风格的文本框</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">input</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mac TextField Input.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码，通过传入不同的工厂对象创建不同风格的控件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Windows风格的控件</span></span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowsFactory</span>();</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button1</span> <span class="operator">=</span> factory1.createButton();</span><br><span class="line">        button1.click();</span><br><span class="line">        <span class="type">TextField</span> <span class="variable">textField1</span> <span class="operator">=</span> factory1.createTextField();</span><br><span class="line">        textField1.input();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Mac风格的控件</span></span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MacFactory</span>();</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button2</span> <span class="operator">=</span> factory2.createButton();</span><br><span class="line">        button2.click();</span><br><span class="line">        <span class="type">TextField</span> <span class="variable">textField2</span> <span class="operator">=</span> factory2.createTextField();</span><br><span class="line">        textField2.input();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂和产品实现均需要接口定义，接口内定义了这些抽象接口之间的关系，因此实现这些的工厂和产品也具有接口定义的关系</p><h4 id="4-单例模式"><a href="#4-单例模式" class="headerlink" title="4.单例模式"></a>4.单例模式</h4><p>定义：是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点</p><blockquote><p>隐藏其所有的构造方法</p><p>属于创建者模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缺点:能够被反射破坏----构造器黎明抛异常解决</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyStaticInnerClassSingleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">LazyStaticInnerClassSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(LazyHolder.INSTANCE != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不允许非法访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> LazyStaticInnerClassSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">LazyStaticInnerClassSingleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LazyStaticInnerClassSingleton</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册式单例-枚举-解决反射破坏单例问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingleton</span>&#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Object data;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册式单例-容器-线程不安全型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContainerSingleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">ContainerSingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; ioc = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getInstance</span><span class="params">(String className)</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(!ioc.containsKey(className))&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        instance = Class.forName(className).newInstance();</span><br><span class="line">        ioc.put(className,instance);</span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ioc.get(className);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思考：当前容器方式下，如何解决线程不安全问题？</p></blockquote><blockquote><p>chatGPT版答案：</p><p>这段代码实现了一个容器单例模式，即将对象的创建和管理委托给一个容器来处理，通过类名获取对象的实例，如果容器中没有该实例则创建并存储在容器中，否则直接从容器中获取。不过，这段代码存在以下问题：</p><ol><li>线程不安全：在多线程环境下，存在并发访问和更新 ioc 容器的情况，可能导致数据不一致或者出现线程安全问题。</li><li>可能会导致内存泄漏：容器中存储了对象的实例，如果这些实例没有被及时清理或移除，可能会导致内存泄漏。</li><li>使用反射：在getInstance方法中使用Class.forName(className).newInstance()创建对象，这种方式会带来性能开销，且容易出现异常。建议改用其他创建对象的方式，比如工厂方法模式等。</li><li>只能通过类名获取实例：如果需要传递参数来创建对象，那么就需要修改getInstance方法的实现，这增加了代码的复杂性。</li></ol><p>针对以上问题，可以考虑使用线程安全的容器来存储对象实例，如ConcurrentHashMap；对于内存泄漏问题，可以考虑在适当的时候清理容器中的对象实例；对于反射和只能通过类名获取实例的问题，可以使用工厂方法等方式来创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****线程安全，懒加载的单例****/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContainerSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ContainerSingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ContainerSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getService</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ioc.containsKey(className)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ioc) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ioc.containsKey(className)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        instance = Class.forName(className).newInstance();</span><br><span class="line">                        ioc.put(className, instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            instance = ioc.get(className);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ContainerSingleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContainerSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于序列化和反序列化不一致问题，可以采用如下解决方案：</p><p>单例里面重写readResolve()方法，返回单例对象即可解决序列化单例不一致问题，因为在反序列化时会判断有没有写readResolve()方法，有的话就调用这个方法返回instance</p><h4 id="5-代理模式"><a href="#5-代理模式" class="headerlink" title="5.代理模式"></a>5.代理模式</h4><p><strong>应用场景：</strong>保护目标对象，增强目标对象</p><p><strong>静态代理：</strong>显示声明代理对象，只能代理指定类型对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态代理十分常见，属于硬编码，主要用一个代理对象来增强原来对象的功能</span></span><br><span class="line"><span class="comment">// 接口：定义了用户的行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标对象：实现了接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">implements</span> <span class="title class_">IUserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户保存成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象：也实现了接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">IUserDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理对象执行开始&quot;</span>);</span><br><span class="line">        userDao.save();  <span class="comment">// 调用目标对象的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代理对象执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码：使用代理对象调用目标对象的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IUserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        <span class="type">UserDaoProxy</span> <span class="variable">userDaoProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao);</span><br><span class="line">        userDaoProxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>动态代理：</strong>不论目标是啥，都能进行代理，主要分为jdk和CGLib两种动态代理方式</p><blockquote><p><strong>区别</strong>是，jdk的动态代理需要知道被代理类实现的接口，而cglib能够不需要知道</p><p>CGLib采用继承的方式，覆盖父类的方法</p><p>JDK采用的实现的方式们必须要求代理的目标对象一定要实现一个接口</p><p>思想：都是通过生成字节码，重组成一个新的类</p><p>其中，JDK Proxy对于用户而言，依赖更强，调用也更复杂</p><p>CGLib对于目标则没有任何的要求</p><p>CGLib底层没有用到反射，效率和性能更高</p><p>JDK Proxy生成逻辑较为简单，执行效率要低，每次都要用反射</p></blockquote><p><strong>注意，CGLib不能有fina修饰的方法，这一种方法会被忽略</strong></p><p>Spring种的代理选择原则</p><ul><li>当Bean<strong>有实现接口</strong>时，Spring就会用<strong>JDK</strong>的动态代理</li><li>当Bean没有实现接口时，Spring选择CGLib</li><li>Spring可以通过配置强制使用CGLib，只需要在Spring的配置文件中加入声明</li></ul><p>那么JDK和CGLib到底都是如何实现动态代理的呢？首先看下JDK动态代理实现流程</p><ol><li>定义一个接口和实现该接口的类。</li><li>创建一个 <code>InvocationHandler</code> 对象，并实现 <code>invoke</code> 方法，该方法将在代理对象上调用方法时被调用。</li><li>调用 <code>Proxy.newProxyInstance</code> 方法创建代理对象，并将实现了 <code>InvocationHandler</code> 接口的对象传递给它。</li><li>调用代理对象的方法，代理对象会调用 <code>InvocationHandler.invoke</code> 方法，并将方法名、参数和代理对象传递给它。</li></ol><p>下面是实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyExample</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I&#x27;m a dog.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AnimalInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Object target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AnimalInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.target = target;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Before method &quot;</span> + method.getName());</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">            System.out.println(<span class="string">&quot;After method &quot;</span> + method.getName());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">AnimalInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalInvocationHandler</span>(dog);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">proxy</span> <span class="operator">=</span> (Animal) Proxy.newProxyInstance(</span><br><span class="line">            dog.getClass().getClassLoader(),</span><br><span class="line">            dog.getClass().getInterfaces(),</span><br><span class="line">            handler);</span><br><span class="line">        proxy.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述示例中，我们定义了一个接口 <code>Animal</code> 和一个实现该接口的类 <code>Dog</code>。然后，我们创建了一个实现了 <code>InvocationHandler</code> 接口的类 <code>AnimalInvocationHandler</code>，它可以代理 <code>Animal</code> 接口的任何实现类。</p><p>在 <code>main</code> 方法中，我们首先创建了一个 <code>Dog</code> 实例 <code>dog</code>，然后创建了一个 <code>AnimalInvocationHandler</code> 实例 <code>handler</code>，将 <code>dog</code> 传入构造方法。最后，我们使用 <code>Proxy.newProxyInstance</code> 方法创建了一个 <code>Animal</code> 接口的代理对象 <code>proxy</code>，并将 <code>handler</code> 传入其中。</p><p>当我们调用 <code>proxy.say()</code> 时，<code>AnimalInvocationHandler.invoke</code> 方法会被调用，并在调用 <code>dog.say()</code> 方法前后输出了一些信息，以此实现了代理的效果。</p><p><strong>CGLib实现</strong></p><ol><li>引入 <code>cglib</code> 依赖。</li><li>定义一个类和继承该类的代理类。</li><li>创建一个 <code>MethodInterceptor</code> 对象，并实现 <code>intercept</code> 方法，该方法将在代理对象上调用方法时被调用。</li><li>使用 <code>Enhancer</code> 类创建代理对象，并将实现了 <code>MethodInterceptor</code> 接口的对象传递给它。</li><li>调用代理对象的方法，代理对象会调用 <code>MethodInterceptor.intercept</code> 方法，并将方法名、参数和代理对象传递给它。</li></ol><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，定义一个需要被代理的类 <code>UserDao</code> 和一个代理类 <code>UserDaoProxy</code>。这里 <code>UserDao</code> 类只有一个方法 <code>save()</code>，<code>UserDaoProxy</code> 类是一个代理类，继承自 <code>UserDao</code> 并重写了 <code>save()</code> 方法。在重写的方法中，我们可以添加一些代理逻辑，比如在调用被代理对象的方法之前或之后进行一些额外的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">extends</span> <span class="title class_">UserDao</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(UserDao.class);</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method invocation&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method invocation&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-建造者模式"><a href="#6-建造者模式" class="headerlink" title="6.建造者模式"></a>6.建造者模式</h4><p><strong>定义：</strong>是一个将复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示</p><p><strong>特征：</strong>用户只需指定需要建造的类型就可以获得对象，建造过程及细节不需要了解</p><p>把复杂对象的创建和使用分离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">withFirstName</span><span class="params">(String firstName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">withLastName</span><span class="params">(String lastName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">withAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">withAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123; firstName=&#x27;&quot;</span> + firstName + <span class="string">&quot;&#x27;, lastName=&#x27;&quot;</span> + lastName + <span class="string">&quot;&#x27;, age=&quot;</span> + age + <span class="string">&quot;, address=&#x27;&quot;</span> + address + <span class="string">&quot;&#x27; &#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">                            .withFirstName(<span class="string">&quot;John&quot;</span>)</span><br><span class="line">                            .withLastName(<span class="string">&quot;Doe&quot;</span>)</span><br><span class="line">                            .withAge(<span class="number">30</span>)</span><br><span class="line">                            .withAddress(<span class="string">&quot;123 Main Street&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-原型模式"><a href="#7-原型模式" class="headerlink" title="7.原型模式"></a>7.原型模式</h4><p><strong>定义：</strong>是指原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象</p><p>调用者不需要知道任何创建细节，不调用构造函数</p><blockquote><p>通俗讲法就是如何快速构建对象的方法总结，简单工厂将getter、setter封装到某个方法中</p><p>JDK提供的实现Cloneable接口，实现快速复制</p></blockquote><p><strong>适用场景</strong></p><p>1.类初始化消耗资源较多</p><p>2.new产生的一个对象需要非常繁琐的过程</p><p>3.构造函数比较复杂</p><p>4.循环体中产生大量对象时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypeExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">PrototypeExample</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> PrototypeExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">      <span class="keyword">return</span> (PrototypeExample) <span class="built_in">super</span>.clone();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在客户端代码中使用原型模式来创建新对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">      <span class="type">PrototypeExample</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrototypeExample</span>(<span class="string">&quot;example&quot;</span>);</span><br><span class="line">      <span class="type">PrototypeExample</span> <span class="variable">clone</span> <span class="operator">=</span> prototype.clone();</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">&quot;Original object name: &quot;</span> + prototype.getName());</span><br><span class="line">      System.out.println(<span class="string">&quot;Cloned object name: &quot;</span> + clone.getName());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型模式主要是通过类实现cloneable接口，覆写clone接口来实现拷贝，但是这里默认实现的还是浅拷贝，如果想实现深拷贝，需要手动指明非基本类型的拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数和getter/setter方法省略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">cloned</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.birthday = (Date) <span class="built_in">this</span>.birthday.clone();</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-适配器模式"><a href="#8-适配器模式" class="headerlink" title="8.适配器模式"></a>8.适配器模式</h4><p><strong>定义：</strong>又叫变压器模式，它的功能是将一个类的接口编程客户端所期待的一种接口，从而使原本因接口不匹配而导致无法在一起工作的两个类能够一起工作</p><blockquote><p>属于结构型设计模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LegacyRectangle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> length * width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleAdapter</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LegacyRectangle adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RectangleAdapter</span><span class="params">(LegacyRectangle adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> adaptee.calculateArea();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LegacyRectangle</span> <span class="variable">legacyRectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LegacyRectangle</span>();</span><br><span class="line">        <span class="type">RectangleAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RectangleAdapter</span>(legacyRectangle);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> adapter.getArea();</span><br><span class="line">        System.out.println(<span class="string">&quot;Area of rectangle: &quot;</span> + area);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，我们首先创建了一个LegacyRectangle对象，并将其传递给RectangleAdapter适配器类的构造函数。然后，我们使用适配器对象的getArea()方法来计算长方形面积，并输出结果。</p><h4 id="9-桥接模式"><a href="#9-桥接模式" class="headerlink" title="9.桥接模式"></a>9.桥接模式</h4><p><strong>定义：</strong>是一种结构型设计模式，它将抽象部分与实现部分分离开来，使它们可以独立地变化。桥接模式的核心思想是通过组合的方式，将一个类的实现细节委托给另一个类来完成。</p><p>桥接模式的主要目的是将抽象和实现解耦，使得它们可以独立地变化。抽象部分定义了系统的接口和一些高层次的操作，而实现部分负责具体的实现细节。通过将抽象和实现分离开来，桥接模式使得系统更加灵活，易于扩展和维护。</p><p>假设我们要设计一个绘图程序，它可以绘制不同类型的图形，例如圆形和矩形。我们可以使用桥接模式来将图形的类型（抽象部分）和绘制图形的具体方式（实现部分）分离开来。</p><p>首先，我们定义一个Shape抽象类，它包含一个DrawAPI成员变量，表示绘制图形的实现部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们定义一个DrawAPI接口，表示绘制图形的实现部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> radius)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们定义两个具体实现类，分别实现DrawAPI接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedCircle</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> radius)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing red circle at (&quot;</span> + x + <span class="string">&quot;,&quot;</span> + y + <span class="string">&quot;), radius &quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenRectangle</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> radius)</span> &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span></span><br></pre></td></tr></table></figure><h4 id="10-委派模式"><a href="#10-委派模式" class="headerlink" title="10.委派模式"></a>10.委派模式</h4><p><strong>定义：</strong>又叫委托模式，它的基本作用就是负责任务的调度和任务分配，将任务的分配和执行分离开来，可以看做是一种特殊情况下的静态代理的全权代理。</p><blockquote><p>不属于23种GOF设计模式之一</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskA</span> <span class="keyword">implements</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running Task A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskB</span> <span class="keyword">implements</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running Task B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskDelegator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Task&gt; taskMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TaskDelegator</span><span class="params">()</span> &#123;</span><br><span class="line">        taskMap.put(<span class="string">&quot;TaskA&quot;</span>, <span class="keyword">new</span> <span class="title class_">TaskA</span>());</span><br><span class="line">        taskMap.put(<span class="string">&quot;TaskB&quot;</span>, <span class="keyword">new</span> <span class="title class_">TaskB</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">(String taskName)</span> &#123;</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskMap.get(taskName);</span><br><span class="line">        <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Unknown task: &quot;</span> + taskName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegationPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TaskDelegator</span> <span class="variable">taskDelegator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskDelegator</span>();</span><br><span class="line">        taskDelegator.doTask(<span class="string">&quot;TaskA&quot;</span>);</span><br><span class="line">        taskDelegator.doTask(<span class="string">&quot;TaskB&quot;</span>);</span><br><span class="line">        taskDelegator.doTask(<span class="string">&quot;TaskC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-模版模式"><a href="#11-模版模式" class="headerlink" title="11.模版模式"></a>11.模版模式</h4><p><strong>定义：</strong>是一种行为型设计模式，它定义了一个算法的骨架，将一些步骤延迟到子类中实现，从而使得子类可以改变算法的某些特定步骤，而不改变算法的结构。</p><p><strong>解析：</strong>模版模式是在框架和日常开发之中使用比较多的一种设计模式，适合具有大量重复操作的步骤，将这些重复内容抽离出来放进模版之中，后续的开发只需要继承模版并实现个性化部分即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">startPlay</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">endPlay</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 初始化游戏</span></span><br><span class="line">        initialize();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 抽取出的公共部分方法</span></span><br><span class="line">      doSomething1();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 开始游戏</span></span><br><span class="line">        startPlay();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 抽取出的公共部分方法</span></span><br><span class="line">      doSomething2();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 结束游戏</span></span><br><span class="line">        endPlay();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protect <span class="keyword">void</span> <span class="title function_">doSomething1</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;模版内固定方法1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  protect <span class="keyword">void</span> <span class="title function_">doSomething2</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;模版内固定方法2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cricket</span> <span class="keyword">extends</span> <span class="title class_">Game</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">endPlay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cricket Game Finished!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cricket Game Initialized! Start playing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">startPlay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cricket Game Started. Enjoy the game!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Football</span> <span class="keyword">extends</span> <span class="title class_">Game</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">endPlay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Finished!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Initialized! Start playing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">startPlay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Started. Enjoy the game!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameTemplatePatternDemo</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">Game</span> <span class="variable">game</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cricket</span>();</span><br><span class="line">        game.play();</span><br><span class="line">        System.out.println();</span><br><span class="line"> </span><br><span class="line">        game = <span class="keyword">new</span> <span class="title class_">Football</span>();</span><br><span class="line">        game.play();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-策略模式"><a href="#12-策略模式" class="headerlink" title="12.策略模式"></a>12.策略模式</h4><p><strong>定义：</strong>又叫政策模式，它是将定义的算法家族，分别封装起来，让他们之间可以相互替换，从而让算法的变化不会影响到使用算法的用户。</p><p><strong>可以避免多重的if-else语句</strong>，使用map或者数据库配置</p><blockquote><p>属于行为型模式</p></blockquote><p>以下是一个简单的示例，演示如何使用策略模式计算两个数字的和。该示例包括一个接口<code>Strategy</code>，它定义了一个<code>doOperation</code>方法，以及三个实现类：<code>AddStrategy</code>、<code>SubtractStrategy</code>和<code>MultiplyStrategy</code>，它们分别实现了<code>doOperation</code>方法，用于执行加法、减法和乘法运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义策略接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现加法策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现减法策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubtractStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现乘法策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiplyStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类，负责选择和执行具体策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">executeStrategy</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">AddStrategy</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">SubtractStrategy</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">MultiplyStrategy</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 * 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶之并发编程（一）synchronized关键字</title>
      <link href="/2022/09/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/09/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="并发编程基础篇"><a href="#并发编程基础篇" class="headerlink" title="并发编程基础篇"></a>并发编程基础篇</h2><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><ol><li><strong>QPS</strong>（Queries Per Second）：每秒查询率，指的是一个系统或服务在一秒内能够处理的查询次数。例如，如果一个网站每秒钟能够处理100个请求，那么它的QPS为100。</li><li><strong>TPS</strong>（Transactions Per Second）：每秒事务数，指的是一个系统或服务在一秒内能够完成的事务数。一个事务通常指的是一组相关的操作，例如在数据库中执行一次读写操作。TPS是一个系统的性能指标之一，可以用来衡量系统的稳定性和响应能力。</li><li><strong>CPU</strong>（Central Processing Unit，中央处理器）：CPU是计算机的核心部件，它负责执行计算机指令。在并发编程中，CPU的主要限制是它的计算能力，它能够处理的任务数量受到CPU核心数、频率和指令集等因素的影响。为了充分利用CPU的性能，可以采用多线程、异步编程等方式来并发执行任务。</li><li><strong>内存</strong>（Memory）：内存是计算机中用于存储数据和程序的临时存储器，它的容量和速度对并发编程也有很大的影响。如果程序需要频繁地读写内存，那么内存的带宽和延迟就会成为瓶颈。为了减少内存的使用，可以采用一些优化策略，如对象池、缓存等方式。</li><li><strong>磁盘</strong>（Disk）：磁盘是计算机用于存储数据的永久性存储器，它的容量和速度也会对并发编程造成影响。磁盘的读写速度相对于内存来说较慢，因此频繁地进行磁盘读写会成为程序的瓶颈。为了优化磁盘的使用，可以采用一些策略，如异步I&#x2F;O、缓存、压缩等方式。</li><li><strong>网卡</strong>（Network Interface Card）：网卡是计算机用于连接网络的接口，它的带宽和延迟对网络通信的性能有很大的影响。在并发编程中，网络通信是一种常见的场景，因此优化网络通信的性能非常重要。可以采用一些策略，如连接池、异步I&#x2F;O、压缩等方式来优化网络通信的性能。</li><li><strong>I&#x2F;O</strong>（Input&#x2F;Output）是计算机系统中，用于实现计算机与外部设备交互的操作。在并发编程中，I&#x2F;O操作的限制主要包括磁盘、网络和数据库等方面的性能瓶颈。磁盘的读写速度相对于内存来说较慢，因此频繁进行磁盘读写会成为程序的瓶颈。网络通信的带宽和延迟也会影响I&#x2F;O操作的性能，需要采用一些策略来优化，如使用缓存、压缩、连接池等方式。在使用数据库时，频繁进行数据库的读写操作也会成为系统的瓶颈，需要采用一些策略来优化，如使用数据库连接池、使用索引等。</li></ol><blockquote><p>此外，在并发编程之中，进程和线程的概念是必须熟练掌握的</p></blockquote><ul><li><p>进程是指一个程序的运行实例，它拥有自己的地址空间、文件描述符、环境变量、堆栈等资源，是操作系统进行资源分配和调度的基本单位。</p></li><li><p>线程是进程内的一个执行单元，一个进程可以包含多个线程，线程共享进程的地址空间和资源，但是每个线程都有自己的堆栈和寄存器，可以独立执行。线程的并发性相对于进程更高，可以更好地利用计算机的多核处理器，提高程序的性能。</p></li></ul><p><strong>区别：</strong></p><ol><li>进程是操作系统资源分配的基本单位，线程是进程的执行单元，进程可以包含多个线程。</li><li>进程拥有自己的地址空间、文件描述符、环境变量等资源，而线程共享进程的地址空间和资源。</li><li>进程之间相互独立，线程之间共享进程的资源。</li><li>进程切换需要保存当前进程的状态和上下文，开销较大，线程切换开销较小，切换速度更快。</li><li>进程通信需要使用进程间通信机制，如管道、消息队列、共享内存等，线程之间可以直接共享数据。</li></ol><p>总的来说，进程和线程都是用于实现多任务的机制，但是它们的性质和使用方式不同，应该根据具体情况选择适合的机制来实现多任务。</p><h3 id="二、线程相关"><a href="#二、线程相关" class="headerlink" title="二、线程相关"></a>二、线程相关</h3><h4 id="1-线程生命周期"><a href="#1-线程生命周期" class="headerlink" title="1.线程生命周期"></a>1.线程生命周期</h4><p>线程的生命周期可以被分为五个不同的阶段：创建、就绪、运行、阻塞和终止。</p><ol><li>创建阶段：线程被创建，分配了必要的系统资源，但还未开始运行。</li><li>就绪阶段：线程已经准备好运行，但还未被CPU调度执行。</li><li>运行阶段：CPU选择了一个就绪状态的线程，将其放入运行状态，并执行线程的run()方法。</li><li>阻塞阶段：线程进入了一个阻塞状态，例如等待某个事件发生或者等待输入输出操作完成。</li><li>终止阶段：线程执行完了run()方法或者抛出了一个未被捕获的异常，或者被强制中断，线程将进入终止状态。</li></ol><blockquote><p>需要注意的是，在java代码当中，线程具有六个状态，和线程生命周期并不完全匹配</p><p>NEW 新建,RUNNABLE 就绪,BLOCKED 阻塞,WAITING 等待,TIMED_WAITING 时间等待,TERMINATED 终止</p></blockquote><p>不同状态之间的转换可以由以下事件触发：</p><ol><li>创建状态转换为就绪状态：当线程被创建并分配了系统资源之后，它就进入了就绪状态。这个状态转换是自动发生的。</li><li>就绪状态转换为运行状态：当线程被操作系统的调度器选择并分配了CPU资源后，线程进入运行状态。</li><li>运行状态转换为阻塞状态：当线程在执行过程中遇到了阻塞事件（如等待输入&#x2F;输出操作完成、等待某个锁等待等），线程会被挂起，进入阻塞状态。</li><li>阻塞状态转换为就绪状态：当线程被阻塞的原因消除后（如输入&#x2F;输出操作完成或某个锁被释放），线程就会转换为就绪状态，等待操作系统调度器重新分配CPU资源。</li><li>运行状态转换为终止状态：当线程执行完了run()方法或抛出了未被捕获的异常或被强制中断时，线程就会进入终止状态。</li></ol><h4 id="2-实现线程的方法"><a href="#2-实现线程的方法" class="headerlink" title="2.实现线程的方法"></a>2.实现线程的方法</h4><p>1.继承Thread类</p><p>2.实现Runnable接口</p><p>3.实现Callable接口</p><p>4.使用线程池ThreadPoolExecutor</p><h4 id="3-线程中断"><a href="#3-线程中断" class="headerlink" title="3.线程中断"></a>3.线程中断</h4><blockquote><p>线程可以使用stop()来中断，但是这种方法会不论当前线程状态直接将线程中断掉，容易造成未知影响，已经逐渐废弃</p></blockquote><p>更普遍的，可以使用interrupt()方法来中断线程，相当于给正在运行的线程发送了一个信号，通知线程可以中断了，可以用isInterrupted()方法来判断是否启用了线程中断，如果处于中断命令状态，用户可以执行相应操作</p><p>需要注意的是，如果线程内run使用类似如下语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!Thread.currentThread.isInterrupted())&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下在线程外调用interrupt()方法是可以将线程正常中断掉的，而这种状态下的中断其实和使用volatile声明一个共享变量来做线程通信的原理是相似的</p><p><code>interrupt()</code>方法并不会直接中断一个正在运行状态的线程，而是将中断标志位设置为<strong>true</strong>，在线程内可以通过对中断标志位的判断，来决定何时中断当前线程，此外，<code>interrupt()</code>方法对不同状态的线程影响不同：</p><ol><li>如果线程处于运行状态，那么中断标志位将被设置为<code>true</code>，但线程并不会立即停止执行，而是可以通过对中断标志位的检查来决定是否停止执行。</li><li>如果线程处于阻塞状态，那么调用<code>interrupt()</code>方法会立即抛出<code>InterruptedException</code>异常，这样可以提前结束线程的阻塞状态并抛出异常，从而使线程退出阻塞状态继续执行。</li><li>如果线程处于等待状态，例如调用了<code>Object.wait()</code>方法或<code>Thread.join()</code>方法等待其他线程的通知或执行完成，那么调用<code>interrupt()</code>方法也会立即抛出<code>InterruptedException</code>异常，从而使线程退出等待状态继续执行。</li><li>如果线程处于新建状态或者已经终止，那么调用<code>interrupt()</code>方法不会有任何效果，中断标志位会被设置为<code>true</code>，但线程并不会中断执行。</li></ol><blockquote><p>需要注意的是，抛出<code>InterruptedException</code>异常之后，运行线程会将中断标志位重新置为<code>false</code>，即退出了中断状态，为什么这样设计呢？</p><p>这种设计主要是为了线程安全性考虑，当某个线程中断标志位设置为<code>true</code>之后，如果其他线程来获取这个线程状态，会获得<code>true</code>结果，但是这个线程其实并不是在中断标志位被设置为<code>true</code>后就立即进入中断状态了，它可能还会有一些自己的处理，因此需要将中断标志位重置。同时，这也是将中断交给用户来处理的一个操作，使得用户可以更加灵活的处理中断情况，而如果用户想真的中断这个线程时，可以在run内部调用<code>Thread.currentThread().interrupt()</code>来实现线程真正的中断。</p></blockquote><p>如下所示，就是一个调用<code>interrupt()</code>后能抛出<code>InterruptedException</code>异常的run内写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!Thread.currentThread.isInterrupted())&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(InterruptException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-cpu飙升问题排查"><a href="#4-cpu飙升问题排查" class="headerlink" title="4.cpu飙升问题排查"></a>4.cpu飙升问题排查</h4><p>当CPU飙升时，可能是因为某个进程或线程在消耗大量的CPU资源，导致CPU使用率过高。要解决这个问题，可以通过以下步骤进行排查：</p><ol><li>查看系统负载：可以通过命令<code>top</code>或<code>htop</code>来查看系统的负载情况，包括CPU使用率、内存使用率、进程数量等信息。如果CPU使用率很高，可以查看哪些进程或线程占用了大量的CPU资源。</li><li>查看进程信息：可以通过命令<code>ps</code>或<code>pidstat</code>来查看进程的详细信息，包括进程ID、CPU使用率、内存使用率、线程数量等信息。可以根据进程ID定位到具体的进程，并查看其线程的详细信息。<strong>（top命令看进程信息，找到占用cpu过高的进程）</strong></li><li>分析线程堆栈信息：可以通过工具如jstack、jvisualvm等来获取线程堆栈信息，从而了解线程的执行情况。通过分析线程堆栈信息，可以确定哪些线程占用了大量的CPU资源，并查找问题所在。<strong>（jstack查看线程信息，找到占用cpu过高的线程）</strong></li><li>分析代码：根据线程堆栈信息，可以定位到具体的代码位置，进一步分析代码的执行情况。如果是某个代码块或方法导致CPU使用率过高，可以考虑对其进行优化或改进。<strong>（根据dump文件，使用jmap分析是否有死锁，内存泄漏等问题，定位到对应代码块）</strong></li><li>调整系统参数：如果以上步骤都无法解决问题，可以考虑调整系统参数，例如增加CPU数量、增加内存容量、调整线程池大小等，以提高系统性能。</li></ol><p>需要注意的是，CPU飙升问题可能有多种原因，可能是代码问题，也可能是系统配置问题。在排查问题时，需要综合考虑各种因素，并根据具体情况采取相应的措施。</p><blockquote><p>注意，死锁不一定会导致CPU飙升</p><p>首先分析会导致CPU飙升的死锁，这种情况就是多个进程存在死锁，然后不断重试去尝试获取资源，从而导致占用大量CPU资源，导致CPU使用率飙升</p><p>那么不会使CPU飙升的死锁是什么样的呢？考虑以下场景</p><ul><li>进程A获取了锁1，正在等待锁2</li><li>进程B获取了锁2，正在等待锁1</li></ul><p>在这种情况下，A和B进程都进入了阻塞状态，这种状态是不会对CPU资源进行占用的，但是这种死锁不释放也会对资源进行占用，需要及时发现并处理。</p></blockquote><h3 id="三、并发编程之同步锁"><a href="#三、并发编程之同步锁" class="headerlink" title="三、并发编程之同步锁"></a>三、并发编程之同步锁</h3><h4 id="1-synchronized关键字"><a href="#1-synchronized关键字" class="headerlink" title="1.synchronized关键字"></a>1.synchronized关键字</h4><p>synchronized关键字只能作用于<strong>代码块</strong>或者<strong>方法</strong>，并不能直接作用于变量，但是可以声明一个对象放在sychronized锁住代码块的小括号里，作为共享对象进行并发控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时引出了另一个问题，sychronized关键字都可以怎么使用？不同方法锁住的都是什么？</p><ul><li>锁在普通方法上：这种情况下，sychronized锁住的就是当前实例对象本身，也就是this</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>锁在静态方法上：这种情况下，锁对象通常是类对象，也就是说，锁住的是当前类对象的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>锁在代码块上：这种情况下，锁对象可以是任何的Java对象，通常是使用一个专门声明的私有final对象，防止其他对象意外使用该对象导致竞争发生</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，锁的也可以是ClassName.class形式的对象，表示对这个类加了锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (ClassName.class) &#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么叫对类进行加锁呢？</p><p>在JVM当中，每个类在其中都有一个对应的Class对象，这个Class对象是全局唯一的，因此当使用synchronized关键字对类进行加锁时，类所有实例对象的静态变量和静态方法也都是被锁住的，但是对于这个类的实例来说，非静态方法与变量是可以被其他线程正常访问的；所以类锁其实只会锁住一个类的静态方法与静态变量；</p><p>类锁控制的资源范围更大，锁的粒度也更大，可以保证多线程条件下类的静态资源的并发安全性，经典的用例便是单例模式的双重校验锁中对单例类的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// private constructor</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了一个 <code>volatile</code> 关键字来保证在多线程环境下，instance 变量的可见性和有序性，为什么要使用它呢？</p><p>如果没有使用 volatile 关键字，可能会出现以下问题：</p><ol><li>线程 A 进入双重校验锁，执行第一个步骤，此时实例还未被创建，然后线程 B 也进入双重校验锁。</li><li>线程 B 获取到锁，执行第一个步骤，此时实例还未被创建，然后线程 A 获取到锁，执行第二个步骤，创建实例。</li><li>线程 B 继续执行第二个步骤，创建另一个实例，并返回。</li></ol><p>因为指令重排序的原因，线程 B 可能会在实例还未被创建的时候获取到锁，并返回一个未完成初始化的实例。如果其他线程使用这个实例，可能会导致程序出错。</p><blockquote><p>双重校验锁实现的单例并不完美，具体问题与优化可以参考<a href="https://yzj.life/2023/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Java进阶之设计模式</a>中的单例模式介绍</p></blockquote><h4 id="2-抢占锁的本质是什么"><a href="#2-抢占锁的本质是什么" class="headerlink" title="2.抢占锁的本质是什么"></a>2.抢占锁的本质是什么</h4><p>抢占锁是指多个线程竞争同一把锁时，其中一个线程成功获得了锁并持有锁的情况下，其他线程将被阻塞，无法进入临界区进行操作，只有等到锁被释放后才能继续竞争锁并进入临界区。</p><p>抢占锁的本质是通过锁来保证多个线程对共享资源的访问是互斥的，从而保证了线程安全。当一个线程获取锁时，它会进入临界区，执行相关操作，直到完成后才会释放锁。其他线程在没有获得锁之前，无法进入临界区，从而避免了多个线程同时对共享资源进行修改而导致的数据不一致问题。</p><h4 id="3-MarkWord对象头"><a href="#3-MarkWord对象头" class="headerlink" title="3.MarkWord对象头"></a>3.MarkWord对象头</h4><p>在Java对象头中，用于表示锁状态的部分称为mark word（标记字段）。mark word通常包含了三种信息：</p><ul><li>对象的hashCode值</li><li>对象的分代年龄</li><li>锁状态</li></ul><p>其中，锁状态一般使用2bit位来表示，但是在无锁或者偏向锁时，会用3bit位来表示锁状态</p><ul><li>0 01表示无锁状态</li><li>1 01表示是偏向锁状态</li><li>00表示是轻量级锁状态</li><li>10表示是重量级锁状态</li><li>11则是用到的GC标志</li></ul><p>mark word的指针并不是一直不变的，在不同的锁状态下指向不同的对象，用于实现不同需求</p><ul><li>在偏向锁状态下，mark word的指针指向线程ID，用于记录哪个线程拥有该对象。</li><li>在轻量级锁状态下，mark word的指针指向锁记录的地址，锁记录用于存储锁定对象的线程ID和锁的状态信息。</li><li>在重量级锁状态下，mark word的指针指向重量级锁的互斥量。</li></ul><p>下面分别介绍这几种锁</p><blockquote><p>在jdk6之后才对sychronized进行了细化区分，在5和之前都是用的重量级锁</p></blockquote><p><strong>1.偏向锁</strong></p><p>偏向锁的核心思想是，如果一个线程获得了对象的锁，那么在之后的执行中，该线程就可以直接进入临界区，而不用再次获取锁了。偏向锁可以消除大量的同步操作，因为大部分情况下，锁总是由同一个线程多次获得的。如果加入了偏向锁，当这个线程再次进入临界区时，就不用再去尝试获取锁，因为锁已经被偏向该线程了。</p><blockquote><p>注意，并不是说一个线程拿到某一对象置为偏向锁后，这个对象的偏向锁就只能是该线程了，偏向锁存在一个偏向锁撤销的可能，偏向锁撤销可能会升级成轻量级锁，也可能重新变成无锁状态，由以下状态情况触发回到无锁状态</p><ul><li>使用-XX:BiasedLockingStartupDelay参数设置了偏向锁持有时间，到达时间后偏向锁会被撤销</li><li>在并发标记过程中，遇到了安全点，会暂停所有线程，并且把对象头中的偏向锁撤销</li></ul><p>其他一些情况不再细谈，撤销偏向锁其实是一个比较耗费资源的操作，所以有时候jvm会直接把对象设置为“不可偏向”状态，此时再有线程过来尝试获取锁直接升级为轻量级锁</p></blockquote><p><strong>2.轻量级锁</strong></p><p>当一个线程尝试获取一个有偏向锁的对象时，如果这个对象的偏向锁标识符与线程的标识符不同，说明有另一个线程已经竞争这个锁了，那么就会将偏向锁升级为轻量级锁，并使用CAS操作来竞争锁。所以，一般情况下，偏向锁升级为轻量级锁是在第二个线程尝试获取锁时发生的。</p><p>轻量级锁适合使用在有<strong>多个线程在不同时刻</strong>轮流获取锁的情况，如果竞争较为激烈，重量级锁的性能表现会更好</p><p>轻量级锁采用CAS机制来尝试获取锁，如果获取锁失败则会自旋尝试再次获取锁，默认会在10次获取失败后升级成重量级锁，但是这个参数可用通过JVM参数控制</p><p><strong>3.重量级锁</strong></p><p><code>synchronized</code> 的重量级锁是指当竞争激烈时，锁会升级为重量级锁（也叫监视器锁）。在重量级锁的实现中，会使用操作系统的<strong>互斥量</strong>来实现锁，因此在争用同步资源时会发生<strong>内核态与用户态</strong>之间的切换，这种切换的代价比较高，因此重量级锁在性能方面比较差，适合用于保护竞争激烈的共享资源。</p><p>那么操作系统的互斥量是指的什么呢？重量级锁又是如何实现的呢？</p><p>简单来说，Java虚拟机通过对对象的监视器（<code>monitor</code>）进行操作，来达到对对象的加锁和解锁目的</p><p><code>monitorenter</code> 和 <code>monitorexit</code> 是 Java 虚拟机的两条指令，当 JVM 执行 <code>monitorenter</code> 指令时，会先判断对象的 <code>monitor</code> 是否处于无锁状态，如果是，就将 <code>monitor</code> 设置为当前线程持有，并将锁的计数器加1。如果 monitor 已经被当前线程持有，就直接将计数器加1即可，这样可以重入锁。如果 <code>monitor</code> 已经被其他线程持有，则当前线程就会进入阻塞状态，直到 <code>monitor</code> 变为可用。</p><p>当 JVM 执行 <code>monitorexit</code> 指令时，会先判断当前线程是否持有 <code>monitor</code>，如果是，就将 <code>monitor</code> 的计数器减1。如果计数器减为0，说明该线程已经释放了 <code>monitor</code>，可以将 <code>monitor</code> 设置为无锁状态，并唤醒等待在 <code>monitor</code> 上的其他线程。</p><blockquote><p>本质上就是JVM通过对<code>monitor</code>的状态进行操作，来进行加锁和解锁，那么更进一步了解，<code>monitor</code>又是如何实现的呢？</p><p><code>monitor</code> 是一种同步原语，用于实现互斥锁等同步操作。<code>monitor</code> 可以看作是一种抽象的概念，实际上是通过操作系统的互斥量（mutex）来实现的。</p><p><strong>mutex enter</strong>和<strong>mutex exit</strong>就是操作系统中用于实现互斥量的原语。</p></blockquote><h3 id="四、CAS机制"><a href="#四、CAS机制" class="headerlink" title="四、CAS机制"></a>四、CAS机制</h3><p><strong>1.简介</strong></p><p>CAS（Compare And Swap）是一种基于原子性操作的并发编程技术，主要用于多线程环境下的共享变量的操作，可以保证线程安全。</p><p>在CAS操作中，主要包含三个参数：内存地址V、旧的预期值A和新的值B。操作步骤如下：</p><ol><li>读取V的当前值，记为A。</li><li>判断A是否等于预期值，如果相等，则执行步骤3，否则不执行。</li><li>将V的值设置为新值B，如果操作成功，则返回true，否则返回false。</li></ol><p>CAS操作通过比较内存地址V中的旧值A与预期值是否相等来判断是否执行更新操作，如果相等，则将新值B写入到内存地址V中，如果不相等，则不执行更新操作。在更新操作期间，如果其他线程修改了内存地址V中的值，那么CAS操作会失败，需要重新尝试执行CAS操作。</p><p>在java中使用<code>unsafe.compareAndSwapXXX</code>方法来实现cas操作，传递四个值，两个是用来对内存地址定位，相当于内存地址V</p><p><strong>2.ABA问题</strong></p><p>CAS操作存在ABA问题，即如果一个值由A变为B，又变回A，那么CAS操作就可能认为这个值没有变化，从而可能产生问题。为了解决ABA问题，Java提供了AtomicStampedReference类和AtomicMarkableReference类。</p><blockquote><p>AtomicStampedReference使用一个整数类型的stamp（可以理解为版本号）来记录对象被修改的次数。在执行CAS操作时，除了比较对象是否相同，还需要比较版本号是否相同，从而确保不会出现ABA问题。</p><p>AtomicMarkableReference则是使用一个boolean类型的标记位来记录对象是否被修改过。在执行CAS操作时，除了比较对象是否相同，还需要比较标记位是否相同，从而确保不会出现ABA问题。</p></blockquote><p><strong>3.CAS如何实现并发安全</strong></p><p>在单CPU情况下，CAS利用来硬件的原子性指令，将比较与交换同时完成，因此可以保证执行的原子性，从而保证了并发安全</p><p>在多CPU的情况下，单个CPU的原子性指令并不能保证夸CPU实现原子性，因此在多CPU的情况下，底层实际上是加了一个LOCK锁，可以称为缓存锁或总线锁，因此本质还是使用锁来保证的原子性</p><p>关于总线锁，后面会再展开篇幅进行介绍</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatisPlus之条件构造器</title>
      <link href="/2022/08/24/%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8/"/>
      <url>/2022/08/24/%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><blockquote><p>说明：</p><p>条件构造器构造条件时，一般支持两到三个入参，使用以下两个入参情况较多（R column, Object val）；第一个参数是一个 boolean 类型，默认为 true，表示加入到最后构造的 sql 当中；因此在构造条件时，可以将判断加在外面，也可以写在第一个参数处</p></blockquote><h2 id="二、Wrapper"><a href="#二、Wrapper" class="headerlink" title="二、Wrapper"></a>二、Wrapper</h2><h3 id="AbstractWrapper"><a href="#AbstractWrapper" class="headerlink" title="AbstractWrapper"></a>AbstractWrapper</h3><blockquote><p>说明:</p><p>QueryWrapper (LambdaQueryWrapper) 和 UpdateWrapper (LambdaUpdateWrapper) 的父类用于生成 sql 的 where 条件，entity 属性也用于生成 sql 的 where 条件<br>注意: entity 生成的 where 条件与 使用各个 api 生成的 where 条件<strong>没有任何关联行为</strong></p></blockquote><p>作为父类，AbstractWrapper 包含了大量构造条件所用方法</p><p>常用方法不再赘述，具体参考 MyBatis-Plus 官网：<a href="https://baomidou.com/pages/10c804/#alleq:~:text=%23-,AbstractWrapper,-%E8%AF%B4%E6%98%8E%3A">条件构造器 - AbstractWrapper</a></p><p>需要稍微注意的是以下几个方法</p><h4 id="inSql"><a href="#inSql" class="headerlink" title="inSql"></a>inSql</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inSql(R column, String inValue)</span><br></pre></td></tr></table></figure><p>其中，inValue 代表 sql 语句，即开发者可以直接将 sql 语句作为参数传递进来，作为查询条件构造</p><ul><li>字段 IN (sql 语句)</li><li>例: <code>inSql(&quot;age&quot;, &quot;1,2,3,4,5,6&quot;)</code>—&gt;<code>age in (1,2,3,4,5,6)</code></li><li>例: <code>inSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)</code>—&gt;<code>id in (select id from table where id &lt; 3)</code></li></ul><h4 id="having"><a href="#having" class="headerlink" title="having"></a>having</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">having(String sqlHaving, Object... params)</span><br><span class="line">having(<span class="type">boolean</span> condition, String sqlHaving, Object... params)</span><br></pre></td></tr></table></figure><ul><li>HAVING (sql 语句)</li><li>例: <code>having(&quot;sum(age) &gt; 10&quot;)</code>—&gt;<code>having sum(age) &gt; 10</code></li><li>例: <code>having(&quot;sum(age) &gt; &#123;0&#125;&quot;, 11)</code>—&gt;<code>having sum(age) &gt; 11</code></li></ul><h4 id="func"><a href="#func" class="headerlink" title="func"></a>func</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(Consumer&lt;Children&gt; consumer)</span><br><span class="line">func(<span class="type">boolean</span> condition, Consumer&lt;Children&gt; consumer)</span><br></pre></td></tr></table></figure><ul><li>func 方法 (主要方便在出现 if…else 下调用不同方法能不断链)</li><li>例: <code>func(i -&gt; if(true) &#123;i.eq(&quot;id&quot;, 1)&#125; else &#123;i.ne(&quot;id&quot;, 1)&#125;)</code></li></ul><h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">or()</span><br><span class="line">or(<span class="type">boolean</span> condition)</span><br></pre></td></tr></table></figure><ul><li><p>拼接 OR</p><p>注意事项:</p><p>主动调用 <code>or</code> 表示紧接着下一个<strong>方法</strong>不是用 <code>and</code> 连接！(不调用 <code>or</code> 则默认为使用 <code>and</code> 连接)</p></li><li><p>例: <code>eq(&quot;id&quot;,1).or().eq(&quot;name&quot;,&quot;老王&quot;)</code>—&gt;<code>id = 1 or name = &#39;老王&#39;</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">or(Consumer&lt;Param&gt; consumer)</span><br><span class="line">or(<span class="type">boolean</span> condition, Consumer&lt;Param&gt; consumer)</span><br></pre></td></tr></table></figure><ul><li>OR 嵌套</li><li>例: <code>or(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))</code>—&gt;<code>or (name = &#39;李白&#39; and status &lt;&gt; &#39;活着&#39;)</code></li></ul><h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and(Consumer&lt;Param&gt; consumer)</span><br><span class="line">and(<span class="type">boolean</span> condition, Consumer&lt;Param&gt; consumer)</span><br></pre></td></tr></table></figure><ul><li>AND 嵌套</li><li>例: <code>and(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))</code>—&gt;<code>and (name = &#39;李白&#39; and status &lt;&gt; &#39;活着&#39;)</code></li></ul><h3 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h3><blockquote><p>说明:</p><p>继承自 AbstractWrapper , 自身的内部属性 entity 也用于生成 where 条件<br>及 LambdaQueryWrapper, 可以通过 new QueryWrapper ().lambda () 方法获取</p></blockquote><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select(String... sqlSelect)</span><br><span class="line">select(Predicate&lt;TableFieldInfo&gt; predicate)</span><br><span class="line">select(Class&lt;T&gt; entityClass, Predicate&lt;TableFieldInfo&gt; predicate)</span><br></pre></td></tr></table></figure><ul><li><p>设置查询字段</p><blockquote><p>说明:</p><p>以上方法分为两类.<br>第二类方法为：过滤查询字段 (主键除外), 入参不包含 class 的调用前需要 <code>wrapper</code> 内的 <code>entity</code> 属性有值！这两类方法重复调用以最后一次为准</p></blockquote></li><li><p>例: <code>select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;)</code></p></li><li><p>例: <code>select(i -&gt; i.getProperty().startsWith(&quot;test&quot;))</code></p></li></ul><p>在构造 Wrapper 时，使用 select 可以减少无用字段的查询</p><h3 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a>UpdateWrapper</h3><blockquote><p>说明:</p><p>继承自 <code>AbstractWrapper</code> , 自身的内部属性 <code>entity</code> 也用于生成 where 条件<br>及 <code>LambdaUpdateWrapper</code>, 可以通过 <code>new UpdateWrapper().lambda()</code> 方法获取！</p></blockquote><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(String column, Object val)</span><br><span class="line">set(<span class="type">boolean</span> condition, String column, Object val)</span><br></pre></td></tr></table></figure><ul><li>SQL SET 字段</li><li>例: <code>set(&quot;name&quot;, &quot;老李头&quot;)</code></li><li>例: <code>set(&quot;name&quot;, &quot;&quot;)</code>—&gt; 数据库字段值变为<strong>空字符串</strong></li><li>例: <code>set(&quot;name&quot;, null)</code>—&gt; 数据库字段值变为 <code>null</code></li></ul><h4 id="setSql"><a href="#setSql" class="headerlink" title="setSql"></a>setSql</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setSql(String sql)</span><br></pre></td></tr></table></figure><ul><li>设置 SET 部分 SQL</li><li>例: <code>setSql(&quot;name = &#39;老李头&#39;&quot;)</code></li></ul><h4 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h4><ul><li>获取 <code>LambdaWrapper</code><br>在 <code>QueryWrapper</code> 中是获取 <code>LambdaQueryWrapper</code><br>在 <code>UpdateWrapper</code> 中是获取 <code>LambdaUpdateWrapper</code></li></ul><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>上面介绍的都是常规用法，MyBatis-Plus 还支持一些更为简洁的书写方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">LambdaUpdateChainWrapper</span>&lt;&gt;(testMapper)</span><br><span class="line">        .eq(TestEntity::getIsDelete,<span class="number">0</span>)</span><br><span class="line">        .eq(TestEntity::getName,<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">        .eq(TestEntity::getAge,<span class="number">18</span>)</span><br><span class="line">        .set(TestEntity::getAge,<span class="number">20</span>)</span><br><span class="line">        .set(TestEntity::getUpdateTime,<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">        .update();</span><br></pre></td></tr></table></figure><p>这种方法能够直接按照条件查询并更新数据库</p><blockquote><p>此外，需要注意 @TableField (exist &#x3D; false) 注解，加了这个注解的参数不会再往数据库写入，同样无法作为条件参数进行查询</p></blockquote><h3 id="使用-Wrapper-自定义-SQL"><a href="#使用-Wrapper-自定义-SQL" class="headerlink" title="使用 Wrapper 自定义 SQL"></a>使用 Wrapper 自定义 SQL</h3><blockquote><p>注意事项:</p><p>需要 <code>mybatis-plus</code> 版本 &gt;&#x3D; <code>3.0.7</code> param 参数名要么叫 <code>ew</code>, 要么加上注解 <code>@Param(Constants.WRAPPER)</code> 使用 <code>$&#123;ew.customSqlSegment&#125;</code> 不支持 <code>Wrapper</code> 内的 entity 生成 where 语句</p></blockquote><h4 id="用注解"><a href="#用注解" class="headerlink" title="用注解"></a>用注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from mysql_data $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">List&lt;MysqlData&gt; <span class="title function_">getAll</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper wrapper)</span>;</span><br></pre></td></tr></table></figure><h4 id="用-XML"><a href="#用-XML" class="headerlink" title="用 XML"></a>用 XML</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;MysqlData&gt; <span class="title function_">getAll</span><span class="params">(Wrapper ew)</span>;</span><br><span class="line">XML</span><br><span class="line">&lt;select id=<span class="string">&quot;getAll&quot;</span> resultType=<span class="string">&quot;MysqlData&quot;</span>&gt;</span><br><span class="line">SELECT * FROM mysql_data $&#123;ew.customSqlSegment&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>该方法可以将 sql 与使用 Wrapper 构造的查询条件进行拼接，在业务比较复杂，使用 wrapper 又无法满足需求的时候，拼接可以减少不必要的重写 sql 工作</p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis-Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>下面是自己实现的不同排序算法，仅做随时复习观看用</p><h3 id="一、排序算法比较"><a href="#一、排序算法比较" class="headerlink" title="一、排序算法比较"></a>一、排序算法比较</h3><table><thead><tr><th>排序算法</th><th>时间复杂度（平均）</th><th>时间复杂度（最坏）</th><th>时间复杂度（最好）</th><th>空间复杂度</th><th>稳定性</th><th>复杂性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(N2)</td><td>O(N2)</td><td>O(N)</td><td>O(1)</td><td>稳定</td><td>简单</td></tr><tr><td>选择排序</td><td>O(N2)</td><td>O(N2)</td><td>O(N2)</td><td>O(1)</td><td>不稳定</td><td>简单</td></tr><tr><td>插入排序</td><td>O(N2)</td><td>O(N2)</td><td>O(N)</td><td>O(1)</td><td>稳定</td><td>简单</td></tr><tr><td>希尔排序</td><td>O(N1.3)</td><td>O(n(logN)^2)</td><td>O(N)</td><td>O(1)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>归并排序</td><td>O(NlogN)</td><td>O(NlogN)</td><td>O(NlogN)</td><td>O(N)</td><td>稳定</td><td>较复杂</td></tr><tr><td>快速排序</td><td>O(NlogN)</td><td>O(N2)</td><td>O(NlogN)</td><td>O(logN)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>堆排序</td><td>O(NlogN)</td><td>O(NlogN)</td><td>O(NlogN)</td><td>O(1)</td><td>不稳定</td><td>较复杂</td></tr></tbody></table><h3 id="二、算法实现"><a href="#二、算法实现" class="headerlink" title="二、算法实现"></a>二、算法实现</h3><h4 id="1-前置方法，用于交换"><a href="#1-前置方法，用于交换" class="headerlink" title="1.前置方法，用于交换"></a>1.前置方法，用于交换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> j, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2.冒泡排序"></a>2.冒泡排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="comment">// 依次比较两个数大小，每次确定末尾一个数是多少</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;bubbleSort:&quot;</span>+Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="comment">// 每次找到最大的值是多少，然后按顺序插入</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[temp])&#123;</span><br><span class="line">                temp = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,temp,i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;selectSort:&quot;</span>+Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4.插入排序"></a>4.插入排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="comment">// 每次找到排序的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; arr[i] &lt; arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">            swap(arr,i,i-<span class="number">1</span>);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;insertSort:&quot;</span>+Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5.希尔排序"></a>5.希尔排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="comment">// 增量缩小+插入排序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(gap != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i - gap &gt;= <span class="number">0</span> &amp;&amp; arr[i] &lt; arr[i-gap])&#123;</span><br><span class="line">                swap(arr,i,i-gap);</span><br><span class="line">                i -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;shellSort:&quot;</span>+Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6.归并排序"></a>6.归并排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> len / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[] left = Arrays.copyOfRange(arr,<span class="number">0</span>,mid);</span><br><span class="line">    <span class="type">int</span>[] right = Arrays.copyOfRange(arr,mid,len);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left),mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] merge(<span class="type">int</span>[] left, <span class="type">int</span>[] right) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lLen</span> <span class="operator">=</span> left.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rLen</span> <span class="operator">=</span> right.length;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[lLen+rLen];</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; lLen &amp;&amp; q &lt; rLen) &#123;</span><br><span class="line">        <span class="keyword">if</span>(left[p] &lt; right[q])&#123;</span><br><span class="line">            arr[i++] = left[p++];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            arr[i++] = right[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; lLen) arr[i++] = left[p++];</span><br><span class="line">    <span class="keyword">while</span> (q &lt; rLen) arr[i++] = right[q++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7.快速排序"></a>7.快速排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fastSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (end &lt;= start) <span class="keyword">return</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr,start,end);</span><br><span class="line">      fastSort(arr,start,pivot-<span class="number">1</span>);</span><br><span class="line">      fastSort(arr,pivot+<span class="number">1</span>,end);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">      <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">      <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> random.nextInt(end-start)+start;</span><br><span class="line">      swap(arr,start,p);</span><br><span class="line">      <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">      <span class="keyword">while</span> (start &lt; end)&#123;</span><br><span class="line">          <span class="keyword">while</span> (start &lt; end &amp;&amp; arr[end] &gt;= temp) end--;</span><br><span class="line">          arr[start] = arr[end];</span><br><span class="line">          <span class="keyword">while</span> (start &lt; end &amp;&amp; arr[start] &lt; temp) start++;</span><br><span class="line">          arr[end] = arr[start];</span><br><span class="line">      &#125;</span><br><span class="line">      arr[start] = temp;</span><br><span class="line">      <span class="keyword">return</span> start;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-堆排序"><a href="#8-堆排序" class="headerlink" title="8.堆排序"></a>8.堆排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">      <span class="comment">// 建堆 大根堆</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">          heapInsert(arr,i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调整，排序</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> len;</span><br><span class="line">      <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">          swap(arr,<span class="number">0</span>,heapSize-<span class="number">1</span>);</span><br><span class="line">          heapify(arr,heapSize-<span class="number">1</span>);</span><br><span class="line">          heapSize--;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;heapSort:&quot;</span>+Arrays.toString(arr));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调整0——heapSize-1</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (p &lt; heapSize)&#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> p * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">          <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (left &gt;= heapSize) <span class="keyword">return</span>;</span><br><span class="line">          <span class="keyword">if</span>(right &lt; heapSize &amp;&amp; arr[right] &gt; arr[left]) left = right;</span><br><span class="line">          <span class="keyword">if</span>(arr[left] &gt; arr[p]) &#123;</span><br><span class="line">              swap(arr,p,left);</span><br><span class="line">              p = left;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> i/<span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span>(arr[f] &lt;= arr[i]) &#123;</span><br><span class="line">              swap(arr,f,i);</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          i /= <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="三、Arrays-sort"><a href="#三、Arrays-sort" class="headerlink" title="三、Arrays.sort()"></a>三、Arrays.sort()</h3><p>Java 中的 <code>Arrays.sort()</code> 方法可能会使用多种排序算法，包括：</p><ol><li>快速排序（Quick Sort）：快速排序是一种基于比较的排序算法，它的时间复杂度为 O(n log n)。当数组大小大于阈值（通常为 286）时，Java 会优先选择快速排序。快速排序在大多数情况下都是非常高效的。</li><li>归并排序（Merge Sort）：归并排序是一种基于比较的排序算法，它的时间复杂度为 O(n log n)。当数组大小小于等于阈值（通常为 286）时，Java 可能会选择归并排序或插入排序。此外，当数组中有大量重复元素时，Java 也可能会选择归并排序。</li><li>插入排序（Insertion Sort）：插入排序是一种简单的排序算法，它的时间复杂度为 O(n^2)。当数组大小小于等于阈值（通常为 47）时，Java 可能会选择插入排序。对于小型数组，插入排序是一种非常高效的排序算法。</li><li>TimSort：TimSort 是一种混合排序算法，它结合了归并排序和插入排序的优点。它的时间复杂度为 O(n log n)，并且在处理包含大量重复元素的数组时非常高效。当 Java 检测到数组已经被分割为足够小的块，但每个块本身并不有序时，它可能会使用 TimSort。</li><li>双轴快速排序（Dual-Pivot Quick Sort）：双轴快速排序是一种快速排序的变种，它的时间复杂度为 O(n log n)。当数组大小小于等于阈值（通常为 286）时，Java 可能会选择双轴快速排序或插入排序。双轴快速排序比传统的快速排序更适合处理包含大量重复元素的数组。</li><li>堆排序（Heap Sort）：堆排序是一种基于堆数据结构的排序算法，它的时间复杂度为 O(n log n)。当 Java 检测到数组已经被分割为足够小的块，但每个块本身并不有序时，它可能会使用堆排序。</li></ol><p>需要注意的是，以上列出的排序算法不是 Java 所有可能使用的排序算法，具体实现会根据不同的 JVM 实现和其他因素而有所不同。但是，对于绝大多数情况来说，Java 的 <code>Arrays.sort()</code> 方法会选择最合适的排序算法以达到最优的性能。</p><h3 id="四、Collections-sort"><a href="#四、Collections-sort" class="headerlink" title="四、Collections.sort()"></a>四、Collections.sort()</h3><p><code>Collections.sort()</code> 是 Java 中用于对集合进行排序的方法，它也可能会使用多种排序算法，包括：</p><ol><li>归并排序（Merge Sort）：归并排序是一种基于比较的排序算法，它的时间复杂度为 O(n log n)。在对集合进行排序时，Java 通常会选择归并排序。归并排序在大多数情况下都是非常高效的。</li><li>TimSort：TimSort 是一种混合排序算法，它结合了归并排序和插入排序的优点。它的时间复杂度为 O(n log n)，并且在处理包含大量重复元素的集合时非常高效。当 Java 检测到集合已经被分割为足够小的块，但每个块本身并不有序时，它可能会使用 TimSort。</li></ol><p>需要注意的是，<code>Collections.sort()</code> 方法默认使用自然排序（natural ordering），即根据元素自身的比较方法进行排序。如果集合中的元素没有实现 <code>Comparable</code> 接口或者希望按照其他方式进行排序，则需要使用重载的 <code>sort()</code> 方法，并提供自定义的比较器（<code>Comparator</code>）。</p><p>需要注意的是，以上列出的排序算法不是 Java 所有可能使用的排序算法，具体实现会根据不同的 JVM 实现和其他因素而有所不同。但是，对于绝大多数情况来说，Java 的 <code>Collections.sort()</code> 方法会选择最合适的排序算法以达到最优的性能</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础之认识NlogN的排序</title>
      <link href="/2022/05/24/%E8%AE%A4%E8%AF%86NlogN%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/05/24/%E8%AE%A4%E8%AF%86NlogN%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础-归并排序"><a href="#一、基础-归并排序" class="headerlink" title="一、基础 - 归并排序"></a>一、基础 - 归并排序</h2><p>归并排序思想十分简单，但是利用归并排序的变形，可以解决一些看似较为复杂的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> ;</span><br><span class="line">      mergeSort(array,<span class="number">0</span>,array.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right == left) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        mergeSort(array,left,mid);</span><br><span class="line">        mergeSort(array,mid + <span class="number">1</span>,right);</span><br><span class="line">        merge(array,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span>&#123;</span><br><span class="line"><span class="comment">//归并排序特点，开辟一个辅助数组</span></span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right)&#123;</span><br><span class="line">            help[i++] = array[p1] &lt; array[p2] ? array[p1++] : array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid)&#123;</span><br><span class="line">            help[i++] = array[p1++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= right)&#123;</span><br><span class="line">            help[i++] = array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//排好序数组写回原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : help) &#123;</span><br><span class="line">            array[left++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        solution.mergeSort(nums);</span><br><span class="line">        System.out.println(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、拓展"><a href="#二、拓展" class="headerlink" title="二、拓展"></a>二、拓展</h2><h3 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h3><p><strong>问题描述：</strong></p><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。</p><p><strong>例子：</strong></p><p>求数组 [1,3,4,2,5] 的小和</p><p><strong>分析：</strong></p><p>3 左边比 3 小的数，1</p><p>4 左边比 4 小的数，1、3</p><p>2 左边比 2 小的数，1</p><p>5 左边比 5 小的数，1、3、4、2</p><p>所以小和为 1+1+3+1+1+3+4+2&#x3D;16</p><p><strong>求小和算法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> mergeSort(array,<span class="number">0</span>,array.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right == left) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSum</span> <span class="operator">=</span> mergeSort(array,left,mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightSum</span> <span class="operator">=</span> mergeSort(array,mid + <span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> leftSum + rightSum + merge(array,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span>&#123;</span><br><span class="line"><span class="comment">//开辟辅助数组</span></span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//小和结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right)&#123;</span><br><span class="line">          <span class="comment">//核心步骤，重点在于两边数组都是归并排好序的数组</span></span><br><span class="line">          <span class="comment">//因此array[p2]和其右边的值都大于array[p1]</span></span><br><span class="line">            result += array[p1] &lt; array[p2] ? (right - p2 + <span class="number">1</span>) * array[p1] : <span class="number">0</span>;</span><br><span class="line">            help[i++] = array[p1] &lt; array[p2] ? array[p1++] : array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid)&#123;</span><br><span class="line">            help[i++] = array[p1++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= right)&#123;</span><br><span class="line">            help[i++] = array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : help) &#123;</span><br><span class="line">            array[left++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(solution.mergeSort(nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>小和问题是经典的归并排序变形问题，与此类似的还有逆序对问题</p><h3 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h3><p>在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对（个数）。</p><blockquote><p>仅需改动核心步骤即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依然递增排序</span></span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right)&#123;</span><br><span class="line">  <span class="comment">//核心步骤，重点在于两边数组都是归并排好序的数组</span></span><br><span class="line">  <span class="comment">//打印逆序对</span></span><br><span class="line">  <span class="keyword">if</span>(array[p1] &gt; array[p2])&#123;</span><br><span class="line">  <span class="comment">//p1右边的都比p2大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p1;i&lt;mid;i++)&#123;</span><br><span class="line">      System.out.println(array[p1]+<span class="string">&quot;,&quot;</span>+array[p2]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//逆序对个数</span></span><br><span class="line">  <span class="comment">//result += array[p1] &gt; array[p2] ? (mid - p1 + 1) : 0;</span></span><br><span class="line">  help[i++] = array[p1] &lt; array[p2] ? array[p1++] : array[p2++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆序对与小和问题本质一样，除此之外，还有荷兰国旗问题，是小和问题的轻微进阶版本</p><h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><p>给定一个数组 arr，和一个数 num，请把小于 num 的数放在数组的左边，等于 num 的数放在数组的中间，大于 num 的数放在数组的右边。要求额外空间复杂度 O (1)，时间复杂度 O (N)</p><blockquote><p>返回值含义： 一定会返回一个长度为 2 的数组，等于区域的左边界和右边界（也就是相等区域的边界范围 ）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span>[] partition(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> num) &#123;</span><br><span class="line">    <span class="comment">//less为小于num区的边界，more为大于num的边界，left当做遍历数组的指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; more)&#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[left] &lt; num)&#123;</span><br><span class="line">        swap(arr,left++,++less);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[left] &gt; num)&#123;</span><br><span class="line">        swap(arr,--more,left);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        left++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;less + <span class="number">1</span>,more - <span class="number">1</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    solution.partition(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">    System.out.println(solution.partition(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>,<span class="number">5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p>【1】<a href="https://juejin.cn/post/7137283772797419534">认识认识 O (NlogN) 的排序 | 左程云算法笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础之时间复杂度</title>
      <link href="/2022/04/24/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2022/04/24/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础-简单排序算法"><a href="#一、基础-简单排序算法" class="headerlink" title="一、基础 - 简单排序算法"></a>一、基础 - 简单排序算法</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;<span class="comment">//记录最小值位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;<span class="comment">//改变最小值位置</span></span><br><span class="line">&#125;</span><br><span class="line">swap(arr, i, minIndex);<span class="comment">//交换最小值到前面 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; e &gt; <span class="number">0</span>; e--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(arr, i, i + <span class="number">1</span>);<span class="comment">//把较大数交换到后面</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">//只有i，j两个位置不同时可以这么写</span></span><br><span class="line">    <span class="comment">//否则会将数据抹成0</span></span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">arr[j] = arr[i] ^ arr[j];</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">arr[j] = arr[i] ^ arr[j];</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分法的详解与扩展"><a href="#二分法的详解与扩展" class="headerlink" title="二分法的详解与扩展"></a>二分法的详解与扩展</h3><h4 id="1）在一个有序数组中，找某个数是否存在"><a href="#1）在一个有序数组中，找某个数是否存在" class="headerlink" title="1）在一个有序数组中，找某个数是否存在"></a>1）在一个有序数组中，找某个数是否存在</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">int</span>[] sortedArr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (sortedArr == <span class="literal">null</span> || sortedArr.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> sortedArr.length - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (sortedArr[mid] == num) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sortedArr[mid] &gt; num) &#123;</span><br><span class="line">R = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">L = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sortedArr[L] == num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）在一个有序数组中，找-gt-x3D-某个数最左侧的位置"><a href="#2）在一个有序数组中，找-gt-x3D-某个数最左侧的位置" class="headerlink" title="2）在一个有序数组中，找 &gt;&#x3D; 某个数最左侧的位置"></a>2）在一个有序数组中，找 &gt;&#x3D; 某个数最左侧的位置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在arr上，找满足&gt;=value的最左位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nearestIndex</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">index = mid;</span><br><span class="line">R = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">L = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）局部最小值问题"><a href="#3）局部最小值问题" class="headerlink" title="3）局部最小值问题"></a>3）局部最小值问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到一个局部最小值就返回，会优先找到左边的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLessIndex</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// no exist</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr.length == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[arr.length - <span class="number">1</span>] &lt; arr[arr.length - <span class="number">2</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> arr.length - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//left == right 此时的left 就是下一次的mid</span></span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、拓展-异或运算"><a href="#二、拓展-异或运算" class="headerlink" title="二、拓展 - 异或运算"></a>二、拓展 - 异或运算</h2><h3 id="异或运算的性质与扩展"><a href="#异或运算的性质与扩展" class="headerlink" title="异或运算的性质与扩展"></a>异或运算的性质与扩展</h3><blockquote><p>0^N &#x3D;&#x3D; N N^N &#x3D;&#x3D; 0<br>异或运算满足交换律和结合率<br>不用额外变量交换两个数<br><strong>一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数</strong><br><strong>一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找一个出现了奇数次的数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printOddTimesNum1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">eO</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> cur : arr) &#123;</span><br><span class="line">eO ^= cur;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(eO);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找两个出现了奇数次的数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printOddTimesNum2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">eO</span> <span class="operator">=</span> <span class="number">0</span>, eOhasOne = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> curNum : arr) &#123;</span><br><span class="line">eO ^= curNum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">rightOne</span> <span class="operator">=</span> eO &amp; (~eO + <span class="number">1</span>);<span class="comment">//提取最右边的1出来</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> cur : arr) &#123;</span><br><span class="line">            <span class="comment">//当这个数的最右边一位1 与rightOne 相同时，才将它异或进去</span></span><br><span class="line"><span class="keyword">if</span> ((cur &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">eOhasOne ^= cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(eOhasOne + <span class="string">&quot; &quot;</span> + (eO ^ eOhasOne));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="master-公式"><a href="#master-公式" class="headerlink" title="master 公式"></a>master 公式</h3><blockquote><p>Master 公式用来较为简便地评估递归算法的时间复杂度</p></blockquote><p><strong>T(N) &#x3D; a*T(N&#x2F;b) + O(N^d)</strong></p><p>log (b,a) &gt; d -&gt; 复杂度为 O (N^log (b,a))<br>log (b,a) &#x3D; d -&gt; 复杂度为 O (N^d * logN)<br>log (b,a) &lt; d -&gt; 复杂度为 O (N^d)</p><blockquote><p>其中</p><p>a：生成的子问题数（比如二叉树的递归遍历就是 a &#x3D; 2)<br>b：表示每次递归是母问题的 1&#x2F;b 的数据规模<br>N：母问题的数据规模<br>d：额外操作的次数</p></blockquote><p>参考：</p><p>【1】<a href="https://blog.csdn.net/qq_53098203/article/details/120896749">左神算法 - 基础 01 - 认识复杂度和简单排序算法</a></p><p>【2】[数据结构与算法中的 Master 公式](</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础之集合源码分析</title>
      <link href="/2022/03/21/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/03/21/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="java集合源码分析"><a href="#java集合源码分析" class="headerlink" title="java集合源码分析"></a>java集合源码分析</h2><h3 id="一、java集合"><a href="#一、java集合" class="headerlink" title="一、java集合"></a>一、java集合</h3><h4 id="1-ArrayList源码"><a href="#1-ArrayList源码" class="headerlink" title="1.ArrayList源码"></a>1.ArrayList源码</h4><h5 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认数组长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 默认空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">// 集合大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定初始容量的构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                         initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认空初始化---懒加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入实现了Collection接口的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">           elementData = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="add操作"><a href="#add操作" class="headerlink" title="add操作"></a>add操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最常用方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 确定容量 动态扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 进数组</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定位置插入，不常用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定数组大小并决定是否扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">  ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算较大值 minCapacity是size+1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">      <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 确定是否需要扩容 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存不足，需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">      grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩容 每次扩容1.5倍</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">// 新数组长度 = 1.5 * 旧数组长度</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity); <span class="comment">// 复制到新数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么ArrayList每次扩容容积都要变成原来的1.5倍呢？</p><p>在ArrayList的实现中，每次扩容容量都会增加原来容量的一半。这个增量的选择是为了在避免频繁扩容和节省内存之间寻求一个平衡点。</p><p>具体来说，如果每次只增加一个固定的值，那么当需要容纳大量元素时，ArrayList可能会不断地进行扩容操作，这会导致额外的内存分配和复制元素的开销。而如果每次增加原容量的比例太小，那么ArrayList可能需要频繁进行扩容操作，这同样会导致不必要的开销。</p><p>因此，1.5倍的增量选择是一种折中方案，既可以避免过于频繁的扩容操作，又可以减少额外的内存分配和元素复制的开销。同时，这个增量值也可以根据实际情况进行调整。</p></blockquote><h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">  rangeCheck(index); <span class="comment">// 检查是否数组越界</span></span><br><span class="line">  <span class="keyword">return</span> ArrayList.<span class="built_in">this</span>.elementData(offset + index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在多线程环境下，如果一个线程修改了集合中的元素，而另一个线程正在遍历这个集合，就可能会导致遍历出错。为了避免这种情况的发生，<code>ArrayList</code>类提供了<code>checkForComodification</code>方法，用于检测集合是否在遍历过程中被修改过。</p><p><code>modCount</code>变量表示<code>ArrayList</code>被修改的次数，每次修改（增加或删除元素）时<code>modCount</code>会自增</p></blockquote><h5 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E e)</span> &#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">// 检查是否越界</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> ArrayList.<span class="built_in">this</span>.elementData(offset + index); <span class="comment">// 获取原来下标对应的值</span></span><br><span class="line">    ArrayList.<span class="built_in">this</span>.elementData[offset + index] = e;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;<span class="comment">// 要移动元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 从删除位置往后拷贝删除</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                       numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-LinkedList源码"><a href="#2-LinkedList源码" class="headerlink" title="2.LinkedList源码"></a>2.LinkedList源码</h4><h5 id="前置声明-1"><a href="#前置声明-1" class="headerlink" title="前置声明"></a>前置声明</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组大小</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装的节点类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入实现Collection接口的其他对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增单个节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾插法插入新节点</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">      first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="get方法-1"><a href="#get方法-1" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取index位置数值</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index); <span class="comment">// 检查是否越界</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历查找</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">          x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">          x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="set方法-1"><a href="#set方法-1" class="headerlink" title="set方法"></a>set方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    checkElementIndex(index); <span class="comment">// 检查越界</span></span><br><span class="line">    Node&lt;E&gt; x = node(index); <span class="comment">// 找到节点</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove方法-1"><a href="#remove方法-1" class="headerlink" title="remove方法"></a>remove方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除某一坐标节点</span></span><br><span class="line"> <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">     checkElementIndex(index);</span><br><span class="line">     <span class="keyword">return</span> unlink(node(index)); <span class="comment">// node找到index位置的节点</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 删除节点</span></span><br><span class="line"> E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">     <span class="comment">// assert x != null;</span></span><br><span class="line">     <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">         first = next;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         prev.next = next;</span><br><span class="line">         x.prev = <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">         last = prev;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         next.prev = prev;</span><br><span class="line">         x.next = <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     x.item = <span class="literal">null</span>;</span><br><span class="line">     size--;</span><br><span class="line">     modCount++;</span><br><span class="line">     <span class="keyword">return</span> element;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="3-HashMap源码"><a href="#3-HashMap源码" class="headerlink" title="3.HashMap源码"></a>3.HashMap源码</h4><h5 id="前置声明-2"><a href="#前置声明-2" class="headerlink" title="前置声明"></a>前置声明</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认容初始量 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大容量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认负载因子</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转红黑树阈值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扩容后树转链表阈值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最小树化数组阈值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装的节点---hashmap中数据都以Node结构存储在桶中</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">      <span class="keyword">final</span> K key;</span><br><span class="line">      V value;</span><br><span class="line">      Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">      Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">          <span class="built_in">this</span>.hash = hash;</span><br><span class="line">          <span class="built_in">this</span>.key = key;</span><br><span class="line">          <span class="built_in">this</span>.value = value;</span><br><span class="line">          <span class="built_in">this</span>.next = next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">          <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">          value = newValue;</span><br><span class="line">          <span class="keyword">return</span> oldValue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">              Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">              <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                  Objects.equals(value, e.getValue()))</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 散列函数 使用 扰动函数 将哈希值进一步打乱</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      <span class="type">int</span> h;</span><br><span class="line">      <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定初始化容量与负载因子---很少使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定初始化容量---用于知道hashmap大概要存储多少数据时</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 默认构造方法，使用默认负载因子</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 传进来一个map初始化</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// put方法，本质是调用putVal</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 实际上实现put方法的地方</span></span><br><span class="line">  <span class="comment">/********onlyIfAbsent – if true, don&#x27;t change existing value********/</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                 <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// tab就是哈希桶，也就是数组+链表中的数组部分 p用来指向key对应的桶位置节点</span></span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 未初始化，先resize进行初始化</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// p指向要插入的桶节点位置，判断当前位置是否为空，为空直接把value封装放进去</span></span><br><span class="line">     <span class="comment">// (n - 1) &amp; hash 这一步很妙，与double扩容配合可以使得扩容时，节点要么不移动桶位置，要么+原数组长度移动</span></span><br><span class="line">      <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>) </span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 存在哈希冲突 e是要插入的位置，如果已存在这个key，e就指向这个key对应的节点</span></span><br><span class="line">          Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 桶处的根节点和插入的key相等，直接把e指向p</span></span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              e = p;</span><br><span class="line">        <span class="comment">// 如果桶位置已经树化，调用树的putTreeVal方法</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">              e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value); <span class="comment">// 树版本的putVal</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 未树化，则遍历找到要插入位置</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                  <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                      p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 如果插入之后链表长度达到阈值，尝试树化</span></span><br><span class="line">                      <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                          treeifyBin(tab, hash);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                <span class="comment">// 找到已存在key对应节点</span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  p = e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// key已存在，替换value</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">              <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                  e.value = value;</span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++modCount;</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">      <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">          resize();</span><br><span class="line">      afterNodeInsertion(evict);  <span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试将链表树化</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">      <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 如果数组长度未达阈值（64），则先进行数组扩容</span></span><br><span class="line">      <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">          resize();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">              <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                  hd = p;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  p.prev = tl;</span><br><span class="line">                  tl.next = p;</span><br><span class="line">              &#125;</span><br><span class="line">              tl = p;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">              hd.treeify(tab);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">      <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span> oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// 新容量是原来两倍</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 扩容临界值也两倍</span></span><br><span class="line">              newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">          newCap = oldThr;</span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line">      threshold = newThr;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">      Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123; <span class="comment">// 初始时不需要复制</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                  oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 桶中元素就一个 找到元素新位置赋值</span></span><br><span class="line">                      newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 移动树</span></span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                  <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                      Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; next;</span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line">                          <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                      <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                          loTail.next = <span class="literal">null</span>;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                          hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="get方法-2"><a href="#get方法-2" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取key对应值</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际调用方式</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// first是哈希后桶位置上第一个节点</span></span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接找到</span></span><br><span class="line">          <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">              ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              <span class="keyword">return</span> first;</span><br><span class="line">          <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历树</span></span><br><span class="line">              <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">return</span> e;</span><br><span class="line">              &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="remove方法-2"><a href="#remove方法-2" class="headerlink" title="remove方法"></a>remove方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">          <span class="literal">null</span> : e.value;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 找到节点，删除即可，注意树结构删除节点之后可能会退化</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                             <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">          Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              node = p;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">do</span> &#123;</span><br><span class="line">                      <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                          ((k = e.key) == key ||</span><br><span class="line">                           (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                          node = e;</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                      p = e;</span><br><span class="line">                  &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                               (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">              <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                  tab[index] = node.next;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  p.next = node.next;</span><br><span class="line">              ++modCount;</span><br><span class="line">              --size;</span><br><span class="line">              afterNodeRemoval(node);</span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="4-modCount与FailFast机制"><a href="#4-modCount与FailFast机制" class="headerlink" title="4.modCount与FailFast机制"></a>4.modCount与FailFast机制</h4><p>上面三个类里面，都有monCount变量，那么这个变量是什么，有什么用处呢？</p><p>在 Java 集合中，modCount 是用于实现<strong>“快速失败”</strong>机制的一个计数器，用于跟踪集合对象自创建以来所发生的修改次数。当通过迭代器遍历集合时，如果在迭代过程中发现集合的 modCount 发生了变化，就会立即抛出 ConcurrentModificationException 异常，以避免并发修改导致的数据不一致问题。</p><p>快速失败机制的目的是为了保证多个线程并发操作同一个集合时的数据一致性。如果不使用快速失败机制，可能会导致数据不一致，而且这种不一致的结果可能是不可预测的。</p><p>因此，集合类在实现迭代器时，通常会在每次进行<strong>修改（新增，删除，更新）</strong>操作时，将 modCount 的计数器加 1，以便在下次迭代时检测到修改操作，抛出异常以提醒程序员代码存在问题。同时，这也是 Java 集合框架的一个核心设计原则之一，即在多线程环境中保证数据的一致性。</p><h4 id="5-Vector"><a href="#5-Vector" class="headerlink" title="5.Vector"></a>5.Vector</h4><p>和ArrayList很相似，都是以动态数组的形式来存储数据，但是它是线程安全的，Vector的线程安全来自于每一个操作方法都加上了synchronized关键字，对性能来说有较大影响，目前属于逐渐废弃的方法</p><p>而对于ArrayList这种非线程安全的数组，可以使用Collections工具来实现线程安全，比Vector更加安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">syncList</span> <span class="operator">=</span> Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure><p>本质上是工具类为原方法封装了加锁的同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.get(index);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.set(index, element);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;list.add(index, element);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.remove(index);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>sub_images</title>
      <link href="/sub-images/index.html"/>
      <url>/sub-images/index.html</url>
      
        <content type="html"><![CDATA[<div class="gallery">    <div class="fj-gallery  data" data-rowHeight="220" data-limit="10">    <span class="gallery-data">[]</span>    </div>    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>    </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>images</title>
      <link href="/images/index.html"/>
      <url>/images/index.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://source.fomal.cc/img/default_cover_61.webp' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">封面专区</div>  <p>本站用作文章封面的图片，不保证分辨率</p>  <a href='/box/Gallery/photo'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://source.fomal.cc/img/dm11.webp' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">背景专区</div>  <p>收藏的一些的背景与壁纸，分辨率很高</p>  <a href='/box/Gallery/wallpaper'></a>  </figcaption>  </figure>  </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Gallery</title>
      <link href="/Gallery/index.html"/>
      <url>/Gallery/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>music</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 文章页H1-H6图标样式效果 *//* 控制风车转动速度 4s那里可以自己调节快慢 */h1::before,h2::before,h3::before,h4::before,h5::before,h6::before {  -webkit-animation: ccc 4s linear infinite;  animation: ccc 4s linear infinite;}/* 控制风车转动方向 -1turn 为逆时针转动，1turn 为顺时针转动，相同数字部分记得统一修改 */@-webkit-keyframes ccc {  0% {    -webkit-transform: rotate(0deg);    transform: rotate(0deg);  }  to {    -webkit-transform: rotate(-1turn);    transform: rotate(-1turn);  }}@keyframes ccc {  0% {    -webkit-transform: rotate(0deg);    transform: rotate(0deg);  }  to {    -webkit-transform: rotate(-1turn);    transform: rotate(-1turn);  }}/* 设置风车颜色 */#content-inner.layout h1::before {  color: #ef50a8;  margin-left: -1.55rem;  font-size: 1.3rem;  margin-top: -0.23rem;}#content-inner.layout h2::before {  color: #fb7061;  margin-left: -1.35rem;  font-size: 1.1rem;  margin-top: -0.12rem;}#content-inner.layout h3::before {  color: #ffbf00;  margin-left: -1.22rem;  font-size: 0.95rem;  margin-top: -0.09rem;}#content-inner.layout h4::before {  color: #a9e000;  margin-left: -1.05rem;  font-size: 0.8rem;  margin-top: -0.09rem;}#content-inner.layout h5::before {  color: #57c850;  margin-left: -0.9rem;  font-size: 0.7rem;  margin-top: 0rem;}#content-inner.layout h6::before {  color: #5ec1e0;  margin-left: -0.9rem;  font-size: 0.66rem;  margin-top: 0rem;}/* s设置风车hover动效 6s那里可以自己调节快慢*/#content-inner.layout h1:hover,#content-inner.layout h2:hover,#content-inner.layout h3:hover,#content-inner.layout h4:hover,#content-inner.layout h5:hover,#content-inner.layout h6:hover {  color: var(--theme-color);}#content-inner.layout h1:hover::before,#content-inner.layout h2:hover::before,#content-inner.layout h3:hover::before,#content-inner.layout h4:hover::before,#content-inner.layout h5:hover::before,#content-inner.layout h6:hover::before {  color: var(--theme-color);  -webkit-animation: ccc 6s linear infinite;  animation: ccc 6s linear infinite;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>charts</title>
      <link href="/charts/index.html"/>
      <url>/charts/index.html</url>
      
        <content type="html"><![CDATA[<!-- 文章发布时间统计图 --><div id="posts-chart" data-start="2021-01" style="border-radius: 8px; height: 300px; padding: 10px;"></div><!-- 文章标签统计图 --><div id="tags-chart" data-length="10" style="border-radius: 8px; height: 300px; padding: 10px;"></div><!-- 文章分类统计图 --><div id="categories-chart" data-parent="true" style="border-radius: 8px; height: 300px; padding: 10px;"></div>]]></content>
      
    </entry>
    
    
  
</search>
